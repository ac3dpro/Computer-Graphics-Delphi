unit MathUnit;

interface

uses
  Windows,
  Messages,
  SysUtils,
  Variants,
  Classes,
  Graphics,
  Controls,
  Forms,
  Dialogs,
  Menus,
  IdGlobal,
  Math,
  StdCtrls;

type
  TFloatType = real;
  Int03 = 0..3;
  TMatriz3x3 = array[1..3,1..3]of TFloatType;
  TVetor3x1 = array[1..3]of TFloatType;

  TPointN = array of TPoint;
  TPointMatrizNxN = array of TPointN;

  TVetorN = array of TFloatType;
  TMatrizNxN = array of TVetorN;
  TMatrizN3 = array of TMatrizNxN;
  TMatrizN4 = array of TMatrizN3;

  TVetorIN = array of integer;
  TMatrizINxN = array of TVetorIN;
  TMatrizIN3 = array of TMatrizINxN;
  TMatrizIN4 = array of TMatrizIN3;

  TVetorBN = array of boolean;
  TMatrizBNxN = array of TVetorBN;

  PVetorN = ^TVetorN;
  PMatrizNxN = ^TMatrizNxN;
  PMatrizN3 = ^TMatrizN3;
  PMatrizN4 = ^TMatrizN4;
  PVetorIN = ^TVetorIN;
  PMatrizINxN = ^TMatrizINxN;
  PMatrizIN3 = ^TMatrizIN3;
  PMatrizIN4 = ^TMatrizIN4;
  PVetorBN = ^TVetorBN;
  PMatrizBNxN = ^TMatrizBNxN;

  Word2L = string[2];

  Word3L = string[3];

  TSign = (sgNegative,sgNull,sgPositive);

  TLine = array[1..2]of TPoint;

  TRectPoints = array[1..4]of TPoint;

  TDouble = array of double;

  T2DPoint = record
    X, Y : TFloatType;
  end;

  T3DPoint = record
    X, Y, Z : TFloatType;
  end;

  TVetor3DPoint = array of T3DPoint;

  TSetofPoints3D = record
    N: integer;
    P: TVetor3DPoint
  end;

  T2DLine = array[1..2]of T2DPoint;

  T3DLine = array[1..2]of T3DPoint;

  TPline = record
    ortplan: integer;
    Npoly: integer;
    X, Y: TVetorN;
    Closed : boolean;
  end;

  TPlineIN = record
    ortplan: integer;
    Npoly: integer;
    X, Y: TVetorIN;
    Closed : boolean;
  end;

  T3DPline = record
    Npoly: integer;
    X,Y,Z: TVetorN;
    Closed : boolean;
    Merged: TVetorBN;
  end;

  TPlan = record
    X1, Y1, Z1: TFloatType;
    XN, YN, ZN : TFloatType;
  end;

  TPolySet = array of T3DPline;

  TWire = record
    N : integer;
    P : TPolySet;
  end;

  TTriangle = array[1..3]of T3DPoint;

  TTriangle2D = array[1..3]of T2DPoint;

  TTriangles = array of TTriangle;

  TMesh = record
    N : integer;
    F : TTriangles;
  end;

  TMeshes = array of TMesh;

  TScreenPoint = record    { Pixel with x buffer depth information }
    X : TFloatType;
    P : TPoint;
  end;

  TScreenLine = array of TScreenPoint;

  TScreenPlane = array of TScreenLine;

  TRasterizedTriangle = record
    P : TPoint;
    L : array of array[1..2] of integer;
  end;

  TCamera = record            // Camera Data
    Obs : T3DPoint;           // Observer
    Aim : T3DPoint;           // Target/Aim
    Basis : TMatriz3x3;       // Basis of Camera coordinate system
    Perspective : boolean;    // Perspective turned on/off (True/False)
    xlens : TFloatType;             // X coordinate (depth) relative to Camera Observer. Default is -1
  end;

  TBox = array[1..8]of T3DPoint;   // Box coordinates

  TRGB24 = packed record           // Entity for handling three bytes of color (24 bits)
    B,G,R : Byte;                  // Blue (8 bits), Red (8 bits), Green (8 bits)
  end;

  TRGB24Array = packed array[0..MaxInt div SizeOf(TRGB24)-1] of TRGB24;    // Variable for holding the color of each pixel on a scanline
  PRGB24Array = ^TRGB24Array;       // Pointer of TRGB24Array

  TRGB32 = packed record           // Entity for handling four bytes of color (32 bits)
    B,G,R,A : Byte;                // Blue, Red, Green, Alpha-channel
  end;

  TRGB32Array = packed array[0..MaxInt div SizeOf(TRGB32)-1] of TRGB32;    // Variable for holding the color of each pixel on a scanline
  PRGB32Array = ^TRGB32Array;       // Pointer of TRGB32Array

  TRGBFloat = record
    R,G,B : TFloatType;         // Entity to handle red, green, blue properties of lights
  end;

  TAmbientLight = record
    Ia : TRGBFloat;       // Ambient light intensities
  end;

  TLight = record
    Pos : T3DPoint;
    IL : TRGBFloat;       // Light intensities in (R,G,B)
    Attenuation : byte;   // 0 = none, 1 = linear, 2 = quadratic
  end;

  TMaterial = record
    ka : TRGBFloat;       // Coefficients 0 < ka[r,g,b] < 1
    kd : TRGBFloat;       // Coefficients of diffuse light material interaction
    ks : TRGBFloat;       // Coefficients of specular light material interaction
    Ns : TFloatType;            // Shininess exponent for highlights
  end;

  TLights = array of TLight;

  TCameraSettings = record    // Camera Settings
    RotationType : byte;      // Type of Camera rotation around Aim: 1 = Polar, 2 = Free, 3 = XYZ
    VisibleAim : boolean;     // Shows or not the Aim on screen
  end;

  TLightSettings = record
    Visible : boolean;        // Light point visible on the screen
    Fixed : boolean;          // Light point fixed in the world coordinate system
    PosRelCam : T3DPoint;     // Position of light relative to Camera
  end;

  TLightsSettings = array of TLightSettings;

  TPlineSettings = record
    OnSpline : boolean;
    ShowPoints : boolean;
    LineColor, DotColor, DotBorderColor : TColor;
    DotRadius : byte;
  end;

  TSplineSettings = record
    N : integer;
    Ti, Tm, Tf : TFloatType;
  end;

  TScaleSettings = record            // Scale Settings
    WorldFloat, ScreenFloat, SizeRatio : TFloatType;
  end;

      function MatrizInversa(Matriz : TMatrizNxN; Ndim : integer): TMatrizNxN;
      function MatrizInversa3x3(Matriz : TMatriz3x3): TMatriz3x3;
      function MatrizTrocaLinhas_F(Ndim : integer; L1 : integer; L2 : integer) : TMatrizNxN;
      function MatrizCLinear_F(Ndim : integer; L1 : integer; L2 : integer;
                                               X1 : TFloatType;    X2 : TFloatType) : TMatrizNxN;
      function MTrocaLinhas(Matriz : TMatrizNxN; Ndim : integer; L1 : integer; L2 : integer) : TMatrizNxN;
      function MCLinear(Matriz : TMatrizNxN; Ndim : integer;  L1 : integer;    L2 : integer;
                                                              X1 : TFloatType;       X2 : TFloatType) : TMatrizNxN;
      function ProdutoMatrizes(T : TMatriz3x3; P : TMatriz3x3) : TMatriz3x3;
      function ProdutoMatrizVetor(T : TMatriz3x3; P : TVetor3x1) : TVetor3x1;
      function ProdutoMatrizesN(TN : TMatrizNxN; PN : TMatrizNxN; Ndim : integer) : TMatrizNxN;
      function ProdutoMatrizVetorN(T : TMatrizNxN; P : TVetorN; Ndim : integer) : TVetorN;

      function Array2D_Transpose(N : integer; Np : TVetorIN; Matriz : TMatrizNxN) : TMatrizNxN;
      procedure AddValue(Index : integer; R : TFloatType; var NR : integer; var PR : TVetorN); overload;
      procedure AddValue(Index : integer; R : integer; var NR : integer; var PR : TVetorIN); overload;
      procedure AddValue(Index : integer; R : TFloatType; var PR : TVetorN); overload;
      procedure AddValue(Index : integer; R : integer; var PR : TVetorIN); overload;
      procedure AddValue(Index : integer; R : boolean; var NR : integer; var PR : TVetorBN); overload;

      procedure AddNewValue(Index : integer; R : TFloatType; var NR : integer; var PR : TVetorN); overload;
      procedure AddNewValue(Index : integer; R : integer; var NR : integer; var PR : TVetorIN); overload;
      function FindValue(N : integer; P : TVetorN; R : TFloatType) : integer; overload;
      function FindValue(N : integer; P : TVetorIN; R : integer) : integer; overload;
      procedure Clip(N : integer; P : TVetorN; N1, N2 : integer;
                     var NR : integer; PR : TVetorN);
      procedure AddMinimum(L : TFloatType; N : integer; P : TVetorN;
                           var NR : integer; var PR : TVetorN); overload;
      procedure AddMinimum(L : TFloatType; N : integer; P : TVetorN; var NR : integer;
                           var PR : TVetorN; var Index : integer); overload;
      procedure AddMaximum(L : TFloatType; N : integer; P : TVetorN;
                           var NR : integer; var PR : TVetorN); overload;
      procedure AddMaximum(L : TFloatType; N : integer; P : TVetorN; var NR : integer;
                           var PR : TVetorN; var Index : integer); overload;
      procedure RemoveValue(Index : integer; var X : TDouble); overload;
      procedure RemoveValue(Index : integer; var X : TVetorN); overload;
      procedure RemoveValue(Index : integer; var X : TVetorIN); overload;

      function MInvertivel(Matriz : TMatrizNxN; Ndim : integer) : boolean;
      function MInvertivel3x3(Matriz : TMatriz3x3) : boolean;
      function MatrizTransposta(Matriz : TMatrizNxN; Ndim : integer) : TMatrizNxN; overload;
      function MatrizTransposta(Matriz : TMatriz3x3) : TMatriz3x3; overload;

      function Hypot3D(X,Y,Z : TFloatType) : TFloatType; overload;
      function Hypot3D(P : TVetor3x1) : TFloatType; overload;
      function Hypot3D(P : T3DPoint) : TFloatType; overload;
      function Point2D(X,Y : TFloatType) : T2DPoint;
      function Point3D(X,Y,Z : TFloatType) : T3DPoint; overload;
      procedure Point3D(X,Y,Z : TFloatType; var ResultX, ResultY, ResultZ : TFloatType); overload;
      function Vetor3x1(X,Y,Z : TFloatType) : TVetor3x1;
      function ScreenPoint(P : T3DPoint; SizeRatio : TFloatType; Height, XPan, YPan : integer) : TScreenPoint;
      function Triangle(XP1,YP1,ZP1,XP2,YP2,ZP2,XP3,YP3,ZP3 : TFloatType) : TTriangle; overload;
      function Triangle(P1, P2, P3 : T3DPoint) : TTriangle; overload;
      function Triangle(XP1,YP1,XP2,YP2,XP3,YP3 : TFloatType) : TTriangle2D; overload;
      function Triangle(P1, P2, P3 : T2DPoint) : TTriangle2D; overload;
      function TriangleXY(T : TTriangle) : TTriangle2D;
      function TriangleXZ(T : TTriangle) : TTriangle2D;
      function TriangleYZ(T : TTriangle) : TTriangle2D;
      function RectToPoints(Rect : TRect) : TRectPoints;
      function PointToVector(P : T3DPoint) : TVetor3x1;
      function VectorToPoint(P : TVetor3x1) : T3DPoint;
      function SumPoint3D(Series : TVetor3DPoint) : T3DPoint; overload;
      function SumPoint3D(A, B : T3DPoint) : T3DPoint; overload;
      function SubtractPoint3D(A, B : T3DPoint) : T3DPoint;
      function FactorPoint3D(Point : T3DPoint; const Series : array of TFloatType) : T3DPoint; overload;
      procedure FactorPoint3D(Ratio : TFloatType; var Point : T3DPoint); overload;
      procedure FactorPoint3D(Ratio : TFloatType; var X, Y, Z : TFloatType); overload;
      procedure StretchPoint3D(Ratio : TFloatType; Ref : T3DPoint; var Point : T3DPoint);
      function PolySetToWire(N : integer; PSet : TPolySet) : TWire;

      function EqualPoints(A, B : T2DPoint) : boolean; overload;
      function EqualPoints(AX,AY,BX,BY : TFloatType) : boolean; overload;
      function EqualPoints(A, B : T3DPoint) : boolean; overload;
      function EqualPoints(AX,AY,AZ,BX,BY,BZ : TFloatType) : boolean; overload;
      function EqualPointsR(A, B : T2DPoint) : boolean; overload;
      function EqualPointsR(A, B : T3DPoint) : boolean; overload;
      function EqualTriangle(A, B : TTriangle) : boolean;
      function EqualVectors(N1, N2 : integer; V1, V2 : TVetorN) : boolean;

      function Dist_Points(X1,Y1,X2,Y2 : TFloatType) : TFloatType; overload;
      function Dist_Points(X1,Y1,Z1,X2,Y2,Z2 : TFloatType) : TFloatType; overload;
      function Dist_Points(P1, P2 : T2DPoint) : TFloatType; overload;
      function Dist_Points(P1, P2 : T3DPoint) : TFloatType; overload;
      function DistSQR_Points(X1,Y1,Z1,X2,Y2,Z2 : TFloatType) : TFloatType; overload;
      function DistSQR_Points(P1, P2 : T3DPoint) : TFloatType; overload;
      function Dist_PointToLine(X,Y,X1,Y1,X2,Y2 : TFloatType) : TFloatType; overload;
      function Dist_PointToLine(X,Y,Z,X1,Y1,Z1,X2,Y2,Z2 : TFloatType) : TFloatType; overload;
      function Dist_PointToLine(P,P1,P2 : T3DPoint) : TFloatType; overload;
      function Dist_PointToLineR(X,Y,Z,X1,Y1,Z1,X2,Y2,Z2 : TFloatType) : TFloatType;
      function Dist_PointToPlan(X,Y,Z : TFloatType; X1,Y1,Z1,XN,YN,ZN : TFloatType) : TFloatType; overload;
      function Dist_PointToPlan(X,Y,Z : TFloatType; P : TPlan) : TFloatType; overload;
      procedure Projection_PointToPlan(X,Y,Z : TFloatType; X1,Y1,Z1,XN,YN,ZN : TFloatType;
                                 var XR,YR,ZR : TFloatType); overload;
      procedure Projection_PointToPlan(X,Y,Z : TFloatType; Plan : TPlan; var XR,YR,ZR : TFloatType); overload;
      function Projection_PointToPlan(P : T3DPoint; Plan : TPlan) : T3DPoint; overload;
      function Dist_PointToTriangle(X,Y,Z : TFloatType; X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3 : TFloatType) : TFloatType;
      function Plan_Possible(X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3 : TFloatType) : boolean;
      function Plan3D(X1,Y1,Z1,XN,YN,ZN : TFloatType) : TPlan;
      function PlanOpposite(P : TPlan) : TPlan;
      function Volume_Pyramid(XV,YV,ZV,X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3 : TFloatType) : TFloatType;

      function MinValueIndex(X : TDouble) : integer;
      function MaxValueIndex(X : TDouble) : integer;
      function MinIndex(X : TDouble) : integer;
      function MaxIndex(X : TDouble) : integer;
      function MinValueN(X : TVetorN) : TFloatType;
      function MaxValueN(X : TVetorN) : TFloatType;
      function MeanValueN(X : TVetorN) : TFloatType;

      function MaxX(A,B : TFloatType) : TFloatType; overload;
      function MaxX(A,B : integer) : integer; overload;
      function MinX(A,B : TFloatType) : TFloatType; overload;
      function MinX(A,B : integer) : integer; overload;
      function Confine(X, A, B : TFloatType) : TFloatType; overload;
      function Confine(X, A, B : integer) : integer; overload;
      function ConfineX(X, A, B : TFloatType) : TFloatType; overload;
      function ConfineX(X, A, B : integer) : integer; overload;
      function StepCicleFloat(R, Max, Step : TFloatType) : TFloatType;
      function StepCicleInteger(R, Max, Step : integer) : integer;
      function StepCicleNatural(R, Max, Step : integer) : integer;
      function SymInteger(R, Max : integer) : integer;
      function SymIntegerFZero(R, Max : integer) : integer;
      function InvSymInteger(R, Max : integer) : integer;

      procedure Change_Base(X,Y,Z : TFloatType; Xo,Yo,Zo,Xx,Xy,Xz,Yx,Yy,Yz,Zx,Zy,Zz : TFloatType;
                            var XResult,YResult,ZResult : TFloatType);
      procedure Change_Base_Plan(X,Y,Z,X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3 : TFloatType;
                                 var XResult,YResult,ZResult : TFloatType); overload;
      procedure Change_Base_Plan(X, Y, Z : TFloatType; T : TTriangle;
                                 var XResult,YResult,ZResult : TFloatType); overload;
      procedure Change_Base_Plan(X, Y, Z : TFloatType; P : TPlan; XRef,YRef,ZRef : TFloatType;
                                 var XResult,YResult,ZResult : TFloatType); overload;
      procedure Plan_BaseAxis(P : TPlan; X,Y,Z : TFloatType; var X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3 : TFloatType); overload;
      function Plan_BaseAxis(P : TPlan; X,Y,Z : TFloatType) : TMatriz3x3; overload;
      procedure Change_Base_Orthonormal(X,Y,Z,Xo,Yo,Zo,Xx,Xy,Xz,Yx,Yy,Yz,Zx,Zy,Zz : TFloatType;
                                        var XResult,YResult,ZResult : TFloatType);
      function OrthonormalBase(Xx,Xy,Xz,Yx,Yy,Yz,Zx,Zy,Zz : TFloatType) : TMatriz3x3;
      function OrthonormalBaseTriangle(T : TTriangle) : TMatriz3x3;
      procedure VetorUnitario(X,Y,Z : TFloatType; var XResult,YResult,ZResult : TFloatType); overload;
      function VetorUnitario(P : TVetor3x1) : TVetor3x1; overload;
      function VetorUnitario(P : T3DPoint) : T3DPoint; overload;
      procedure ProdutoVetorial(x1 : TFloatType; y1 : TFloatType; z1 : TFloatType;
                                x2 : TFloatType; y2 : TFloatType; z2 : TFloatType;
                                var x3 : TFloatType; var y3 : TFloatType; var z3 : TFloatType); overload;
      function ProdutoVetorial(P1, P2 : T3DPoint): T3DPoint; overload;
      procedure ProdutoVetorial(N1, N2 : T3DPoint; var Result : TVetor3x1); overload;
      function ProdutoVetorial(P1, P2 : TVetor3x1): TVetor3x1; overload;
      procedure ProdutoVetorial(N1, N2 : TVetor3x1; var Result : T3DPoint); overload;
      function ProdutoVetorial_ABS(x1 : TFloatType; y1 : TFloatType; z1 : TFloatType;
                                   x2 : TFloatType; y2 : TFloatType; z2 : TFloatType) : TFloatType; overload;
      function ProdutoVetorial_ABS(P1, P2 : T3DPoint) : TFloatType; overload;
      function ProdutoVetorial_ABS(P1, P2 : TVetor3x1) : TFloatType; overload;
      function ProdutoVetorial2D(x1 : TFloatType; y1 : TFloatType; x2 : TFloatType; y2 : TFloatType) : TFloatType;
      function RectNull(R : TRect) : boolean;
      procedure TriangleNormalVector(T : TTriangle; var XN, YN, ZN : TFloatType); overload;
      function TriangleNormalVector(T : TTriangle) : T3DPoint; overload;
      function TriangleCenter(T : TTriangle) : T3DPoint; overload;
      procedure TriangleCenter(T : TTriangle; var X, Y, Z : TFloatType); overload;
      function TriangleArea(T : TTriangle) : TFloatType; overload;
      function TriangleArea(T : TTriangle2D) : TFloatType; overload;
      function TriangleAreaXY(T : TTriangle) : TFloatType;
      function TriangleAreaYZ(T : TTriangle) : TFloatType;
      function TriangleAreaZX(T : TTriangle) : TFloatType;
      function TriangleMinX(T : TTriangle) : TFloatType;
      function TriangleMaxX(T : TTriangle) : TFloatType;
      function TriangleMinY(T : TTriangle) : TFloatType;
      function TriangleMaxY(T : TTriangle) : TFloatType;
      function TriangleMinZ(T : TTriangle) : TFloatType;
      function TriangleMaxZ(T : TTriangle) : TFloatType;
      function TriangleGreaterX(T : TTriangle; X : TFloatType) : boolean;
      function TriangleGreaterEqX(T : TTriangle; X : TFloatType) : boolean;
      function TriangleLowerX(T : TTriangle; X : TFloatType) : boolean;
      function TriangleLowerEqX(T : TTriangle; X : TFloatType) : boolean;
      function TrianglePlanPositiveSide(T : TTriangle; P : TPlan) : boolean;
      function TrianglePlanPositiveEqSide(T : TTriangle; P : TPlan) : boolean;
      function TriangleCenterPlanPositiveSide(T : TTriangle; P : TPlan) : boolean;
      function TrianglePlanNegativeSide(T : TTriangle; P : TPlan) : boolean;
      function TriangleInsidePlan(T : TTriangle; P : TPlan) : boolean;
      function Triangle_Plan_Intersection(T : TTriangle; P : TPlan) : TVetor3DPoint;
      function TriangleTrim(T : TTriangle; P : TPlan) : TTriangles;
      function TriangleSlice(T : TTriangle; P : TPlan) : TTriangles;
      function TrianglePointOnEdge2D(X, Y : TFloatType; T : TTriangle) : boolean;
      procedure TriangleDivisionVertex(T : TTriangle; var Index1, Index2 : Int03; var P : T3DPoint);
      procedure TriangleMaximumVerticalGapIndex(T : TTriangle; var Index1, Index2 : Int03);
      procedure TriangleYZUpDown(T : TTriangle;   var T1,T2 : TTriangle);
      procedure Triangle2DUpDown(T : TTriangle2D; var T1,T2 : TTriangle2D);

      function PlanePointDepth(Y,Z,X1,Y1,Z1,XN,YN,ZN : TFloatType) : TFloatType;
      function PlanePointDepthPersp(Y,Z,xV,X1,Y1,Z1,XN,YN,ZN : TFloatType) : TFloatType;
      procedure ProdutoEscalar(x1 : TFloatType; y1 : TFloatType; z1 : TFloatType;
                               x2 : TFloatType; y2 : TFloatType; z2 : TFloatType;
                               var PEResult : TFloatType); overload;
      procedure ProdutoEscalar(P1, P2 : T3DPoint; var PEResult : TFloatType); overload;
      function ProdutoEscalar(x1 : TFloatType; y1 : TFloatType; z1 : TFloatType;
                              x2 : TFloatType; y2 : TFloatType; z2 : TFloatType) : TFloatType; overload;
      function ProdutoEscalar(P1, P2 : T3DPoint) : TFloatType; overload;
      function ProdutoEscalar(P1, P2 : TVetor3x1) : TFloatType; overload;
      function ProdutoEscalar_ANG(x1 : TFloatType; y1 : TFloatType; z1 : TFloatType;
                                  x2 : TFloatType; y2 : TFloatType; z2 : TFloatType) : TFloatType; overload;
      function ProdutoEscalar_ANG(P1, P2 : T3DPoint) : TFloatType; overload;
      function ProdutoEscalar_ANG(P1, P2 : TVetor3x1) : TFloatType; overload;

      procedure MirrorToVector(X1,Y1,Z1,X2,Y2,Z2 : TFloatType; X,Y,Z : TFloatType;
                               var XResult, YResult, ZResult : TFloatType);
      procedure MirrorToTriangle(X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3 : TFloatType; X,Y,Z : TFloatType;
                                 var XResult, YResult, ZResult : TFloatType);
      procedure MirrorToPlan(X1,Y1,Z1,XN,YN,ZN : TFloatType; X,Y,Z : TFloatType;
                             var XResult, YResult, ZResult : TFloatType); overload;
      procedure MirrorToPlan(Plan : TPlan; X,Y,Z : TFloatType;
                             var XResult, YResult, ZResult : TFloatType); overload;
      function MirrorToPlan(Plan : TPlan; P : T3DPoint) : T3DPoint; overload;

      function RefSort(N : integer; P : TVetorN; Key : TVetorIN) : TVetorN; overload;
      function RefSort(N : integer; P : TDouble; Key : TVetorIN) : TDouble; overload;
      function RefSort(N : integer; P : TVetorIN; Key : TVetorIN) : TVetorIN; overload;
      function RefSort(N : integer; P : TMatrizNxN; Key : TVetorIN) : TMatrizNxN; overload;
      function RefSort(N : integer; P : TMatrizN3; Key : TVetorIN) : TMatrizN3; overload;
      function RefSort(N : integer; P : TPointMatrizNxN; Key : TVetorIN) : TPointMatrizNxN; overload;
      function RefSort(N : integer; P : TPolySet; Key : TVetorIN) : TPolySet; overload;
      function RefSort(N : integer; P : TTriangles; Key : TVetorIN) : TTriangles; overload;

      function SelectionSort(N : integer; P : TVetorN) : TVetorN; overload;    { ordenação por Seleção Direta }
      function SelectionSort(N : integer; P : TVetorIN) : TVetorIN; overload;
      function SelectionSort(N : integer; P : TDouble) : TDouble; overload;

      function QuickSort(N : integer; P  : TVetorN) : TVetorN; overload;    { ordenação por QuickSort }
      function QuickSort(N : integer; P : TDouble) : TDouble; overload;
      function QuickSort(N : integer; P : TVetorIN) : TVetorIN; overload;

      function QuickSortMap(N : integer; P  : TVetorN; var Key : TVetorIN) : TVetorN; overload;    { ordenação por QuickSort }
      function QuickSortMap(N : integer; P : TDouble; var Key : TVetorIN) : TDouble; overload;     { key = mapa de ordenação }
      function QuickSortMap(N : integer; P : TVetorIN; var Key : TVetorIN) : TVetorIN; overload;

      procedure SwapPos(N : integer; var P : TVetorN; N1, N2 : integer); overload;
      procedure SwapPos(N : integer; var P : TMatrizNxN; N1, N2 : integer); overload;
      procedure SwapPos(N : integer; var P : TVetorIN; N1, N2 : integer); overload;
      procedure SwapPos(N : integer; var P : TMatrizINxN; N1, N2 : integer); overload;
      procedure SwapPos(N : integer; var P : TPolySet; N1, N2 : integer); overload;
      procedure SwapValues(var A, B : integer); overload;
      procedure SwapValues(var A, B : TFloatType); overload;

      function Greater(X : TFloatType; A : TFloatType; Precision : TFloatType) : boolean;
      function GreaterEq(X : TFloatType; A : TFloatType; Precision : TFloatType) : boolean;
      function Lower(X : TFloatType; A : TFloatType; Precision : TFloatType) : boolean;
      function LowerEq(X : TFloatType; A : TFloatType; Precision : TFloatType) : boolean;
      function Equal(X : TFloatType; A : TFloatType; Precision : TFloatType) : boolean;
      function Unequal(X : TFloatType; A : TFloatType; Precision : TFloatType) : boolean;
      function Between(X : TFloatType; A, B : TFloatType; Precision : TFloatType) : boolean; overload;
      function Between(X : integer; A, B : integer) : integer; overload;
      function BetweenEq(X : TFloatType; A, B : TFloatType; Precision : TFloatType) : boolean;
      function OutRange(X : TFloatType; A, B : TFloatType; Precision : TFloatType) : boolean;
      function OutRangeEq(X : TFloatType; A, B : TFloatType; Precision : TFloatType) : boolean;

      function PointInsideLine(X,Y,X1,Y1,X2,Y2 : TFloatType) : boolean; overload;
      function PointInsideLine(X,Y,Z,X1,Y1,Z1,X2,Y2,Z2 : TFloatType) : boolean; overload;
      function PointInsideLineR(X,Y,X1,Y1,X2,Y2 : TFloatType) : boolean; overload;
      function PointInsideLineR(X,Y,Z,X1,Y1,Z1,X2,Y2,Z2 : TFloatType) : boolean; overload;
      function PointInsideTriangle(X, Y, Z : TFloatType; T : TTriangle) : boolean;
      function PointInsideTriangle2D(X, Y : TFloatType; T : TTriangle) : boolean;

      function Linear_Interpolation(X : TFloatType; X1,Y1,X2,Y2 : TFloatType) : TFloatType;
      function Linear_IntegerInterpolation(X : integer; X1,Y1,X2,Y2 : TFloatType) : integer;
      procedure Linear_Intersection(X1,Y1,X2,Y2,X3,Y3,X4,Y4 : TFloatType; var Intersect : boolean;
                                    var X, Y : TFloatType);
      procedure Line_Plan_Intersection(X1,Y1,Z1,X2,Y2,Z2,Xp,Yp,Zp,XN,YN,ZN : TFloatType;
                                       var Intersect : boolean; var X,Y,Z : TFloatType); overload;
      procedure Line_Plan_Intersection(X1,Y1,Z1,X2,Y2,Z2 : TFloatType; P : TPlan;
                                       var Intersect : boolean; var X,Y,Z : TFloatType); overload;
      procedure Line_Plan_Intersection(X1,Y1,Z1,X2,Y2,Z2 : TFloatType; P : TPlan;
                                       var Intersect : boolean; var Pts : TSetofPoints3D); overload;

      function Line2D(P1,P2 : T2DPoint) : T2DLine;

      function RGBFloat(R, G, B : TFloatType) : TRGBFloat;
      procedure ColorToRGBBytes(Color : TColor; var R, G, B : Byte);
      function ColorToRGBFloat(Color : TColor) : TRGBFloat;
      function ColorToRGBFloatNorm(Color : TColor) : TRGBFloat;
      function MaterialFloat(kaR,kaG,kaB,kdR,kdG,kdB,ksR,ksG,ksB,MNs : TFloatType) : TMaterial; overload;
      function MaterialFloat(Mka, Mkd, Mks : TRGBFloat; MNs : TFloatType) : TMaterial; overload;
      procedure MaterialColor(Color : TColor; var M : TMaterial);
      function IntegerToRoman(N : Integer) : WideString;
      function FlipBoolean(X : boolean) : boolean;

      function REGRA_SIMPSON(x1 : TFloatType; y1 : TFloatType; x2 : TFloatType; y2 : TFloatType; x3 : TFloatType; y3 : TFloatType) : TFloatType;

      procedure SplineCubico(X : array of TFloatType; t : array of TFloatType; Np : integer; Nintm : integer;
                           var XS : TVetorN; var NpS : integer);
      procedure SplineCubico_Pline(Poly : TPline; Uniform_TF : boolean; var PolyResult : TPline);
      procedure SplineCubicoT(X : array of TFloatType; t : array of TFloatType; Np : integer; Nintm : integer;
                              var XS : TVetorN; var NpS : integer);
      procedure SplineCubicoT_Pline(Poly : TPline; Uniform_TF : boolean; dTension : TFloatType; var PolyResult : TPline);
      function CatmullRomSpline(Poly : TPline; Ts,Ts_1,Ts_N : TFloatType; Nintm : integer) : TPline; overload;
      function CatmullRomSpline(Poly : TPlineIN; Ts,Ts_1,Ts_N : TFloatType; Nintm : integer) : TPlineIN; overload;
      function CatmullRomSplineDyDx(Poly : TPline; Ts, D1, DN : TFloatType; Nintm : integer) : TPline; overload;
      function CatmullRomSplineDyDx(Poly : TPlineIN; Ts, D1, DN : TFloatType; Nintm : integer) : TPlineIN; overload;
      function CatmullRomSpline3D(Poly : T3DPline; Ts,Ts_1,Ts_N : TFloatType; Nintm : integer) : T3DPline;
      function CatmullRomSplineX(Poly : TPline; Ts_1,Ts_N : TFloatType; Nintm : integer) : TPline; overload;
      function CatmullRomSplineX(Poly : TPlineIN; Ts_1,Ts_N : TFloatType; Nintm : integer) : TPlineIN; overload;
      function Ellipse_3_Points(X1, Y1, X2, Y2, XC, YC : TFloatType; Nintm : integer; CW, Inner: Boolean) : TPline;

      function Matrix3x3ToNxN(Matrix : TMatriz3x3) : TMatrizNxN;
      function MatrixNxNTo3x3(Matrix : TMatrizNxN) : TMatriz3x3;
      function MatrixToStr(Matrix : TMatrizNxN; Ndim : integer; Format : TFloatFormat;
                                                        Precision, Digits : Integer) : string;
      function PointToStr(X,Y,Z : TFloatType; SpaceChar : string; Format : TFloatFormat;
                          Precision, Digits : Integer) : string; overload;
      function PointToStr(X,Y : TFloatType; SpaceChar : string; Format : TFloatFormat;
                          Precision, Digits : Integer) : string; overload;
      function PointToStr(P : T3DPoint; SpaceChar : string; Format : TFloatFormat;
                          Precision, Digits : Integer) : string; overload;
      function PointToStr(P : TPoint; SpaceChar : string) : string; overload;
      function PolyToStr(Poly : TPline; SpaceChar : string; Format : TFloatFormat;
                         Precision, Digits : Integer) : string; overload;
      function PolyToStr(Poly : T3DPline; SpaceChar : string; Format : TFloatFormat;
                         Precision, Digits : Integer) : string; overload;
      function PolyToStr(N : integer; X, Y, Z : TVetorN; SpaceChar : string; Format : TFloatFormat;
                         Precision, Digits : Integer) : string; overload;
      function PolyToStr(N : integer; X, Y : TVetorN; SpaceChar : string; Format : TFloatFormat;
                         Precision, Digits : Integer) : string; overload;
      function TriangleToStr(F : TTriangle; SpaceChar : string; Format : TFloatFormat;
                             Precision, Digits : Integer) : string; overload;
      function TriangleToStr(F : TTriangle; SpaceChar,SpacePointChar : string; Format : TFloatFormat;
                             Precision, Digits : Integer) : string; overload;
      function TriangleToStrId(F : TTriangle; SpaceChar,SpacePointChar : string; Format : TFloatFormat;
                               Precision, Digits : Integer) : string;
      function RectToStr(R : TRect; SpaceChar : string) : string;
      function VectorToStr(P : TVetorN; SpaceChar : string; Format : TFloatFormat;
                           Precision, Digits : Integer) : string; overload;
      function VectorToStr(P : TVetorIN; SpaceChar : string) : string; overload;
      function RGBFloatToStr(P : TRGBFloat; SpaceChar : string; Format : TFloatFormat;
                             Precision, Digits : Integer) : string;
      function RGB24ToStr(P : TRGB24; SpaceChar : string) : string;

      procedure SetLength3DPline(var P : T3DPline; N : integer);
      function SetMatrixDim(Matrix : TMatrizNxN; Ndim : integer) : TMatrizNxN;
      function SetMatrixDimN2(Matrix : TMatrizNxN; Ndim1,Ndim2 : integer) : TMatrizNxN;
      function SetMatrixDimN3(Matrix : TMatrizN3; Ndim1,Ndim2,Ndim3 : integer) : TMatrizN3;
      function SetMatrixDimN4(Matrix : TMatrizN4; Ndim1,Ndim2,Ndim3,Ndim4  : integer) : TMatrizN4;
      function SetMatrixDimIN2(Matrix : TMatrizINxN; Ndim1,Ndim2 : integer) : TMatrizINxN;
      function SetMatrixDimIN3(Matrix : TMatrizIN3; Ndim1,Ndim2,Ndim3 : integer) : TMatrizIN3;
      function SetMatrixDimIN4(Matrix : TMatrizIN4; Ndim1,Ndim2,Ndim3,Ndim4  : integer) : TMatrizIN4;
      function InitializeMatrix(Rows, Columns : integer; Value : TFloatType) : TMatrizNxN; overload;
      function InitializeMatrix(Rows, Columns : integer; Value : integer) : TMatrizINxN; overload;
      function InitializeMatrix(Rows, Columns : integer; Value : boolean) : TMatrizBNxN; overload;
      procedure InitializePoint(X, Y, Z : TFloatType; var XResult : TFloatType; var YResult : TFloatType;
                                var ZResult : TFloatType);

      procedure WriteonDXF_Poly(var DXF : text; Layer : string; color : integer; closed : boolean;
                               Initial, Final, Npoly : integer; X, Y, Z : TVetorN;
                               MinWidth, DecPlaces : integer);
     procedure WriteonDXF_3DFace(var DXF : text; Layer : string; color : integer;
                                 X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3 : TFloatType; MinWidth, DecPlaces : integer);
     procedure WriteonDXF_SetofPoly(var DXF : text; Layer : string; color : integer;
                                    PolySet : TWire; MinWidth, DecPlaces : integer);
     procedure WriteonDXFStr_Poly(var DXF : string; Layer : string; color : integer; closed : boolean;
                                  Initial, Final, Npoly : integer; X, Y, Z : TVetorN;
                                  Format : TFloatFormat; Precision, Digits : integer);
     procedure WriteonDXFStr_SetofPoly(var DXF : string; Layer : string; color : integer;
                                       PolySet : TWire;
                                       Format : TFloatFormat; Precision, Digits : integer);
     procedure WriteonDXFStr_3DFace(var DXF : string; Layer : string; color : integer;
                                    X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3 : TFloatType;
                                    Format : TFloatFormat; Precision, Digits : integer);
     procedure WriteonTXT_Str(var TXT : text; StrTxt : string);
     procedure WritelnonTXT_Str(var TXT : text; StrTxt : string);
     procedure StringToText(var TXT : text; FileName, StrTxt : string);
     procedure StringToPoint(Str : string; var X : TFloatType; var Y : TFloatType; var Z : TFloatType);
     function NumberPosStr(Start : integer; Str : string) : integer;
     procedure FiltroNumerosReais(Palavra : TEdit; Chave: Char; var chaveResult : char);
     procedure FiltroNumerosInteiros(Palavra : TEdit; Chave: Char; var chaveResult : char);
     procedure FiltroNumerosNaturais(Chave: Char; var chaveResult : char);
     procedure FiltroNumerosReaisPositivos(Palavra : TEdit; Chave: Char; var chaveResult : char); overload;
     function SetStrToFloat(const S : string; default : TFloatType) : TFloatType;
     function SetStrToRGBFloat(const SR, SG, SB : string; default : TRGBFloat) : TRGBFloat;
     function SetStrToInt(const S : string; default : integer) : integer;
     function StartStrToFloatDefault(S : string; default : TFloatType; F : TFloatFormat;
                                     Precision, Digits : integer) : string;
     procedure ReadPoint(XStr,YStr,ZStr : string; Default : T3DPoint; var P : T3DPoint); overload;
     procedure ReadPoint(XStr,YStr,ZStr : string; XDefault,YDefault,ZDefault : TFloatType;
                         var X, Y, Z : TFloatType); overload;
     function ExtractNaturalStr(S : string) : string;
     function EvaluateFloatStr(Start : integer; S : string) : TFloatType;
     function ExtractFloatStr(Start : integer; S : string; var Last : integer) : string;
     procedure ExtractFloatVectorStr(Str : string; var N : integer; var FloatVector : TVetorN);
     function FindChar(C : char; S : string) : boolean;
     function FindFirstNatural(S : string; var Pos : integer) : integer;
     function FindString(S : string; Source : string) : boolean;

type TPPline = class
     public
       class function AddPoint(Poly : TPline; X, Y : TFloatType; N : integer) : TPline; overload;
       class function AddPoint(Poly : TPlineIN; X, Y : integer; N : integer) : TPlineIN; overload;
       class function Area(Poly : TPline) : TFloatType;
       class function CCW(Poly : TPline) : boolean;
       class function PointFromPolyline(Poly : TPlineIN; X, Y : Integer; T : integer) : integer;
       class function Gap(Poly : TPline) : boolean; overload;
       class function Gap(Poly : TPlineIN) : boolean; overload;
       class function Join(Poly_1 : TPline; Poly_2 : TPline) : TPline;
       class function MultiPoly_Scan_Min(MPol : TWire; PolyDirection : char; NPolyInitial : integer;
                                         DirectionScan : char; Scan : TFloatType) : TPline;
       class function PointsToPline(NPts : integer; Xi, Yi, Xf, Yf : TFloatType;
                                    X, Y : TVetorN; Closed : boolean) : TPline;
       class procedure Reference_Pline(XOrigin, YOrigin : TFloatType; var Poly : TPline);
       class procedure Move_Pline(X, Y : TFloatType; var Poly : TPline);
       class procedure RemovePoint(N : integer; X, Y : TVetorN; Npt : integer;
                                   var NResult : integer; var XResult, YResult : TVetorN);
       class procedure RemoveRepeatedPts(N : integer; X, Y : TVetorN;
                                         var NResult : integer; var XResult, YResult : TVetorN);
       class function Reset(Poly : TPline) : TPline; overload;
       class function Reset(Poly : TPlineIN) : TPlineIN; overload;
       class procedure ScanGrid(NPoly : integer; X, Y : TVetorN; DirectionScan : char; NScan : integer; Grid : TVetorN;
                                var GridResult, ScanResult : TMatrizNxN;
                                var NScanResult : TVetorIN; var NResult : integer);
       class procedure ScanGrid_Max(NPoly : integer; X, Y : TVetorN; DirectionScan : char; NScan : integer;
                                    Grid : TVetorN; var NResult : TVetorBN; var ScanResult : TVetorN);
       class procedure ScanGrid_Min(NPoly : integer; X, Y : TVetorN; DirectionScan : char; NScan : integer;
                                    Grid : TVetorN; var NResult : TVetorBN; var ScanResult : TVetorN);
       class procedure Scan_Max(NPoly : integer; X, Y : TVetorN; DirectionScan : char;
                                Scan : TFloatType; var NResult : boolean; var ScanResult : TFloatType);
       class procedure Scan_Min(NPoly : integer; X, Y : TVetorN; DirectionScan : char;
                                Scan : TFloatType; var NResult : boolean; var ScanResult : TFloatType);
       class function Sym_MainAxis(Poly : TPline; X, Y : boolean) : TPline;
       class procedure Uniforme_Poligonal(NpontosE : integer; NpontosS : integer; Xpol : TVetorN; Ypol : TVetorN;
                                          var NpontosF : integer; var XpolF : TVetorN; var YpolF : TVetorN);
       class procedure Uniforme_PoligonalN(NpontosE : integer; NpontosS : integer; Xpol : TVetorN; Ypol : TVetorN;
                                           var NpontosF : integer; var XpolF : TVetorN; var YpolF : TVetorN);
     end;

type  TPoly = class
      public
        class function AddNewPoint(Poly : T3DPline; X, Y, Z : TFloatType; N : integer) : T3DPline;
        class procedure AddPoint(N : integer; X, Y, Z : TFloatType; var Poly : T3DPline); overload;
        class procedure AddPoint(N : integer; X, Y, Z : TFloatType; var PN : integer;
                                 var PX, PY, PZ : TVetorN); overload;
        class function Align(Poly_1 : T3DPline; Poly_2 : T3DPline) : T3DPline;
        class function Align_R(Poly_1 : T3DPline; Poly_2 : T3DPline) : T3DPline;
        class function Area(Poly : T3DPline) : TFloatType;
        class function Break(Poly : T3DPline; N1, N2 : integer) : T3DPline;
        class function CCW(Poly : T3DPline) : boolean;
        class function Close(Poly : T3DPline) : T3DPline;
        class function CoincidentTest(Poly_1, Poly_2 : T3DPline) : boolean;
        class function EqualTest(Poly_1, Poly_2 : T3DPline) : boolean;
        class function FindClosestPoint(X, Y, Z : TFloatType; Poly : T3DPline) : integer;
        class function Gap(Poly : T3DPline) : boolean;
        class function Gap_Coord(X1,Y1,Z1,XN,YN,ZN : TFloatType) : boolean;

        class function LeftofXBoundary(Poly : T3DPline; X1, X2 : TFloatType) : boolean;
        class function RightofXBoundary(Poly : T3DPline; X1, X2 : TFloatType) : boolean;
        class function IncreasePoints(N, First, Last : integer; P : T3DPline) : T3DPline;
        class function InsideXBoundary(Poly : T3DPline; X1, X2 : TFloatType) : boolean;
        class function InsideXBoundaryEq(Poly : T3DPline; X1, X2 : TFloatType) : boolean;
        class function InXCoordinate(Poly : T3DPline; X : TFloatType) : boolean;
        class function InsidePlanBoundary(Poly : T3DPline; P : TPlan) : boolean; overload;
        class function InsidePlanBoundary(Poly : T3DPline; X1,Y1,Z1,XN,YN,ZN : TFloatType) : boolean; overload;
        class function InsidePlan(Poly : T3DPline; P : TPlan) : boolean; overload;
        class function InsidePlan(Poly : T3DPline; X1,Y1,Z1,XN,YN,ZN : TFloatType) : boolean; overload;

        class procedure Poly_Plan_Intersection(Poly : T3DPline; P : TPlan; var Intersect : boolean;
                                               var Points : TSetofPoints3D);
        class procedure MultiPoly_Plan_Intersection(MPol : TWire; P : TPlan; var Intersect : boolean;
                                                    var Points : TSetofPoints3D);
        class function Join(Poly_1 : T3DPline; Poly_2 : T3DPline) : T3DPline;
        class function Mirror(Poly : T3DPline; Plan : TPlan) : T3DPline;
        class function Plan(Poly : T3DPline) : boolean;
        class function Pline_2Dto3D(Poly : TPline; DeepCoord : TFloatType; Plan : Word2L) : T3DPline; overload;
        class function Pline_2Dto3D(Poly : TPline; N : integer; X,Y,Z,XRef,YRef,ZRef : TFloatType;
                                    Plan : TPlan) : T3DPline; overload;
        class function Point(Poly : T3DPline; N : integer) : T3DPoint;
        class function PointIndex(X, Y, Z : TFloatType; Poly : T3DPline) : integer;
        class procedure PolyToPoints(Poly : T3DPline; var X, Y, Z : TVetorN);
        class function PointsToPoly(N : integer; X, Y, Z : TVetorN) : T3DPline;
        class function Poly_2DProjection(Poly : T3DPline; Plan : Word2L) : TPline;
        class function PtInCommon(Poly_1, Poly_2 : T3DPline; var N1, N2 : integer) : boolean;
        class procedure Reference_3DPline(XOrigin, YOrigin, ZOrigin : TFloatType; var Poly : T3DPline);
        class procedure Move_3DPline(X, Y, Z : TFloatType; var Poly : T3DPline);
        class procedure RemovePoint(N : integer; X, Y, Z : TVetorN; Npt : integer;
                                    var NResult : integer; var XResult, YResult, ZResult : TVetorN); overload;
        class procedure RemovePoint(Npt : integer; var N : integer; var X, Y, Z : TVetorN); overload;
        class procedure RemovePoint(Npt : integer; var P : T3DPline); overload;
        class procedure RemovePoint(N : integer; P : TVetor3DPoint; Npt : integer;
                                    var NResult : integer; var PResult : TVetor3DPoint); overload;
        class procedure RemoveRepeatedPts(N : integer; X, Y, Z : TVetorN; var NResult : integer;
                                          var XResult, YResult, ZResult : TVetorN); overload;
        class procedure RemoveRepeatedPts(N : integer; P : TVetor3DPoint; var NResult : integer;
                                          var PResult : TVetor3DPoint); overload;
        class function RemoveRepeatedPts(N : integer; P : TVetor3DPoint) : TVetor3DPoint; overload;
        class function Renumber(Poly : T3DPline; N1 : integer) : T3DPline;
        class function Reset(Poly : T3DPline) : T3DPline;
        class function Reverse(Poly : T3DPline) : T3DPline;
        class procedure Scan_Max(NPoly : integer; X, Y, Z : TVetorN; DirectionScan : char; Scan : TFloatType;
                                 AxisMaxRef : byte; var NResult : boolean; var S1, S2 : TFloatType);
        class procedure Scan_Min(NPoly : integer; X, Y, Z : TVetorN; DirectionScan : char; Scan : TFloatType;
                                 AxisMinRef : byte; var NResult : boolean; var S1, S2 : TFloatType);
        class function SetofPointsToPoly(NPts : integer; Xi, Yi, Zi, Xf, Yf, Zf : TFloatType;
                                         X, Y, Z : TVetorN; Closed : boolean) : T3DPline; overload;
        class function SetofPointsToPoly(Xi,Yi,Zi,Xf,Yf,Zf : TFloatType; Pts : TSetofPoints3D;
                                         Closed : boolean) : T3DPline; overload;
        class procedure Split(Poly : T3DPline; N1, N2 : integer; var Poly1, Poly2 : T3DPline);
        class function Trim_Plan(Poly : T3DPline; X1,Y1,Z1,XN,YN,ZN : TFloatType) : TWire;
        class function Trim_PlanTriangle(Poly : T3DPline; X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3 : TFloatType) : TWire;
        class procedure Uniform_Poly3D(NpontosE : integer; NpontosS : integer; Xpol : TVetorN; Ypol : TVetorN; Zpol : TVetorN;
                                       var NpontosF : integer; var XpolF : TVetorN; var YpolF : TVetorN; var ZpolF : TVetorN);
        class procedure Uniform_SetofPoly3D_Max(N : integer; Npoly : TVetorIN; X, Y , Z : TMatrizNxN;
                                                Sym : boolean; X1,Y1,Z1,XN,YN,ZN : TFloatType;
                                                var NpolyResult : TVetorIN; var XResult, YResult, ZResult : TMatrizNxN);
        class function VectorToPoly(N : integer; X, Y, Z : TVetorN; Closed : boolean) : T3DPline;
        class function Volume(Poly : T3DPline) : TFloatType;
        class function Weld(Poly_1 : T3DPline; Poly_2 : T3DPline) : T3DPline;
        class procedure WireToPoints(Wire : TWire; var N : integer; var Npoly : TVetorIN; var X, Y, Z : TMatrizNxN);
      end;

type TSetofPoints = class
     public
       class function Reset(Pts : TSetofPoints3D) : TSetofPoints3D;
       class function AddPoint(Pts : TSetofPoints3D; X, Y, Z : TFloatType; N : integer) : TSetofPoints3D;
       class function Join(Pts1, Pts2 : TSetofPoints3D) : TSetofPoints3D;
       class procedure MinXPoint(Pt : TSetofPoints3D; var X, Y, Z : TFloatType);
       class procedure MaxXPoint(Pt : TSetofPoints3D; var X, Y, Z : TFloatType);
       class procedure MinYPoint(Pt : TSetofPoints3D; var X, Y, Z : TFloatType);
       class procedure MaxYPoint(Pt : TSetofPoints3D; var X, Y, Z : TFloatType);
       class procedure MinZPoint(Pt : TSetofPoints3D; var X, Y, Z : TFloatType);
       class procedure MaxZPoint(Pt : TSetofPoints3D; var X, Y, Z : TFloatType);
     end;

type TSetofPoly = class
     public
       class function AddPoly(PolySet : TWire; Poly : T3DPline; N : integer) : TWire; overload;
       class procedure AddPoly(Poly : T3DPline; Index : integer; var P : TWire); overload;
       class function Delete(N : integer; PolySet : TWire) : TWire;
       class function DeleteListofPoly(N : integer; ID : TVetorIN; PolySet : TWire) : TWire;
       class function InsideXBoundary(PolySet : TWire; X1, X2 : TFloatType; var N : integer) : TVetorIN;
       class function InXCoordinate(PolySet : TWire; X : TFloatType; var N : integer) : TVetorIN;
       class function Join(PolySet1,PolySet2 : TWire) : TWire;
       class function PolyWithPtInCommon(Poly : T3DPline; PolySet : TWire; var N : integer) : TVetorIN;
       class function Reset(PolySet : TWire) : TWire;
       class function Slice_Plan(PolySet : TWire; X1,Y1,Z1,XN,YN,ZN : TFloatType) : TWire;
       class function Subset(N : integer; ID : TVetorIN; PolySet : TWire) : TWire;
       class function Trim_Plan(PolySet : TWire; X1,Y1,Z1,XN,YN,ZN : TFloatType) : TWire;
       class function Setof3DPlineToWire(N : integer; PolySet : array of T3DPline) : TWire;
     end;

type TSurf = class
     public
       class function AddFace(F : TTriangle; Faces : TMesh; N : integer) : TMesh;
       class function AddNewFace(F : TTriangle; Faces : TMesh; N : integer) : TMesh;
       class function AddMesh(F : TMesh; Faces : TMesh; N : integer) : TMesh;
       class function FlipDirection(Poly1, Poly2 : T3DPline) : T3DPline;
       class procedure InitializeMeshes(NMeshes : integer; NFaces : array of integer; var M : TMeshes);
       class function MeshesToVetorIN(M : TMeshes) : TVetorIN;
       class function PyramidFaceSurf(X,Y,Z : TFloatType; P : T3DPline) : TMesh;
       class function Pol_Pol_Surf(Poly_1 : T3DPline; Poly_2 : T3DPline) : TMesh;
       class procedure RemoveFace(Index : integer; var X : TMesh);
       class function SingleRowPolySurf(Poly_1 : T3DPline; Poly_2 : T3DPline) : TMesh;
       class function TrimMesh(F : TMesh; Plan : TPlan) : TMesh;
       class function TrimTwiceMesh(F : TMesh; Plan1, Plan2 : TPlan) : TMesh; 
     end;

type TSurface = class(TObject)
     public
       FFaces    : TMesh;
       FM        : TMaterial;
       FPenColor : TColor;
       FPenWidth : integer;
       FEdges    : boolean;
     private

     end;

type TCGraphic = class
     public
       class procedure AddLightPoint(NL : integer; PLs : TLights; N : integer; P : TLight;
                                     var NR : integer; var PR : TLights);
       class procedure RemoveLightPoint(NL : integer; PLs : TLights; N : integer;
                                        var NR : integer; var PR : TLights);
       class procedure AddLightPointSettings(PLs : TLightsSettings; N : integer; P : TLightSettings;
                                             var PR : TLightsSettings);
       class procedure ApplyRotation(X, Y, Z  : TFloatType; A : T3DPoint; T : TMatriz3x3; var XR, YR, ZR : TFloatType); overload;
       class procedure ApplyRotation(P, A : T3DPoint; T : TMatriz3x3; var PR : T3DPoint); overload;
       class procedure ApplyViewPointBasis(X, Y, Z : TFloatType; C : TCamera; var XR, YR, ZR : TFloatType); overload;
       class function ApplyViewPointBasis(Point : T3DPoint; C : TCamera) : T3DPoint; overload;
       class procedure ClearBitmap(Bmp : TBitmap; PenColor : TColor);
       class function Clipping_Polygon(PolC, Poly : T3DPline) : TWire;  { not finished }
       class function CoveredLineX(L1, L2 : T2DLine) : boolean;
       class function CoveredLineY(L1, L2 : T2DLine) : boolean;
       class procedure CrossDisplay(Bmp : TBitmap; X, Y : TFloatType; R : integer; SizeRatio : TFloatType;
                                    XPan, YPan : integer);
       class function CursorOnRectangleVertice(X, Y : integer; R : TRect; T : integer;
                                               DefaultCursor : TCursor) : TCursor; overload;
       class function CursorOnRectangleVertice(X, Y : integer; R : TRect; T : integer;
                                               DefaultCursor : TCursor; var Vertice : byte) : TCursor; overload;
       class function CursorOnPlineINVertice(Poly : TPlineIN; X, Y : integer; T : integer;
                                             DefaultCursor : TCursor; var Vertice : integer) : TCursor; overload;
       class function CursorOnPlineINVertice(Poly : TPlineIN; X, Y : integer; T : integer;
                                             DefaultCursor : TCursor) : TCursor; overload;
       class procedure Draw_Aim(P : T3DPoint; C : TCamera; Bmp : TBitmap; RatioRadiusWidth : TFloatType;
                                PenColor : TColor; PenWidth : integer; SizeRatio : TFloatType;  XPan, YPan : integer);
       class procedure Draw_CustomRectangle(Bmp : TBitmap; R : TRect; PenColor : TColor;
                                            PenWidth : integer; PenStyle : TPenStyle);
       class procedure Draw_Line3D(X1,Y1,Z1,X2,Y2,Z2 : TFloatType; Bmp : TBitmap; PenColor : TColor;
                                   PenWidth : integer; SizeRatio : TFloatType;
                                   C : TCamera; XPan, YPan : integer);
       class procedure Draw_Poly2D_Points(Poly : TPline; Bmp : TBitmap; N1, N2 : integer;
                                          PenBorderColor, PenBrushColor : TColor; PenWidth : integer;
                                          T : integer; SizeRatio : TFloatType; XPan, YPan : integer); overload;
       class procedure Draw_Poly2D_Points(Poly : TPlineIN; Bmp : TBitmap; N1, N2 : integer;
                                          PenBorderColor, PenBrushColor : TColor; PenWidth : integer;
                                          T : integer; XPan, YPan : integer); overload;
       class procedure Draw_Poly2D(Poly : TPlineIN; Bmp : TBitmap; N1, N2 : integer;
                                   PenColor : TColor; PenWidth : integer; PenStyle : TPenStyle;
                                   XPan, YPan : integer); overload;
       class procedure Draw_Poly2D(Poly : TPline; Bmp : TBitmap; N1, N2 : integer;  PenColor : TColor;
                                   PenWidth : integer; PenStyle : TPenStyle; SizeRatio : TFloatType;
                                   XPan, YPan : integer); overload;
       class function Draw_CustomPoly2D(Poly : TPline; Bmp : TBitmap; SpLnSettings : TSplineSettings;
                                        PLnSettings : TPlineSettings; SizeRatio : TFloatType;
                                        Xpan, YPan : integer) : TPline; overload;
       class procedure Draw_CustomPoly2D(Poly : TPline; Bmp : TBitmap; PLnSettings : TPlineSettings;
                                         SizeRatio : TFloatType; Xpan, YPan : integer); overload;
       class function Draw_CustomPoly2D(Poly : TPlineIN; Bmp : TBitmap; SpLnSettings : TSplineSettings;
                                        PLnSettings : TPlineSettings; Xpan, YPan : integer) : TPlineIN; overload;
       class procedure Draw_CustomPoly2D(Poly : TPlineIN; Bmp : TBitmap; PLnSettings : TPlineSettings;
                                         Xpan, YPan : integer); overload;


       class procedure Draw_Poly3D(Poly : T3DPline; N1, N2 : integer; Bmp : TBitmap;
                                   PenColor : TColor; PenWidth : integer; SizeRatio : TFloatType;
                                   C : TCamera; XPan, YPan : integer);
       class procedure Draw_Polygons(Faces : TMesh; Bmp : TBitmap; PenColor : TColor;
                                     PenWidth : integer; SizeRatio : TFloatType;
                                     AmbientLight : TAmbientLight; NoLights : integer;
                                     PtsLight : TLights; M : TMaterial;
                                     C : TCamera; Edges : boolean; XPan, YPan : integer);

       class procedure Draw_Polygons_XBuffer(Faces : TMesh; Bmp : TBitmap; PenColor : TColor;
                                             AmbientLight : TAmbientLight; NoLights : integer;
                                             PtsLight : TLights; M : TMaterial; C : TCamera;
                                             Edges : boolean; SizeRatio : TFloatType; XPan, YPan : integer;
                                             var Buffer : TMatrizNxN);
       class procedure Draw_Polygons_XBuffer_Opt(Faces : TMesh; Bmp : TBitmap; PenColor : TColor;
                                                 AmbientLight : TAmbientLight; NoLights : integer;
                                                 PtsLight : TLights; M : TMaterial; C : TCamera;
                                                 Edges : boolean; SizeRatio : TFloatType; XPan, YPan : integer;
                                                 var Buffer : TMatrizNxN);
       class procedure Draw_Polygons_XBuffer_Opt2(Faces : TMesh; Bmp : TBitmap; PenColor : TColor;
                                                  AmbientLight : TAmbientLight; NoLights : integer;
                                                  PtsLight : TLights; M : TMaterial; C : TCamera;
                                                  Edges : boolean; SizeRatio : TFloatType; XPan, YPan : integer;
                                                  var Buffer : TMatrizNxN);
       class procedure DrawPolXBuffer_NormalVector(Face : TTriangle; BmpHeight : integer; XBuffer : TFloatType;
                                                   IndexX, IndexY : integer; XLens : TFloatType;
                                                   SizeRatio : TFloatType; XPan, YPan : integer;
                                                   var P : T3DPoint;
                                                   var XN, YN, ZN : TFloatType); overload;
       class procedure DrawPolXBuffer_NormalVector(Face : TTriangle; BmpHeight : integer; XBuffer : TFloatType;
                                                   IndexX, IndexY : integer; SizeRatio : TFloatType;
                                                   XPan, YPan : integer;
                                                   var P : T3DPoint;
                                                   var XN, YN, ZN : TFloatType); overload;
       class procedure DrawPolXBuffer_BMP(Faces : TMesh; Bmp : TBitmap; PenColor : TColor;
                                          Buffer : TMatrizNxN; ID : TMatrizINxN; EdgeID : TMatrizBNxN;
                                          AmbientLight : TAmbientLight; NoLights : integer;
                                          PtsL : TLights; M : TMaterial; XLens : TFloatType;
                                          SizeRatio : TFloatType; XPan, YPan : integer); overload;
       class procedure DrawPolXBuffer_BMP(Faces : TMesh; Bmp : TBitmap; Buffer : TMatrizNxN; ID : TMatrizINxN;
                                          AmbientLight : TAmbientLight; NoLights : integer;
                                          PtsL : TLights; M : TMaterial; XLens : TFloatType;
                                          SizeRatio : TFloatType; XPan, YPan : integer); overload;
      class procedure DrawPolXBuffer_BMP(Faces : TMesh; Bmp : TBitmap; PenColor : TColor;
                                         Buffer : TMatrizNxN; ID : TMatrizINxN; EdgeID : TMatrizBNxN;
                                         AmbientLight : TAmbientLight; NoLights : integer;
                                         PtsL : TLights; M : TMaterial; SizeRatio : TFloatType;
                                         XPan, YPan : integer); overload;
       class procedure DrawPolXBuffer_BMP(Faces : TMesh; Bmp : TBitmap;
                                          Buffer : TMatrizNxN; ID : TMatrizINxN;
                                          AmbientLight : TAmbientLight; NoLights : integer;
                                          PtsL : TLights; M : TMaterial;
                                          SizeRatio : TFloatType; XPan, YPan : integer); overload;

       class procedure EllipseDisplay(Bmp : TBitmap; X, Y : TFloatType; R : integer; SizeRatio : TFloatType;
                                      XPan, YPan : integer);
       class procedure IMBase2DOrto(xo : TFloatType; yo : TFloatType; x1 : TFloatType; y1 : TFloatType; x2 : TFloatType; y2 : TFloatType;
                                    var x3 : TFloatType; var y3 : TFloatType);
       class function InitializeBmpXBuffer(Bmp : TBitmap; MinXBuffer : TFloatType) : TMatrizNxN; overload;
       class procedure InitializeBmpXBuffer(BmpHeight, BmpWidth : integer; MinXBuffer : TFloatType; var Buffer : TMatrizNxN); overload;
       class procedure Mark_2DPoint(X, Y : TFloatType; Bmp : TBitmap; PenBorderColor, PenBrushColor : TColor;
                                    PenWidth : integer; T : integer; SizeRatio : TFloatType; XPan, YPan : integer); overload;
       class procedure Mark_2DPoint(X, Y : integer; Bmp : TBitmap; PenBorderColor, PenBrushColor : TColor;
                                    PenWidth : integer; T : integer; XPan, YPan : integer); overload;
       class procedure Mark_3DPoint(X,Y,Z : TFloatType; Bmp : TBitmap; PenColor : TColor; PenWidth : integer; Dcirc : integer;
                                    SizeRatio : TFloatType; C : TCamera; XPan, YPan : integer); overload;
       class procedure Mark_3DPoint(P : T3DPoint; Bmp : TBitmap; PenColor : TColor; PenWidth : integer; Dcirc : integer;
                                    SizeRatio : TFloatType; C : TCamera; XPan, YPan : integer); overload;
       class procedure MBase2DOrto(xo : TFloatType; yo : TFloatType; x1 : TFloatType; y1 : TFloatType; x2 : TFloatType; y2 : TFloatType;
                                   var x3 : TFloatType; var y3 : TFloatType);
       class procedure MoveCameraPos(V, A : T3DPoint;
                                     var XCo, ZCo : TVetor3x1;
                                     var Vo, Ao : T3DPoint;
                                     var RefY, RefZ : T3DPoint;
                                     var TCBase : TMatriz3x3);
       class procedure MoveCameraNav(V, A : T3DPoint;
                                     var XCo, ZCo : TVetor3x1;
                                     var Vo, Ao : T3DPoint;
                                     var RefY, RefZ : T3DPoint;
                                     var TCBase : TMatriz3x3);
       class function PaintersAlgorithm(Faces : TMesh; C : TCamera) : TMesh; overload;
       class function PaintersAlgorithm(Faces : TMesh) : TMesh; overload;
       class procedure PerspectiveProjection(P : TVetor3x1; O : TVetor3x1; xV : TFloatType;
                                             var PR : TVetor3x1); overload;
       class function PerspectiveProjection(P : T3DPoint; O : T3DPoint; xV : TFloatType) : T3DPoint; overload;
       class procedure PerspectiveProjection(X, Y, Z : TFloatType; CXObs, CYObs, CZObs : TFloatType; xV : TFloatType;
                                             var XR, YR, ZR : TFloatType); overload;
       class procedure PhongShade(AmbientLight : TAmbientLight; N : integer; PLights : TLights;
                                  M : TMaterial; X, Y, Z, XN, YN, ZN : TFloatType;
                                  var R, G, B : TFloatType);
       class function PhongDiffuseSpecularLight(P : TLight; M : TMaterial;
                                                X, Y, Z, XN, YN, ZN : TFloatType) : TRGBFloat;
       class procedure PhongShadeR(AmbientLight : TAmbientLight; N : integer; PLights : TLights;
                                   M : TMaterial; X, Y, Z, XN, YN, ZN : TFloatType;
                                   var R, G, B : TFloatType);
       class function PhongDiffuseSpecularLightR(P : TLight; M : TMaterial;
                                                 X, Y, Z, XN, YN, ZN : TFloatType) : TRGBFloat;
       class function PixelInsideLine(X, Y : integer; X1,Y1,X2,Y2 : TFloatType) : boolean;
       class function PixelOnRectangleVertice(X, Y : integer; R : TRect; T : integer) : boolean;
       class function PixelOnTriangleEdge(X, Y : integer; T : TTriangle) : boolean;
       class procedure RasterizeSubTriangle_Isom(T : TTriangle; Index : Int03; TriangleIndex : integer;
                                                 C : TCamera; BmpWidth, BmpHeight : integer; SizeRatio : TFloatType;
                                                 XPan, YPan : integer;
                                                 var Buffer : TMatrizNxN; var TID : TMatrizINxN); overload;
       class procedure RasterizeSubTriangle_Isom(T : TTriangle; Index : Int03; TriangleIndex : integer;
                                                 C : TCamera; BmpWidth, BmpHeight : integer; SizeRatio : TFloatType;
                                                 XPan, YPan : integer;
                                                 var Buffer : TMatrizNxN; var TID : TMatrizINxN;
                                                 var EdgeID : TMatrizBNxN); overload;
       class procedure RasterizeSubTriangle_Persp(T : TTriangle; Index : Int03; TriangleIndex : integer;
                                                  C : TCamera; BmpWidth, BmpHeight : integer; SizeRatio : TFloatType;
                                                  XPan, YPan : integer;
                                                  var Buffer : TMatrizNxN; var TID : TMatrizINxN); overload;
       class procedure RasterizeSubTriangle_Persp(T : TTriangle; Index : Int03; TriangleIndex : integer;
                                                  C : TCamera; BmpWidth, BmpHeight : integer; SizeRatio : TFloatType;
                                                  XPan, YPan : integer;
                                                  var Buffer : TMatrizNxN; var TID : TMatrizINxN;
                                                  var EdgeID : TMatrizBNxN); overload;
       class procedure RasterizeTriangleIsom(T : TTriangle; TriangleIndex : integer;
                                             C : TCamera; BmpWidth, BmpHeight : integer;
                                             SizeRatio : TFloatType; XPan, YPan : integer;
                                             var Buffer : TMatrizNxN;
                                             var TID : TMatrizINxN); overload;
       class procedure RasterizeTriangleIsom(T : TTriangle; TriangleIndex : integer;
                                             C : TCamera; BmpWidth, BmpHeight : integer;
                                             SizeRatio : TFloatType; XPan, YPan : integer;
                                             var Buffer : TMatrizNxN;
                                             var TID : TMatrizINxN;
                                             var EdgeID : TMatrizBNxN); overload;
       class procedure RasterizeTrianglePersp(T : TTriangle; TriangleIndex : integer;
                                             C : TCamera; BmpWidth, BmpHeight : integer;
                                             SizeRatio : TFloatType; XPan, YPan : integer;
                                             var Buffer : TMatrizNxN;
                                             var TID : TMatrizINxN); overload;
       class procedure RasterizeTrianglePersp(T : TTriangle; TriangleIndex : integer;
                                             C : TCamera; BmpWidth, BmpHeight : integer;
                                             SizeRatio : TFloatType; XPan, YPan : integer;
                                             var Buffer : TMatrizNxN;
                                             var TID : TMatrizINxN;
                                             var EdgeID : TMatrizBNxN); overload;
       class function RectangleVertice(Index : byte; R : TRect) : TPoint;
       class procedure RectangleEditVertice(Index : byte; X, Y : integer; var R : TRect);
       class procedure ReflectedVector(X, Y, Z, XN, YN, ZN : TFloatType; var XR, YR, ZR : TFloatType);
       class procedure RemoveLightPointSettings(PLs : TLightsSettings; N : integer; var PR : TLightsSettings);
       class procedure ReversePerspectiveProjection(P : TVetor3x1; O : TVetor3x1; xV : TFloatType; var PR : TVetor3x1); overload;
       class function ReversePerspectiveProjection(P : T3DPoint; O : T3DPoint; xV : TFloatType) : T3DPoint; overload;
       class procedure ReversePerspectiveProjection(X, Y, Z : TFloatType; CXObs, CYObs, CZObs : TFloatType;
                                                    xV : TFloatType; var XR, YR, ZR : TFloatType); overload;
       class function ReverseScalePanFloat(P : T3DPoint; Height, SizeRatio, XPan, YPan : TFloatType) : T3DPoint; overload;
       class procedure ReverseScalePanFloat(X, Y : TFloatType; Height, SizeRatio,
                                            XPan, YPan : TFloatType; var XR, YR: TFloatType); overload;
       class function ReverseScalePanPoly(Poly : TPlineIN; SizeRatio : TFloatType;
                                          Height, XPan, YPan : integer) : TPline;
       class function RevertViewPointBasis(Point : T3DPoint; C : TCamera) : T3DPoint;
       class function RotationAngleDisplay(X, Y, Xo, Yo : integer; Amplitude : TFloatType;
                                           Height, Width : integer) : TFloatType;
       class procedure RotationXAxis(R : TFloatType; var T : TMatriz3x3);
       class procedure RotationYAxis(R : TFloatType; var T : TMatriz3x3);
       class procedure RotationZAxis(R : TFloatType; var T : TMatriz3x3);
       class procedure Rotation3DAxis(R : TFloatType; AX, AY, AZ : TFloatType; var T : TMatriz3x3); overload;
       class procedure Rotation3DAxis(R : TFloatType; AX, AY, AZ : TFloatType; var TAcm, T : TMatriz3x3); overload;
       class procedure Scale(x1 : TFloatType; y1 : TFloatType; z1 : TFloatType; Ratio : TFloatType;
                             var x2 : TFloatType; var y2 : TFloatType; var z2 : TFloatType); overload;
       class function Scale(P : T3DPoint; Ratio : TFloatType) : T3DPoint; overload;
       class function ScalePanFloat(P : T3DPoint; Height, SizeRatio, XPan, YPan : TFloatType) : T3DPoint; overload;
       class procedure ScalePanFloat(X, Y : TFloatType; Height, SizeRatio,
                                     XPan, YPan : TFloatType; var XR, YR: TFloatType); overload;
       class procedure ScalePanInt(X, Y : TFloatType; SizeRatio : TFloatType;
                                   Height, XPan, YPan : integer; var XR, YR: integer);
       class function ScreenScale(Measure : TFloatType; Ratio : TFloatType; DotsPI : Integer) : TFloatType;
       class procedure ScanLineSubTriangleEnds(T : TTriangle; Index : Int03; Z : integer;
                                               var L : TLine);
       class function ScanLineSubTriangle_Isom(T : TTriangle; Index : Int03; Z : integer;
                                               C : TCamera; Width,Height : integer;
                                               SizeRatio : TFloatType; XPan, YPan : integer) : TScreenLine;
       class function ScanLineSubTriangle_Persp(T : TTriangle; Index : Int03; Z : integer;
                                                C : TCamera; Width,Height : integer;
                                                SizeRatio : TFloatType; XPan, YPan : integer) : TScreenLine;
       class function ScanLineTriangleIntersection(T : TTriangle; Z : TFloatType; var L : T2DLine) : boolean; overload;
       class function ScanLineTriangleIntersection(T : TTriangle; Z : integer; A1,A2,B1,B2 : Int03) : TLine; overload;
       class function ScanLineTriangleIntersectionR(T : TTriangle; Z : TFloatType; var L : T2DLine) : boolean;
       class function ScanLineTriangle(T : TTriangle; Z : TFloatType; C : TCamera; Width, Height : integer;
                                       SizeRatio : TFloatType; XPan, YPan : integer) : TScreenLine;
       class function ScanLineTriangle_Isom(T : TTriangle; Z : TFloatType; C : TCamera; Width,Height : integer;
                                            SizeRatio : TFloatType; XPan, YPan : integer) : TScreenLine;
       class function ScanLineTriangle_Persp(T : TTriangle; Z : TFloatType; C : TCamera; Width,Height : integer;
                                             SizeRatio : TFloatType; XPan, YPan : integer) : TScreenLine;
       class function ScanLineTriangleIsom(T : TTriangle; Z : integer; A1,A2,B1,B2 : Int03;
                                           C : TCamera; Width,Height : integer;
                                           SizeRatio : TFloatType; XPan, YPan : integer) : TScreenLine;
       class function ScanLineTrianglePersp(T : TTriangle; Z : integer; A1,A2,B1,B2 : Int03;
                                            C : TCamera; Width,Height : integer;
                                            SizeRatio : TFloatType; XPan, YPan : integer) : TScreenLine;
       class function ScanLineTriangleR(T : TTriangle; Z : TFloatType; C : TCamera; Width,Height : integer;
                                        SizeRatio : TFloatType; XPan, YPan : integer) : TScreenLine;
       class procedure ScanLineXBufferUpdate(TriangleIndex : integer;
                                             Z : integer; PixelLine : TScreenLine;
                                             C : TCamera;
                                             var Buffer : TMatrizNxN; var TID : TMatrizINxN); overload;
       class procedure ScanLineXBufferUpdate(T : TTriangle; TriangleIndex : integer;
                                             Z : integer; PixelLine : TScreenLine;
                                             C : TCamera;
                                             var Buffer : TMatrizNxN; var TID : TMatrizINxN;
                                             var EdgeID : TMatrizBNxN); overload;
       class function SetRatio_Display(Hmax,Vmax,HDisplay,VDisplay : TFloatType) : TFloatType;
       class function Sight3DPoint(P : T3DPoint; Bmp : TBitmap; SizeRatio : TFloatType;
                                   C : TCamera; XPan, YPan : integer) : T3DPoint;
       class function TriangleInBounds(T : TTriangle; CameraXlens : TFloatType;
                                       BmpWidth, BmpHeight : integer;
                                       var Zmin, Zmax : integer) : boolean;
       class procedure TriangleDominantEdge(T : TTriangle; var N1, N2 : integer);
       class procedure TriangleDominantEdgeYZ(T : TTriangle; var N1, N2 : integer);
       class procedure ViewLine(X1 : TFloatType; Y1 : TFloatType; Z1 : TFloatType;
                                X2 : TFloatType; Y2 : TFloatType; Z2 : TFloatType;
                                xV : TFloatType; Persp: boolean; var Visible : boolean;
                                var X1F : TFloatType;  var Y1F : TFloatType;  var Z1F : TFloatType;
                                var X2F : TFloatType;  var Y2F : TFloatType;  var Z2F : TFloatType);
       class function ViewPointBasis(Point : T3DPoint; C : TCamera) : T3DPoint;
       class procedure XBuffer_Mesh(Faces : TMesh; BmpWidth, BmpHeight : integer; C : TCamera;
                                    SizeRatio : TFloatType; XPan, YPan : integer;
                                    var Buffer : TMatrizNxN;
                                    var TID : TMatrizINxN); overload;
       class procedure XBuffer_Mesh(Faces : TMesh; BmpWidth, BmpHeight : integer; C : TCamera;
                                    SizeRatio : TFloatType; XPan, YPan : integer;
                                    var Buffer : TMatrizNxN;
                                    var TID : TMatrizINxN;
                                    var EdgeID : TMatrizBNxN); overload;
       class function ZoomAll(Camera : TCamera; DisplayHeight, DisplayWidth : integer;
                              B : TBox) : TFloatType;
       class procedure TextDisplay(Bmp : TBitmap; X, Y : integer; TextFont, Color : integer;
                                   TextStyle : TFontStyles; Text : WideString);
     end;


const
  epsilon = 1e-10;
  MaxPrecision = -7;
  RelPrecision = 1e-7;      // Relative Precision for floating point arithmetic operations and comparisons
  InfDistance = 149597870700;        // Distance in meters from Earth to the Sun
  MIdentidade : TMatriz3x3 = ((1,0,0),(0,1,0),(0,0,1));    { Identity Matrix }
  TriangleEdgeIndexes : array[1..3,1..2]of Int03 = ((2,3),(1,3),(1,2));  // Limits (1..2) of opposite edges to triangle vertices (1..3)
  TrianglePointIndex : array[1..3,1..3]of Int03 = ((0,3,2),(3,0,1),(2,1,0)); // Opposite vertex of the edge defined by limits (1..3,1..3)
  TriangleNextVertex : array[1..3]of Int03 = (2,3,1);  // Following index of a vertex in a triangle
  TriangleNext2Vertex : array[1..3]of Int03 = (3,1,2); // Post following index of a vertex in a triangle
  NullPoint : T3DPoint = (X : 0; Y : 0; Z : 0);
  XPoint : T3DPoint = (X : 1; Y : 0; Z : 0);
  YPoint : T3DPoint = (X : 0; Y : 1; Z : 0);
  ZPoint : T3DPoint = (X : 0; Y : 0; Z : 1);
  PlanXY : TPlan = (X1 : 0; Y1 : 0; Z1 : 0; XN : 0; YN : 0; ZN : 1);
  PlanXZ : TPlan = (X1 : 0; Y1 : 0; Z1 : 0; XN : 0; YN : 1; ZN : 0);
  PlanYZ : TPlan = (X1 : 0; Y1 : 0; Z1 : 0; XN : 1; YN : 0; ZN : 0);
  var
  Cotas : text;
  MatrizA, MatrizA_Inversa, MatrizB : TMatrizNxN;
  NMdim, NMdimB : integer;
  MOLIdentidade : TMatrizNxN;   // Identity Matrix for Linear Operations
  EMsg : string;
  TID : TMatrizINxN;
  EdgeID : TMatrizBNxN;

implementation

function RGBFloat(R, G, B : TFloatType) : TRGBFloat;
begin
  Result.R := R; Result.G := G; Result.B := B;
end;  { RGBFloat }

procedure ColorToRGBBytes(Color : TColor; var R, G, B : Byte);
begin
  Color  := ColorToRGB(Color);
  R := GetRValue(Color);
  G := GetGValue(Color);
  B := GetBValue(Color);
end;  { ColorToRGBBytes }

function ColorToRGBFloat(Color : TColor) : TRGBFloat;
begin
  Color  := ColorToRGB(Color);
  Result.R := GetRValue(Color);
  Result.G := GetGValue(Color);
  Result.B := GetBValue(Color);
end;  { ColorToRGBFloat }

function ColorToRGBFloatNorm(Color : TColor) : TRGBFloat;
begin
  Color  := ColorToRGB(Color);
  Result.R := GetRValue(Color)/255;
  Result.G := GetGValue(Color)/255;
  Result.B := GetBValue(Color)/255;
end;  { ColorToRGBFloatNorm }

function MaterialFloat(kaR,kaG,kaB,kdR,kdG,kdB,ksR,ksG,ksB,MNs : TFloatType) : TMaterial;
begin
  with Result do
  begin
    ka := RGBFloat(kaR,kaG,kaB);  kd := RGBFloat(kdR,kdG,kdB);
    ks := RGBFloat(ksR,ksG,ksB);  Ns := MNs;
  end;
end;  { MaterialFloat }

function MaterialFloat(Mka, Mkd, Mks : TRGBFloat; MNs : TFloatType) : TMaterial;
begin
  with Result do
  begin
    ka := Mka;  kd := Mkd;  ks := Mks;  Ns := MNs;
  end;
end;  { MaterialFloat }

procedure MaterialColor(Color : TColor; var M : TMaterial);
begin   { ATENÇÃO! Dúvida Ks é brilho especular, então reflete a cor da luz }
  M.ka := ColorToRGBFloatNorm(Color);
  M.kd := ColorToRGBFloatNorm(Color);           
  //M.ks := ColorToRGBFloatNorm(Color);
end;  { MaterialColor }

procedure SetLength3DPline(var P : T3DPline; N : integer);
begin
  If N > 0 then
  begin
    SetLength(P.X,N); SetLength(P.Y,N); SetLength(P.Z,N);
  end;
end;  { SetLength3DPline }

function SetMatrixDim(Matrix : TMatrizNxN; Ndim : integer) : TMatrizNxN;
var
  i : integer;
begin
  SetLength(Matrix,Ndim);
  for i := Low(Matrix) to High(Matrix) do
    SetLength(Matrix[i],Ndim);
  Result := Matrix;
end;  { SetMatrixDim }

function SetMatrixDimN2(Matrix : TMatrizNxN; Ndim1,Ndim2 : integer) : TMatrizNxN;
var
  i : integer;
begin
  SetLength(Matrix,Ndim1);
  for i := 0 to Ndim1-1 do
    SetLength(Matrix[i],Ndim2);
  Result := Matrix;
end;  { SetMatrixDimN2 }

function SetMatrixDimN3(Matrix : TMatrizN3; Ndim1,Ndim2,Ndim3 : integer) : TMatrizN3;
var
  i, j : integer;
begin
  SetLength(Matrix,Ndim3);
  for j := 0 to Ndim3-1 do
  begin
    SetLength(Matrix[j],Ndim1);
    for i := 0 to Ndim1-1 do
      SetLength(Matrix[i,j],Ndim2);
  end;
  Result := Matrix;
end;  { SetMatrixDimN3 }

function SetMatrixDimN4(Matrix : TMatrizN4; Ndim1,Ndim2,Ndim3,Ndim4  : integer) : TMatrizN4;
var
  i, j, k : integer;
begin
  SetLength(Matrix,Ndim4);
  for k := 0 to Ndim4-1 do
  begin
    SetLength(Matrix[k],Ndim3);
    for j := 0 to Ndim3-1 do
    begin
      SetLength(Matrix[j,k],Ndim1);
      for i := 0 to Ndim1-1 do
        SetLength(Matrix[i,j,k],Ndim2);
    end;
  end;
  Result := Matrix;
end;  { SetMatrixDimN4 }

function SetMatrixDimIN2(Matrix : TMatrizINxN; Ndim1,Ndim2 : integer) : TMatrizINxN;
var
  i : integer;
begin
  SetLength(Matrix,Ndim1);
  for i := 0 to Ndim1-1 do
    SetLength(Matrix[i],Ndim2);
  Result := Matrix;
end;  { SetMatrixDimIN2 }

function SetMatrixDimIN3(Matrix : TMatrizIN3; Ndim1,Ndim2,Ndim3 : integer) : TMatrizIN3;
var
  i, j : integer;
begin
  SetLength(Matrix,Ndim3);
  for j := 0 to Ndim3-1 do
  begin
    SetLength(Matrix[j],Ndim1);
    for i := 0 to Ndim1-1 do
      SetLength(Matrix[i,j],Ndim2);
  end;
  Result := Matrix;
end;  { SetMatrixDimIN3 }

function SetMatrixDimIN4(Matrix : TMatrizIN4; Ndim1,Ndim2,Ndim3,Ndim4  : integer) : TMatrizIN4;
var
  i, j, k : integer;
begin
  SetLength(Matrix,Ndim4);
  for k := 0 to Ndim4-1 do
  begin
    SetLength(Matrix[k],Ndim3);
    for j := 0 to Ndim3-1 do
    begin
      SetLength(Matrix[j,k],Ndim1);
      for i := 0 to Ndim1-1 do
        SetLength(Matrix[i,j,k],Ndim2);
    end;
  end;
  Result := Matrix;
end;  { SetMatrixDimIN4 }

function Matrix3x3ToNxN(Matrix : TMatriz3x3) : TMatrizNxN;
var
  i : integer;
begin
  SetLength(Result,4);
  for i := 1 to 3 do
  begin
    SetLength(Result[i],4);
    Result[i,1] := Matrix[i,1];
    Result[i,2] := Matrix[i,2];
    Result[i,3] := Matrix[i,3];
  end;
end;  { Matrix3x3ToNxN }

function MatrixNxNTo3x3(Matrix : TMatrizNxN) : TMatriz3x3;
var
  i : integer;
begin
  for i := 1 to 3 do
  begin
    Result[i,1] := Matrix[i,1];
    Result[i,2] := Matrix[i,2];
    Result[i,3] := Matrix[i,3];
  end;
end;  { Matrix3x3ToNxN }

function MatrixToStr(Matrix : TMatrizNxN; Ndim : integer;
                     Format : TFloatFormat; Precision, Digits : Integer) : string;
var                                  { Transforma Matriz N x N em string }
  i, j : integer;
begin
  Result := '';
  for i := 1 to Ndim do
  begin
    for j := 1 to Ndim-1 do
    begin
      Result := Result + FloatToStrF(Matrix[i,j],Format,Precision,Digits) + char(9);   { char(9) = TAB }
    end;
    Result := Result + FloatToStrF(Matrix[i,Ndim],Format,Precision,Digits) + #13 + #13;
  end;

end;  { MatrixToStr }

function PointToStr(X,Y,Z : TFloatType; SpaceChar : string; Format : TFloatFormat;
                    Precision, Digits : Integer) : string;
begin
  Result := FloatToStrF(X,Format,Precision,Digits)+SpaceChar+
            FloatToStrF(Y,Format,Precision,Digits)+SpaceChar+
            FloatToStrF(Z,Format,Precision,Digits);
end;  { PointToStr }

function PointToStr(X,Y : TFloatType; SpaceChar : string; Format : TFloatFormat;
                    Precision, Digits : Integer) : string;
begin
  Result := FloatToStrF(X,Format,Precision,Digits)+SpaceChar+
            FloatToStrF(Y,Format,Precision,Digits);
end;  { PointToStr }

function PointToStr(P : T3DPoint; SpaceChar : string; Format : TFloatFormat;
                    Precision, Digits : Integer) : string;
begin
  Result := FloatToStrF(P.X,Format,Precision,Digits)+SpaceChar+
            FloatToStrF(P.Y,Format,Precision,Digits)+SpaceChar+
            FloatToStrF(P.Z,Format,Precision,Digits);
end;  { PointToStr }

function PointToStr(P : TPoint; SpaceChar : string) : string;
begin
  Result := IntToStr(P.X)+SpaceChar+IntToStr(P.Y);
end;  { PonitToStr }

function PolyToStr(Poly : T3DPline; SpaceChar : string; Format : TFloatFormat;
                   Precision, Digits : Integer) : string;
var
  i : integer;
begin
  Result := '';
  for i := 1 to Poly.Npoly do
  begin
    Result := Result + IntToStr(i) + char(9) +
    PointToStr(Poly.X[i],Poly.Y[i],Poly.Z[i],SpaceChar,fffixed,Precision,Digits)+char(13);
  end;
end;  { PolyToStr }

function PolyToStr(Poly : TPline; SpaceChar : string; Format : TFloatFormat;
                   Precision, Digits : Integer) : string;
var
  i : integer;
begin
  Result := '';
  for i := 1 to Poly.Npoly do
  begin
    Result := Result + IntToStr(i) + char(9) +
    PointToStr(Poly.X[i],Poly.Y[i],SpaceChar,fffixed,Precision,Digits)+char(13);
  end;
end;  { PolyToStr }

function PolyToStr(N : integer; X, Y, Z : TVetorN; SpaceChar : string; Format : TFloatFormat;
                   Precision, Digits : Integer) : string;
var
  i : integer;
begin
  Result := '';
  for i := 1 to N do
  begin
    Result := Result + IntToStr(i) + char(9) +
    PointToStr(X[i],Y[i],Z[i],SpaceChar,fffixed,Precision,Digits)+char(13);
  end;
end;  { PolyToStr }

function PolyToStr(N : integer; X, Y : TVetorN; SpaceChar : string; Format : TFloatFormat;
                   Precision, Digits : Integer) : string;
var
  i : integer;
begin
  Result := '';
  for i := 1 to N do
  begin
    Result := Result + IntToStr(i) + char(9) +
    PointToStr(X[i],Y[i],SpaceChar,fffixed,Precision,Digits)+char(13);
  end;
end;  { PolyToStr }

function TriangleToStr(F : TTriangle; SpaceChar : string; Format : TFloatFormat;
                       Precision, Digits : Integer) : string;
begin
  Result := '('+PointToStr(F[1],SpaceChar,Format,Precision,Digits)+')'+EOL+
            '('+PointToStr(F[2],SpaceChar,Format,Precision,Digits)+')'+EOL+
            '('+PointToStr(F[3],SpaceChar,Format,Precision,Digits)+')';
end;  { TriangleToStr }

function TriangleToStr(F : TTriangle; SpaceChar,SpacePointChar : string; Format : TFloatFormat;
                       Precision, Digits : Integer) : string;
begin
  Result := '('+PointToStr(F[1],SpaceChar,Format,Precision,Digits)+')'+SpacePointChar+
            '('+PointToStr(F[2],SpaceChar,Format,Precision,Digits)+')'+SpacePointChar+
            '('+PointToStr(F[3],SpaceChar,Format,Precision,Digits)+')';
end;  { TriangleToStr }

function TriangleToStrId(F : TTriangle; SpaceChar,SpacePointChar : string; Format : TFloatFormat;
                         Precision, Digits : Integer) : string;
begin
  Result := '1'+SpaceChar+'('+PointToStr(F[1],SpaceChar,Format,Precision,Digits)+')'+SpacePointChar+
            '2'+SpaceChar+'('+PointToStr(F[2],SpaceChar,Format,Precision,Digits)+')'+SpacePointChar+
            '3'+SpaceChar+'('+PointToStr(F[3],SpaceChar,Format,Precision,Digits)+')';
end;  { TriangleToStr }

function RectToStr(R : TRect; SpaceChar : string) : string;
begin
  Result := 'Left '+IntToStr(R.Left)+SpaceChar+
            'Top '+IntToStr(R.Top)+SpaceChar+
            'Right '+IntToStr(R.Right)+SpaceChar+
            'Bottom '+IntToStr(R.Bottom)+SpaceChar+
            'TopLeft '+'('+PointToStr(R.TopLeft,', ')+')'+SpaceChar+
            'BottomRight '+'('+PointToStr(R.BottomRight,', ')+')';
end;  { RectToStr }

function RectNull(R : TRect) : boolean;
begin
  Result := False;
  If PointsEqual(R.TopLeft,R.BottomRight) then
    Result := True;
end;  { RectNull }

function VectorToStr(P : TVetorN; SpaceChar : string; Format : TFloatFormat;
                     Precision, Digits : Integer) : string;
var
  i : integer;
begin
  Result := '';
  for i := 1 to High(P) do
  begin
    Result := Result+IntToStr(i)+SpaceChar+FloatToStrF(P[i],Format,Precision,Digits)+char(13);
  end;
end;  { VectorToStr }

function VectorToStr(P : TVetorIN; SpaceChar : string) : string;
var
  i : integer;
begin
  Result := '';
  for i := 1 to High(P) do
  begin
    Result := Result+IntToStr(i)+SpaceChar+IntToStr(P[i])+char(13);
  end;
end;  { VectorToStr }

function RGBFloatToStr(P : TRGBFloat; SpaceChar : string; Format : TFloatFormat;
                       Precision, Digits : Integer) : string;
begin
  Result := FloatToStrF(P.R,Format,Precision,Digits)+SpaceChar+
            FloatToStrF(P.G,Format,Precision,Digits)+SpaceChar+
            FloatToStrF(P.B,Format,Precision,Digits);
end;  { RGBFloatToStr }

function RGB24ToStr(P : TRGB24; SpaceChar : string) : string;
begin
  Result := IntToStr(P.R)+SpaceChar+
            IntToStr(P.G)+SpaceChar+
            IntToStr(P.B);
end;  { RGB24ToStr }

function MatrizInversa(Matriz : TMatrizNxN; Ndim : integer) : TMatrizNxN;
var                          { Determina matriz inversa pelo Método de Gauss }
  i, j, k : integer;
  posmaxV : integer;
  MatrizOp : TMatrizNxN;      { Matriz para operações lineares }
  MatrizL : TMatrizNxN;       { Matriz left side: matriz do lado esquerdo do produto de matrizes }
  MatrizR : TMatrizNxN;       { Matriz right side: matriz do lado direito do produto de matrizes }
begin
   MatrizOp := SetMatrixDim(MatrizOp,Ndim+1);
   MatrizL := SetMatrixDim(MatrizL,Ndim+1);
   MatrizR := SetMatrixDim(MatrizR,Ndim+1);
   MOLIdentidade := SetMatrixDim(MOLIdentidade,Ndim+1);
   Result := SetMatrixDim(Result,Ndim+1);

   for i := 1 to Ndim do
     for j := 1 to Ndim do
     begin
       MOLIdentidade[i,j] := 0;
     end;
   for i := 1 to Ndim do
    MOLIdentidade[i,i] := 1;

   MatrizOp := Matriz;
   MatrizR := MOLIdentidade;

   for j := 1 to Ndim-1 do
   begin
     { Identifica a linha de j-ésimo valor de maior valor absoluto: posmaxV }
     posmaxV := j;
     for i := j to Ndim do
     begin
       if ABS(MatrizOp[i,j]) > ABS(MatrizOp[posmaxV,j]) then
         posmaxV := i;
     end;

     { Executa operação de troca de linhas para colocar a frente
        a linha de j-ésimo valor de maior valor absoluto, evitando
        que esse j-ésimo valor seja zero }
     MatrizL := MatrizOp;
     MatrizOp := MTrocaLinhas(MatrizL,Ndim,j,posmaxV);

     { Determina a matriz que multiplicada por MatrizOp
       executa a troca de linhas em MatrizOp }
     MatrizL := MatrizTrocaLinhas_F(Ndim,j,posmaxV);
     Result := ProdutoMatrizesN(MatrizL,MatrizR,Ndim);
     MatrizR := Result;

     { Atualiza a posição da linha de j-ésimo valor de maior valor
       absoluto após o término da execução de troca de linhas.     }
     posmaxV := j;

     { Executa combinação linear da j-ésima linha (posmaxV) com
       cada linha abaixo da mesma (j+1, .., Ndim) para zerar todos
       os j-ésimos valores dessas linhas }
     for k := j+1 to Ndim do
     begin
       { Registra matriz de transformação para execução da combinação linear }
       MatrizL := MatrizCLinear_F(Ndim,k,j,1,-MatrizOp[k,j]/MatrizOp[posmaxV,j]);
       Result := ProdutoMatrizesN(MatrizL,MatrizR,Ndim);
       MatrizR := Result;
       { Executa combinação linear na linha k de MatrizOp }
       MatrizL := MatrizOp;
       MatrizOp := MCLinear(MatrizL,Ndim,k,j,1,-MatrizOp[k,j]/MatrizOp[posmaxV,j]);
     end;
   end;

   for i := Ndim downto 2 do
   begin
     { Registra matriz de transformação para execução da Multiplicação da
       i-ésima linha por uma constante C =(1/L[i,i]) }

     MatrizL := MatrizCLinear_F(Ndim,i,i,1,(1/MatrizOp[i,i]));
     Result := ProdutoMatrizesN(MatrizL,MatrizR,Ndim);
     MatrizR := Result;
     { Multiplica i-ésima linha por uma constante }

     MatrizL := MatrizOp;
     MatrizOp := MCLinear(MatrizL,Ndim,i,i,1,(1/MatrizOp[i,i]));

     for j := i-1 downto 1 do
     begin
       { Zera valores de cada j-ésima linha na i-ésima coluna }
       MatrizL := MatrizCLinear_F(Ndim,j,i,1,-MatrizOp[j,i]);
       Result := ProdutoMatrizesN(MatrizL,MatrizR,Ndim);
       MatrizR := Result;
       { Multiplica i-ésima linha por uma constante }
       MatrizL := MatrizOp;
       MatrizOp := MCLinear(MatrizL,Ndim,j,i,1,-MatrizOp[j,i]);
     end;
   end;
   { Registra matriz de transformação para execução da Multiplicação da
       primeira linha por uma constante C =(1/L[1,1]) }

   MatrizL := MatrizCLinear_F(Ndim,1,1,1,(1/MatrizOp[1,1]));
   Result := ProdutoMatrizesN(MatrizL,MatrizR,Ndim);
   MatrizR := Result;
   { Multiplica primeira linha por uma constante }
   MatrizL := MatrizOp;
   MatrizOp := MCLinear(MatrizL,Ndim,1,1,1,(1/MatrizOp[1,1]));
   //ShowMessage(MatrixToStr(MatrizOp,Ndim,fffixed,7,3));

end;  { MatrizInversa }

function MatrizInversa3x3(Matriz : TMatriz3x3) : TMatriz3x3;
var
  i, j : byte;
  M : TMatrizNxN;
begin
  SetMatrixDim(M,4);
  for i := 1 to 3 do
    for j := 1 to 3 do
      M[i,j] := Matriz[i,j];
  M := MatrizInversa(M,3);
  for i := 1 to 3 do
    for j := 1 to 3 do
      Result[i,j] := M[i,j];
end;  { MatrizInversa3x3 }

function MInvertivel(Matriz : TMatrizNxN; Ndim : integer) : boolean;
var                             { ATENÇÃO : Resolver por Determinante }
  i, j, k : integer;
begin
  Result := True;
  j := 0;
  repeat
  begin
    j := j+1;
    k := 0;
    for i := 1 to Ndim do
    begin
      If Matriz[i,j] = 0 then
        k := k + 1;
    end;
  end;
  until((j = Ndim) or (k = Ndim));

  If k = Ndim then
    Result := False;

  i := 0;
  repeat
  begin
    i := i+1;
    k := 0;
    for j := 1 to Ndim do
    begin
      If Matriz[i,j] = 0 then
        k := k + 1;
    end;
  end;
  until((i = Ndim) or (k = Ndim));

  If k = Ndim then
    Result := False;

end;  { MInvertivel }

function MInvertivel3x3(Matriz : TMatriz3x3) : boolean;
var
  Det : TFloatType;
begin
  Result := True;
  Det := (Matriz[1,1]*Matriz[2,2]*Matriz[3,3])+(Matriz[1,2]*Matriz[2,3]*Matriz[3,1])+
         (Matriz[1,3]*Matriz[2,1]*Matriz[3,2])-(Matriz[1,1]*Matriz[2,3]*Matriz[3,2])-
         (Matriz[1,2]*Matriz[2,1]*Matriz[3,3])-(Matriz[1,3]*Matriz[2,2]*Matriz[3,1]);
  If Det <> 0 then
    Result := True
  Else If Det = 0 then
    Result := False;
end;  { MInvertivel3x3 }

function MatrizTransposta(Matriz : TMatrizNxN; Ndim : integer) : TMatrizNxN;
var                   { Calcula Matriz Transposta }
  i, j : integer;
begin
  SetLength(Result,Ndim+1);
  for i := 1 to Ndim do
  begin
    SetLength(Result[i],Ndim+1);
    for j := 1 to Ndim do
      Result[i,j] := Matriz[j,i];
  end;
end;  { MatrizTransposta }

function MatrizTransposta(Matriz : TMatriz3x3) : TMatriz3x3;
var                   { Calcula Matriz 3x3 Transposta }
  i, j : integer;
begin
  for i := 1 to 3 do
  begin
    for j := 1 to 3 do
      Result[i,j] := Matriz[j,i];
  end;
end;  { MatrizTransposta }

function MinValueIndex(X : TDouble) : integer;
var
  varaux : TFloatType;
begin
  varaux := MinValue(X);
  Result := -1;
  repeat
  begin
    Result := Result + 1;
  end;
  until(X[Result] = varaux);
end;  { MinValueIndex }

function MaxValueIndex(X : TDouble) : integer;
var
  varaux : TFloatType;
begin
  varaux := MaxValue(X);
  Result := -1;
  repeat
  begin
    Result := Result + 1;
  end;
  until(X[Result] = varaux);
end;  { MaxValueIndex }

function MinIndex(X : TDouble) : integer;
var
  varaux : TFloatType;
begin
  RemoveValue(0,X);
  varaux := MinValue(X);
  Result := -1;
  repeat
  begin
    Result := Result + 1;
  end;
  until(X[Result] = varaux);
  Result := Result + 1;
end;  { MinValueIndex }

function MaxIndex(X : TDouble) : integer;
var
  varaux : TFloatType;
begin
  RemoveValue(0,X);
  varaux := MaxValue(X);
  Result := -1;
  repeat
  begin
    Result := Result + 1;
  end;
  until(X[Result] = varaux);
  Result := Result + 1;
end;  { MaxValueIndex }

function MinValueN(X : TVetorN) : TFloatType;
var
  i : integer;
begin
  Result := X[1];
  for i := 1 to High(X) do
    If Lower(X[i],Result,RelPrecision) then
      Result := X[i];
end;  { MinValueN }

function MaxValueN(X : TVetorN) : TFloatType;
var
  i : integer;
begin
  Result := X[1];
  for i := 1 to High(X) do
    If Greater(X[i],Result,RelPrecision) then
      Result := X[i];
end;  { MaxValueN }

function MeanValueN(X : TVetorN) : TFloatType;
var
  i : integer;
begin
  Result := 0;
  for i := 1 to High(X) do
  begin
    Result := Result + X[i];
  end;
  Result := Result/High(X);
end;  { MeanValueN }

function MinX(A,B : TFloatType) : TFloatType; overload;
begin
  Result := ((A+B)-sqrt((A-B)*(A-B)))/2;
end;  { MinX }

function MinX(A,B : integer) : integer; overload;
begin
  Result := Round(((A+B)-sqrt((A-B)*(A-B)))/2);
end;  { MinX }

function MaxX(A,B : TFloatType) : TFloatType; overload;
begin
  Result := ((A+B)+sqrt((A-B)*(A-B)))/2;
end;  { MaxX }

function MaxX(A,B : integer) : integer; overload;
begin
  Result := Round(((A+B)+sqrt((A-B)*(A-B)))/2);
end;  { MaxX }

function Confine(X, A, B : TFloatType) : TFloatType;
begin      { Delimita X entre A e B. B deve ser maior ou igual a A }
  Result := Min(X,B);
  Result := Max(Result,A);
end;  { Confine }

function Confine(X, A, B : integer) : integer;
begin      { Delimita X entre A e B. B deve ser maior ou igual a A }
  Result := Min(X,B);
  Result := Max(Result,A);
end;  { Confine }

function ConfineX(X, A, B : TFloatType) : TFloatType;
begin      { Delimita X entre A e B. B deve ser maior ou igual a A }
  Result := MinX(X,B);
  Result := MaxX(Result,A);
end;  { ConfineX }

function ConfineX(X, A, B : integer) : integer;
begin      { Delimita X entre A e B. B deve ser maior ou igual a A }
  Result := MinX(X,B);
  Result := MaxX(Result,A);
end;  { ConfineX }

function StepCicleFloat(R, Max, Step : TFloatType) : TFloatType;
begin  { Result cicle from zero to Max. Step must be less or equal to Max }
  R := R + Step;
  If Lower(R,0,RelPrecision) then
    R := R + Max
  Else If Greater(R,Max,RelPrecision) then
    R := R - Max;
  Result := R;
end;  { StepCicleFloat }

function StepCicleInteger(R, Max, Step : integer) : integer;
begin  { Result cicle from zero to Max. Step must be less or equal to Max }
  Confine(Step,0,Max);
  R := R + Step;
  If R < 0 then
    R := R + Max + 1
  Else If R > Max then
    R := R - Max - 1;
  Result := R;
end;  { StepCicleInteger }

function StepCicleNatural(R, Max, Step : integer) : integer;
begin  { Result cicle from one to Max. Step must be less or equal to Max }
  Confine(Step,0,Max);
  R := R + Step;
  If R < 1 then
    R := R + Max
  Else If R > Max then
    R := R - Max;
  Result := R;
end;  { StepCicleNatural }

function SymInteger(R, Max : integer) : integer;
begin    { Result is the corresponding index equally far from the center of a list }
         { from 1 to Max }
  Result := Max-R+1;
end;  { SymInteger }

function SymIntegerFZero(R, Max : integer) : integer;
begin    { Result is the corresponding index equally far from the center of a list }
         { from 0 to Max }
  Result := Max-R-1;
end;  { SymIntegerFZero }

function InvSymInteger(R, Max : integer) : integer;
begin    { Result is the corresponding index far Max div 2 from the given value R }
  Result := (Max div 2) + R;
end;  { InvSymInteger }

procedure RemoveValue(Index : integer; var X : TDouble);
var                          { Remove the value Index from vector X }
  i : integer;
begin
  If (Low(X)<=Index) and (Index<High(X)) then
  begin
    for i := Index to High(X)-1 do
      X[i] := X[i+1];
  end;
  SetLength(X,High(X)+1);
end;  { RemoveValue }

procedure RemoveValue(Index : integer; var X : TVetorN);
var                          { Remove o valor Index do vetor X }
  i : integer;
begin
  If (Low(X)<=Index) and (Index<High(X)) then
  begin
    for i := Index to High(X)-1 do
      X[i] := X[i+1];
  end;
  SetLength(X,High(X)+1);
end;  { RemoveValue }

procedure RemoveValue(Index : integer; var X : TVetorIN);
var                          { Remove o valor Index do vetor X }
  i : integer;
begin
  If (Low(X)<=Index) and (Index<High(X)) then
  begin
    for i := Index to High(X)-1 do
      X[i] := X[i+1];
  end;
  SetLength(X,High(X)+1);
end;  { RemoveValue }

procedure ProdutoVetorial(x1 : TFloatType; y1 : TFloatType; z1 : TFloatType;
                          x2 : TFloatType; y2 : TFloatType; z2 : TFloatType;
                          var x3 : TFloatType; var y3 : TFloatType; var z3 : TFloatType);
begin
  x3 := (y1*z2) - (y2*z1);
  y3 := (x2*z1) - (x1*z2);
  z3 := (x1*y2) - (x2*y1);
end;  { ProdutoVetorial }

function ProdutoVetorial(P1, P2 : T3DPoint): T3DPoint;
begin
  Result.X := (P1.Y*P2.Z) - (P2.Y*P1.Z);
  Result.Y := (P2.X*P1.Z) - (P1.X*P2.Z);
  Result.Z := (P1.X*P2.Y) - (P2.X*P1.Y);
end;  { ProdutoVetorial }

procedure ProdutoVetorial(N1, N2 : T3DPoint; var Result : TVetor3x1);
begin
  Result[1] := (N1.Y*N2.Z) - (N2.Y*N1.Z);
  Result[2] := (N2.X*N1.Z) - (N1.X*N2.Z);
  Result[3] := (N1.X*N2.Y) - (N2.X*N1.Y);
end;  { ProdutoVetorial }

function ProdutoVetorial(P1, P2 : TVetor3x1): TVetor3x1;
begin
  Result[1] := (P1[2]*P2[3]) - (P2[2]*P1[3]);
  Result[2] := (P2[1]*P1[3]) - (P1[1]*P2[3]);
  Result[3] := (P1[1]*P2[2]) - (P2[1]*P1[2]);
end;  { ProdutoVetorial }

procedure ProdutoVetorial(N1, N2 : TVetor3x1; var Result : T3DPoint);
begin
  Result.X := (N1[2]*N2[3]) - (N2[2]*N1[3]);
  Result.Y := (N2[1]*N1[3]) - (N1[1]*N2[3]);
  Result.Z := (N1[1]*N2[2]) - (N2[1]*N1[2]);
end;  { ProdutoVetorial }

function ProdutoVetorial_ABS(x1 : TFloatType; y1 : TFloatType; z1 : TFloatType;
                             x2 : TFloatType; y2 : TFloatType; z2 : TFloatType) : TFloatType;
var
  x3, y3, z3 : TFloatType;
begin
  x3 := (y1*z2) - (y2*z1);
  y3 := (x2*z1) - (x1*z2);
  z3 := (x1*y2) - (x2*y1);
  Result := sqrt(sqr(x3)+sqr(y3)+sqr(z3));
end;  { ProdutoVetorial_ABS }

function ProdutoVetorial_ABS(P1, P2 : T3DPoint) : TFloatType;
begin
  Result := Hypot3D(ProdutoVetorial(P1,P2));
end;  { ProdutoVetorial_ABS }

function ProdutoVetorial_ABS(P1, P2 : TVetor3x1) : TFloatType;
begin
  Result := Hypot3D(ProdutoVetorial(P1,P2));
end;  { ProdutoVetorial_ABS }

function ProdutoVetorial2D(x1 : TFloatType; y1 : TFloatType; x2 : TFloatType; y2 : TFloatType) : TFloatType;
begin
  Result := (x1*y2) - (x2*y1);
end;  { ProdutoVetorial2D }

procedure TriangleNormalVector(T : TTriangle; var XN, YN, ZN : TFloatType);
begin
  ProdutoVetorial(T[2].X-T[1].X,T[2].Y-T[1].Y,T[2].Z-T[1].Z,
                  T[3].X-T[1].X,T[3].Y-T[1].Y,T[3].Z-T[1].Z,
                  XN,YN,ZN);
end;  { TriangleNormalVector }

function TriangleNormalVector(T : TTriangle) : T3DPoint;
begin
  ProdutoVetorial(T[2].X-T[1].X,T[2].Y-T[1].Y,T[2].Z-T[1].Z,
                  T[3].X-T[1].X,T[3].Y-T[1].Y,T[3].Z-T[1].Z,
                  Result.X,Result.Y,Result.Z);
end;  { TriangleNormalVector }

function TriangleCenter(T : TTriangle) : T3DPoint;
begin
  Result.X := (T[1].X+T[2].X+T[3].X)/3;
  Result.Y := (T[1].Y+T[2].Y+T[3].Y)/3;
  Result.Z := (T[1].Z+T[2].Z+T[3].Z)/3;
end;  { TriangleCenter }

procedure TriangleCenter(T : TTriangle; var X, Y ,Z : TFloatType);
begin
  X := (T[1].X+T[2].X+T[3].X)/3;
  Y := (T[1].Y+T[2].Y+T[3].Y)/3;
  Z := (T[1].Z+T[2].Z+T[3].Z)/3;
end;  { TriangleCenter }

function TriangleArea(T : TTriangle) : TFloatType;
begin
  Result := Hypot3D(TriangleNormalVector(T))/2;
end;  { TriangleArea }

function TriangleArea(T : TTriangle2D) : TFloatType;
begin
  Result := ProdutoVetorial2D(T[2].X-T[1].X,T[2].Y-T[1].Y,
                              T[3].X-T[1].X,T[3].Y-T[1].Y)/2;
end;  { TriangleArea }

function TriangleAreaXY(T : TTriangle) : TFloatType;
begin
  Result := ProdutoVetorial2D(T[2].X-T[1].X,T[2].Y-T[1].Y,
                              T[3].X-T[1].X,T[3].Y-T[1].Y)/2;
end;  { TriangleAreaXY }

function TriangleAreaYZ(T : TTriangle) : TFloatType;
begin
  Result := ProdutoVetorial2D(T[2].Y-T[1].Y,T[2].Z-T[1].Z,
                              T[3].Y-T[1].Y,T[3].Z-T[1].Z)/2;
end;  { TriangleAreaYZ }

function TriangleAreaZX(T : TTriangle) : TFloatType;
begin
  Result := ProdutoVetorial2D(T[2].Z-T[1].Z,T[2].X-T[1].X,
                              T[3].Z-T[1].Z,T[3].X-T[1].X)/2;
end;  { TriangleAreaZX }

function TriangleMinX(T : TTriangle) : TFloatType;
begin
  Result := Min(T[3].X,Min(T[1].X,T[2].X));
end;  { TriangleMinX }

function TriangleMaxX(T : TTriangle) : TFloatType;
begin
  Result := Max(T[3].X,Max(T[1].X,T[2].X));
end;  { TriangleMaxX }

function TriangleMinY(T : TTriangle) : TFloatType;
begin
  Result := Min(T[3].Y,Min(T[1].Y,T[2].Y));
end;  { TriangleMinY }

function TriangleMaxY(T : TTriangle) : TFloatType;
begin
  Result := Max(T[3].Y,Max(T[1].Y,T[2].Y));
end;  { TriangleMaxY }

function TriangleMinZ(T : TTriangle) : TFloatType;
begin
  Result := Min(T[3].Z,Min(T[1].Z,T[2].Z));
end;  { TriangleMinZ }

function TriangleMaxZ(T : TTriangle) : TFloatType;
begin
  Result := Max(T[3].Z,Max(T[1].Z,T[2].Z));
end;  { TriangleMaxZ }

function TriangleGreaterX(T : TTriangle; X : TFloatType) : boolean;
var       { Checks if all the triangle points have X coordinates greater than X }
  i : byte;
begin
  i := 0;  Result := True;
  repeat
  begin
    Inc(i);
    If Greater(T[i].X,X,RelPrecision) then
      Result := True
    Else Result := False;
  end;
  until((i = 3) or (Result = False));
end;  { TriangleGreaterX }

function TriangleGreaterEqX(T : TTriangle; X : TFloatType) : boolean;
var       { Checks if all the triangle points have X coordinates greater than X }
  i : byte;
begin
  i := 0;  Result := True;
  repeat
  begin
    Inc(i);
    If GreaterEq(T[i].X,X,RelPrecision) then
      Result := True
    Else Result := False;
  end;
  until((i = 3) or (Result = False));
end;  { TriangleGreaterEqX }

function TriangleLowerX(T : TTriangle; X : TFloatType) : boolean;
var       { Checks if all the triangle points have X coordinates lower than X }
  i : byte;
begin
  i := 0;  Result := True;
  repeat
  begin
    Inc(i);
    If Lower(T[i].X,X,RelPrecision) then
      Result := True
    Else Result := False;
  end;
  until((i = 3) or (Result = False));
end;  { TriangleLowerX }

function TriangleLowerEqX(T : TTriangle; X : TFloatType) : boolean;
var       { Checks if all the triangle points have X coordinates lower than X }
  i : byte;
begin
  i := 0;  Result := True;
  repeat
  begin
    Inc(i);
    If LowerEq(T[i].X,X,RelPrecision) then
      Result := True
    Else Result := False;
  end;
  until((i = 3) or (Result = False));
end;  { TriangleLowerEqX }

function TrianglePlanPositiveSide(T : TTriangle; P : TPlan) : boolean;
var       { Checks if all the triangle points are on the same side of P normal vector }
  i : byte;
begin
  i := 0;  Result := True;
  repeat
  begin
    Inc(i);
    If Greater(ProdutoEscalar(T[i].X-P.X1,T[i].Y-P.Y1,T[i].Z-P.Z1,P.XN,P.YN,P.ZN),0,RelPrecision) then
      Result := True
    Else Result := False;
  end;
  until((i = 3) or (Result = False));
end;  { TrianglePlanPositiveSide }

function TrianglePlanPositiveEqSide(T : TTriangle; P : TPlan) : boolean;
var       { Checks if all the triangle points are on the same side of P normal vector }
  i : byte;
begin
  i := 0;  Result := True;
  repeat
  begin
    Inc(i);
    If GreaterEq(ProdutoEscalar(T[i].X-P.X1,T[i].Y-P.Y1,T[i].Z-P.Z1,P.XN,P.YN,P.ZN),0,RelPrecision) then
      Result := True
    Else Result := False;
  end;
  until((i = 3) or (Result = False));
end;  { TrianglePlanPositiveEqSide }

function TriangleCenterPlanPositiveSide(T : TTriangle; P : TPlan) : boolean;
var       { Checks if the triangle center is on the same side of P normal vector }
  C : T3DPoint;
begin
  C := TriangleCenter(T);
  If Greater(ProdutoEscalar(C.X-P.X1,C.Y-P.Y1,C.Z-P.Z1,P.XN,P.YN,P.ZN),0,RelPrecision) then
    Result := True
  Else Result := False;
end;  { TriangleCenterPlanPositiveSide }

function TrianglePlanNegativeSide(T : TTriangle; P : TPlan) : boolean;
var       { Checks if all the triangle points are on the opposite side of P normal vector }
  i, j : byte;
begin
  i := 0; j := 0;  Result := False;
  for i := 1 to 3 do
  begin
    If Lower(ProdutoEscalar(T[i].X-P.X1,T[i].Y-P.Y1,T[i].Z-P.Z1,P.XN,P.YN,P.ZN),0,RelPrecision) then
      Inc(j);
  end;
  If j = 3 then
    Result := True;
end;  { TrianglePlanNegativeSide }

function TriangleInsidePlan(T : TTriangle; P : TPlan) : boolean;
var       { Checks if all the triangle points are on the plan P }
  i, j : byte;
begin
  i := 0; j := 0;  Result := False;
  for i := 1 to 3 do
  begin
    If Equal(ProdutoEscalar(T[i].X-P.X1,T[i].Y-P.Y1,T[i].Z-P.Z1,P.XN,P.YN,P.ZN),0,RelPrecision) then
      Inc(j);
  end;
  If j = 3 then
    Result := True;
end;  { TriangleInsidePlan }

function Triangle_Plan_Intersection(T : TTriangle; P : TPlan) : TVetor3DPoint;
var                      { Defines the intercetion between a plan and a triangle }
  i, k : byte;
  intersect : boolean;
  X,Y,Z : TFloatType;
begin
  { Finds Intersections between Triangle T and the Plan P }
  k := 0;  SetLength(Result,1);
  for i := 1 to 2 do       { first two edges }
  begin
    intersect := False;
    Line_Plan_Intersection(T[i].X,T[i].Y,T[i].Z,T[i+1].X,T[i+1].Y,T[i+1].Z,P,
                           intersect,X,Y,Z);
    If intersect then
    begin
      Inc(k);  SetLength(Result,k+1);  Result[k] := Point3D(X,Y,Z);
    end;
  end;
  intersect := False;      { last edge }
  Line_Plan_Intersection(T[3].X,T[3].Y,T[3].Z,T[1].X,T[1].Y,T[1].Z,P,
                         intersect,X,Y,Z);
  If intersect  then
  begin
    Inc(k);  SetLength(Result,k+1);  Result[k] := Point3D(X,Y,Z);
  end;

  { Eliminates repeated intersection points of Result }
  Result := TPoly.RemoveRepeatedPts(k,Result);
end;  { Triangle_Plan_Intersection }

function TrianglePointOnEdge2D(X, Y : TFloatType; T : TTriangle) : boolean;
begin
  Result := False;
  If (PointInsideLine(X,Y,T[1].Y,T[1].Z,T[2].Y,T[2].Z)) or
     (PointInsideLine(X,Y,T[2].Y,T[2].Z,T[3].Y,T[3].Z)) or
     (PointInsideLine(X,Y,T[3].Y,T[3].Z,T[1].Y,T[1].Z)) then
    Result := True;
end;  { TrianglePointOnEdge2D }

procedure TriangleYZUpDown(T : TTriangle; var T1, T2 : TTriangle);
var       { Divides a triangle in two triangles by a horizontal line from the middle vertex }
  i, j : integer;
  P, PR : array[1..4]of T3DPoint;
  H : TFloatType;
  PL : T3DPoint;
begin
  { Transforms T in a closed polygon of 4 points }
  for i := 1 to 3 do
    P[i] := T[i];
  P[4] := T[1];

  { Finds the edge with biggest vertical gap }
  H := abs(P[2].Z-P[1].Z);  j := 1;
  for i := 1 to 3 do
    if Greater(abs(P[i+1].Z-P[i].Z),H,RelPrecision) then
    begin
      H := abs(P[i+1].Z-P[i].Z);  j := i;
    end;

  { Makes this edge the First edge }
  If j > 1 then
    for i := 1 to j-1 do
      PR[4-i+1] := P[j-i];
  for i := j to 4 do
    PR[i-j+1] := P[i];
  P := PR;

  for i := 1 to 3 do
    T[i] := P[i];

  { The Third point is the division point }
  { Finds the intersection of its height with First edge }
  PL.X := Linear_Interpolation(T[3].Z,T[1].Z,T[1].X,T[2].Z,T[2].X);
  PL.Y := Linear_Interpolation(T[3].Z,T[1].Z,T[1].Y,T[2].Z,T[2].Y);
  PL.Z := T[3].Z;
  { Set the pair of triangles }
  T1 := Triangle(T[1],PL,T[3]);  T2 := Triangle(PL,T[2],T[3]);
end;  { TriangleYZUpDown }

procedure TriangleDivisionVertex(T : TTriangle; var Index1, Index2 : Int03; var P : T3DPoint);
var                  { Gives the vertexes indexes necessary to divide the triangle T in two }
  i, j, k : Int03;   { triangles by a horizontal line from the middle vertex }
  H : TFloatType;
begin
  { Finds the edge with biggest vertical gap }
  H := abs(T[2].Z-T[1].Z);  j := 1;
  for i := 1 to 2 do
    if Greater(abs(T[i+1].Z-T[i].Z),H,RelPrecision) then
    begin
      H := abs(T[i+1].Z-T[i].Z);  j := i;
    end;
  if Greater(abs(T[1].Z-T[3].Z),H,RelPrecision) then
  begin
    H := abs(T[i+1].Z-T[i].Z);  j := 3;
  end;

  { Division Vertex }
  { vertex j from which comes the horizontal line that will intersect }
  { the Edge with Biggest Vertical Gap }
  i := TriangleNext2Vertex[j];
  k := TriangleNextVertex[j];
  P.X := Linear_Interpolation(T[i].Z,T[j].Z,T[j].X,T[k].Z,T[k].X);
  P.Y := Linear_Interpolation(T[i].Z,T[j].Z,T[j].Y,T[k].Z,T[k].Y);
  P.Z := T[i].Z;

  { Indexes that mark vertexes not aligned with the horizontal line }
  Index1 := i;  Index2 := k;
end;  { TriangleDivisionVertex }

procedure TriangleMaximumVerticalGapIndex(T : TTriangle; var Index1, Index2 : Int03);
var                  { Gives the vertexes indexes that bounds the edge with }
  i, j, k : Int03;   { biggest vertical gap }
  H : TFloatType;
begin
  { Finds the smallest vertex}
  H := T[1].Z;  Index1 := 1;
  for i := 2 to 3 do
    if Lower(T[i].Z,H,RelPrecision) then
    begin
      H := T[i].Z;  Index1 := i;
    end;

  { Finds the highest vertex }
  H := T[1].Z;  Index2 := 1;
  for i := 2 to 3 do
    if Greater(T[i].Z,H,RelPrecision) then
    begin
      H := T[i].Z;  Index2 := i;
    end;
end;  { TriangleMaximumVerticalGapIndex }

procedure Triangle2DUpDown(T : TTriangle2D; var T1,T2 : TTriangle2D);
var       { Divides a 2D triangle in two triangles with horizontal bases }
  i, j : integer;
  T2D : TTriangle2D;
  P, PR : array[1..4]of T2DPoint;
  H : TFloatType;
  PL : T2DPoint;
begin
  { Transforms T in a closed polygon of 4 points }
  for i := 1 to 3 do
    P[i] := T[i];
  P[4] := T[1];

  { Finds the edge with biggest vertical gap }
  H := P[2].Y-P[1].Y;  j := 1;
  for i := 1 to 3 do
    if Greater(P[i+1].Y-P[i].Y,H,RelPrecision) then
    begin
      H := P[i+1].Y-P[i].Y;  j := i;
    end;

  { Makes this edge the First edge }
  If j > 1 then
    for i := 1 to j-1 do
      PR[4-i+1] := P[j-i];
  for i := j to 4 do
    PR[i-j+1] := P[i];
  P := PR;

  for i := 1 to 3 do
    T[i] := PR[i];

  { The Third point is the division point }
  { Finds the intersection of its height with First edge }
  PL.X := Linear_Interpolation(T[3].Y,T[1].Y,T[1].X,T[2].Y,T[2].X);
  PL.Y := T[3].Y;

  T1 := Triangle(T[1],PL,T[3]);  T2 := Triangle(PL,T[2],T[3]);
end;  { Triangle2DUpDown }

function TriangleSlice(T : TTriangle; P : TPlan) : TTriangles;
          { Slices one triangle in as many parts as the Plan allows to (1,2 or, at most, 3) }
begin

end;  { TriangleSlice }

function TriangleTrim(T : TTriangle; P : TPlan) : TTriangles;
var       { Trim one triangle in as many parts as the Plan allows to (0, 1 or 2) }
  i, j, k, r : byte;
  s : integer;
  L : TVetor3DPoint;
  TR : TTriangle;
begin
  If TrianglePlanNegativeSide(T,P)  then  { Triangle outside plan boundary }
    SetLength(Result,0)
  Else If TriangleInsidePlan(T,P)  then   { Triangle on plan }
  begin
    SetLength(Result,2);  Result[1] := T;
  end
  Else begin                                    { Triangle inside plan boundary }
    L := Triangle_Plan_Intersection(T,P);
    k := High(L);
    { Builds sub-triangles after the Intersection }
    If k <= 1 then        // One or none point touches the plan
    begin
      SetLength(Result,2);  Result[1] := T;
    end
    Else If k = 2 then    // Two points touch the plan
    begin
      r := 0;
      for i := 1 to 3 do
      begin
        If Equal(Dist_PointToPlan(T[i].X,T[i].Y,T[i].Z,P),0,RelPrecision) then
          Inc(r);
      end;

      If r > 1 then  // One edge lies on Plan P
      begin
        SetLength(Result,2);  Result[1] := T;
      end
      Else begin
        j := 0;  SetLength(Result,0);
        { First two sub-triangles }
        for i := 1 to 2 do
        begin
          TR[1] := T[i];  TR[2] := L[1];  TR[3] := L[2];
          If (Unequal(TriangleArea(TR),0,RelPrecision)) and
             (TrianglePlanPositiveEqSide(TR,P) ) then
          begin
            Inc(j);  SetLength(Result,j+1);  Result[j] := TR;
          end;
        end;
        { Third sub-triangle }
        TR[1] := T[3];  TR[2] := T[1];
        for i := 1 to 2 do
        begin
          If Equal(Dist_PointToLine(L[i],T[1],T[3]),0,RelPrecision) then
            TR[3] := L[i];
        end;
        If (Unequal(TriangleArea(TR),0,RelPrecision)) and
           (TrianglePlanPositiveEqSide(TR,P) ) then
        begin
          Inc(j);  SetLength(Result,j+1);  Result[j] := TR;
        end;
      end;
    end;
  end;
end;  { TriangleTrim }

function PlanePointDepth(Y,Z,X1,Y1,Z1,XN,YN,ZN : TFloatType) : TFloatType;
begin    { Computes X coordinate of a plan, being known Y and Z }
  If Unequal(XN,0,RelPrecision) then
    Result := ((XN*X1)+(YN*Y1)+(ZN*Z1)-(YN*Y)-(ZN*Z))/XN
  Else Result := 0;
end;  { PlanePointDepth }

function PlanePointDepthPersp(Y,Z,xV,X1,Y1,Z1,XN,YN,ZN : TFloatType) : TFloatType;
begin    { Computes X coordinate of a plan, being known Y and Z. It's considered }
         { perspective distortion by xV. Camera position is the origin. }
  If Unequal((XN*xV)+(YN*Y)+(ZN*Z),0,RelPrecision) then
    Result := xV*((XN*X1)+(YN*Y1)+(ZN*Z1))/((XN*xV)+(YN*Y)+(ZN*Z))
  Else Result := 0;
end;  { PlanePointDepthPersp }

procedure ProdutoEscalar(x1 : TFloatType; y1 : TFloatType; z1 : TFloatType;
                                x2 : TFloatType; y2 : TFloatType; z2 : TFloatType;
                                var PEResult : TFloatType);
begin
  PEResult := (x1*x2) + (y1*y2) + (z1*z2);
end; { ProdutoEscalar }

procedure ProdutoEscalar(P1, P2 : T3DPoint; var PEResult : TFloatType);
begin
  PEResult := (P1.X*P2.X) + (P1.Y*P2.Y) + (P1.Z*P2.Z);
end; { ProdutoEscalar }

function ProdutoEscalar(x1 : TFloatType; y1 : TFloatType; z1 : TFloatType;
                        x2 : TFloatType; y2 : TFloatType; z2 : TFloatType) : TFloatType;
begin
  Result := (x1*x2) + (y1*y2) + (z1*z2);
end; { ProdutoEscalar }

function ProdutoEscalar(P1, P2 : T3DPoint) : TFloatType;
begin
  Result := (P1.X*P2.X) + (P1.Y*P2.Y) + (P1.Z*P2.Z);
end; { ProdutoEscalar }

function ProdutoEscalar(P1, P2 : TVetor3x1) : TFloatType;
begin
  Result := (P1[1]*P2[1]) + (P1[2]*P2[2]) + (P1[3]*P2[3]);
end; { ProdutoEscalar }

function ProdutoEscalar_ANG(x1 : TFloatType; y1 : TFloatType; z1 : TFloatType;
                            x2 : TFloatType; y2 : TFloatType; z2 : TFloatType) : TFloatType;
begin
  Result := 0;
  If (Unequal(Hypot3D(x1,y1,z1),0,RelPrecision)) and (Unequal(Hypot3D(x2,y2,z2),0,RelPrecision)) and
     (ABS(((x1*x2)+(y1*y2)+(z1*z2))/(Hypot3D(x1,y1,z1)*Hypot3D(x2,y2,z2)))<=1) then
    Result := RadToDeg(ARCCOS(((x1*x2)+(y1*y2)+(z1*z2))/(Hypot3D(x1,y1,z1)*Hypot3D(x2,y2,z2))))
  Else If (Equal(Hypot3D(x1,y1,z1),0,RelPrecision)) or (Equal(Hypot3D(x2,y2,z2),0,RelPrecision)) then
    Result := 90;
end;  { ProdutoEscalar_ANG }

function ProdutoEscalar_ANG(P1, P2 : T3DPoint) : TFloatType;
begin
  Result := 0;
  If (Unequal(Hypot3D(P1),0,RelPrecision)) and (Unequal(Hypot3D(P2),0,RelPrecision)) and
  (ABS(ProdutoEscalar(P1,P2)/(Hypot3D(P1)*Hypot3D(P2)))<=1) then
    Result := RadToDeg(ARCCOS(ProdutoEscalar(P1,P2)/(Hypot3D(P1)*Hypot3D(P2))))
  Else If (Equal(Hypot3D(P1),0,RelPrecision)) or (Equal(Hypot3D(P2),0,RelPrecision)) then
    Result := 90;
end;  { ProdutoEscalar_ANG }

function ProdutoEscalar_ANG(P1, P2 : TVetor3x1) : TFloatType;
begin
  Result := 0;
  If (Unequal(Hypot3D(P1),0,RelPrecision)) and (Unequal(Hypot3D(P2),0,RelPrecision)) and
  (ABS(ProdutoEscalar(P1,P2)/(Hypot3D(P1)*Hypot3D(P2)))<=1) then
    Result := RadToDeg(ARCCOS(ProdutoEscalar(P1,P2)/(Hypot3D(P1)*Hypot3D(P2))))
  Else If (Equal(Hypot3D(P1),0,RelPrecision)) or (Equal(Hypot3D(P2),0,RelPrecision)) then
    Result := 90;
end;  { ProdutoEscalar_ANG }

function Greater(X : TFloatType; A : TFloatType; Precision : TFloatType) : boolean;
begin         { Verifica se X é maior do que A }
  {If RoundTo(X,MaxPrecision)>RoundTo(A,MaxPrecision) then
    Result := True
  Else Result := False;}
  If X > A+(Precision*Max(ABS(X),ABS(A))) then
    Result := True
  Else Result := False;
  //If X > A then Result := True Else Result := False;
end;  { Greater }

function GreaterEq(X : TFloatType; A : TFloatType; Precision : TFloatType) : boolean;
begin         { Verifica se X é maior ou igual a A }
  (*{If (Equal(X,A,Precision)) then
    Result := True
  Else }If RoundTo(X,MaxPrecision)>=RoundTo(A,MaxPrecision) then
    Result := True
  Else Result := False;*)
  If (Equal(X,A,Precision)) then
    Result := True
  Else begin
    If X > A+(Precision*Max(ABS(X),ABS(A))) then
      Result := True
    Else Result := False;
  end;
  //If X >= A then Result := True Else Result := False;
end;  { Greater }

function Lower(X : TFloatType; A : TFloatType; Precision : TFloatType) : boolean;
begin         { Verifica se X é menor do que A }
  {If RoundTo(X,MaxPrecision)<RoundTo(A,MaxPrecision) then
    Result := True
  Else Result := False;}
  If X < A-(Precision*Max(ABS(X),ABS(A))) then
    Result := True
  Else Result := False;

  //If X < A then Result := True Else Result := False;
end;  { Lower }

function LowerEq(X : TFloatType; A : TFloatType; Precision : TFloatType) : boolean;
begin         { Verifica se X é menor ou igual a A }
  (*//If (Equal(X,A,Precision)) then
    //Result := True
  {Else }If RoundTo(X,MaxPrecision)<=RoundTo(A,MaxPrecision) then
    Result := True
  Else Result := False;*)
  If (Equal(X,A,Precision)) then
    Result := True
  Else begin
    If X < A-(Precision*Max(ABS(X),ABS(A))) then
      Result := True
    Else Result := False;
  end;
  //If X <= A then Result := True Else Result := False;
end;  { LowerEq }

function Equal(X : TFloatType; A : TFloatType; Precision : TFloatType) : boolean;
var
  absA, absX, absDif : TFloatType;
begin         { Verifica se X e A são aproximadamente iguais }
 {// absA := ABS(A); absX := ABS(X); absDif := ABS(X-A);
  If X = A then
    Result := True
  Else begin
    If RoundTo(X,MaxPrecision)=RoundTo(A,MaxPrecision) then
      Result := True
    Else Result := False;
  end;}
  //If X = A then Result := True Else Result := False;
  If X = A then
    Result := True
  Else begin
    If ABS(X-A)<epsilon then
      Result := True
    Else If ABS(X-A)<Precision*Max(ABS(X),ABS(A)) then
      Result := True
    Else If ABS(X-A)>=Precision*Max(ABS(X),ABS(A)) then
      Result := False;
  end;
end;  { Equal }

function Unequal(X : TFloatType; A : TFloatType; Precision : TFloatType) : boolean;
begin         { Verifica se X e A são suficientemente diferentes }
  Result := not (Equal(X,A,Precision));
  
  {If X = A then
    Result := False
  Else begin
    If ABS(X-A)<epsilon then
      Result := False
    Else If ABS(X-A)<Precision*Max(ABS(X),ABS(A)) then
        Result := False
    Else If ABS(X-A)>=Precision*Max(ABS(X),ABS(A)) then
        Result := True;
  end;}

  (*If X = A then
    Result := False
  Else If ABS(X-A)<Precision*Max(ABS(X),ABS(A)) then
    Result := False
  Else Result := True;*)
end;  { Unequal }

function Between(X : TFloatType; A, B : TFloatType; Precision : TFloatType) : boolean;
begin       { Verifica se X E (A,B) ou (B,A) }
  //Result := -(X-A)*(X-B);
  If (Greater(X,Min(A,B),Precision)) and (Lower(X,Max(A,B),Precision)) then
    Result := True
  Else Result := False;
end;  { Between }

function Between(X : integer; A, B : integer) : integer;
begin       { Se Between > 0, X E(A,B) ou X E(B,A) }
            { Se Between >= 0, X E[A,B] ou X E[B,A] }
            { Se Between < 0, X E(-inf,A)U(B,+inf) ou X E(-inf,B)U(A,+inf) }
            { Se Between <= 0, X E(-inf,A]U[B,+inf) ou X E(-inf,B]U[A,+inf) }
  Result := -(X-A)*(X-B);
end;  { Between }

function BetweenEq(X : TFloatType; A, B : TFloatType; Precision : TFloatType) : boolean;
begin       { Verifica se X E (A,B) ou (B,A) }
  //Result := -(X-A)*(X-B);
  If (GreaterEq(X,Min(A,B),Precision)) and (LowerEq(X,Max(A,B),Precision)) then
    Result := True
  Else Result := False;
end;  { BetweenEq }

function OutRange(X : TFloatType; A, B : TFloatType;  Precision : TFloatType) : boolean;
begin       { Verifica se X E (-inf,Min(A,B)) ou (Max(A,B),+inf) }
  If (Lower(X,Min(A,B),Precision)) or (Greater(X,Max(A,B),Precision)) then
    Result := True
  Else Result := False;
end;  { OutRange }

function OutRangeEq(X : TFloatType; A, B : TFloatType;  Precision : TFloatType) : boolean;
begin       { Verifica se X E (-inf,Min(A,B)] ou [Max(A,B),+inf) }
  //Result := -(X-A)*(X-B);
  If (LowerEq(X,Min(A,B),Precision)) or (GreaterEq(X,Max(A,B),Precision)) then     // i.e.: (X <= Min(A,B)) or (X >= Max(A,B))
    Result := True
  Else Result := False;
end;  { OutRangeEq }

function Linear_Interpolation(X : TFloatType; X1,Y1,X2,Y2 : TFloatType) : TFloatType;
begin           { Interpola Y em uma reta para um dado X intermediário }
  Result := Y1;
  If Unequal(X1,X2,RelPrecision) then
    Result := Y1+((X-X1)*(Y2-Y1)/(X2-X1))
  Else If (Equal(X1,X2,RelPrecision)) and (Equal(X,X1,RelPrecision)) then
    Result := Y1;
end;  { Linear_Interpolation }

function Linear_IntegerInterpolation(X : integer; X1,Y1,X2,Y2 : TFloatType) : integer;
begin           { Interpola Y em uma reta para um dado X intermediário }
  Result := Round(Y1);
  If Unequal(X1,X2,RelPrecision) then
    Result := Round(Y1+((X-X1)*(Y2-Y1)/(X2-X1)))
  Else If (Equal(X1,X2,RelPrecision)) and (Equal(X,X1,RelPrecision)) then
    Result := Round(Y1);
end;  { Linear_IntegerInterpolation }

procedure Linear_Intersection(X1,Y1,X2,Y2,X3,Y3,X4,Y4 : TFloatType; var Intersect : boolean;
                              var X, Y : TFloatType);
var                  { Determina Interseção entre Duas Retas }
  PVet : TFloatType;       { ((X1,Y1),(X2,Y2)) e ((X3,Y3),(X4,Y4)) }
begin
  PVet := ProdutoVetorial2D(X2-X1,Y2-Y1,X4-X3,Y4-Y3);
  If PVet <> 0 then
  begin
    X := (((Y3-Y1)*(X2-X1)*(X4-X3))-(X3*(Y4-Y3)*(X2-X1))+(X1*(Y2-Y1)*(X4-X3)))/(-PVet);
    Y := (((X3-X1)*(Y2-Y1)*(Y4-Y3))-(Y3*(X4-X3)*(Y2-Y1))+(Y1*(X2-X1)*(Y4-Y3)))/PVet;
    If (LowerEq(Dist_Points(X,Y,0,(X2+X1)/2,(Y2+Y1)/2,0),Dist_Points(X1,Y1,0,X2,Y2,0)/2,RelPrecision))
    and (LowerEq(Dist_Points(X,Y,0,(X3+X4)/2,(Y3+Y4)/2,0),Dist_Points(X3,Y3,0,X4,Y4,0)/2,RelPrecision)) then
      Intersect := True
    Else Intersect := False;
  end
  Else If PVet = 0 then
  begin
    Intersect := False;
    X := 0;
    Y := 0;
  end;
end;  { Linear_Intersection }

function Line2D(P1,P2 : T2DPoint) : T2DLine;
begin
  Result[1] := P1;  Result[2] := P2;
end;  { Line2D }

function PointInsideLine(X,Y,X1,Y1,X2,Y2 : TFloatType) : boolean;
begin  { Resulta True se o ponto X,Y estiver entre (X1,Y1) e (X2,Y2) }
  Result := False;
  If Equal(Dist_PointToLine(X,Y,X1,Y1,X2,Y2),0,RelPrecision) then    { Colinear point }
  begin
    If (EqualPoints(Point2D(X,Y),Point2D(X1,Y1))) or (EqualPoints(Point2D(X,Y),Point2D(X2,Y2))) then
      Result := True                                                         { Coincident to boundaries }
    Else If LowerEq(Dist_Points(X,Y,(X2+X1)/2,(Y2+Y1)/2),Dist_Points(X1,Y1,X2,Y2)/2,RelPrecision) then
      Result := True;                                                        { Between two boundaries }
  end;
end;  { PointInsideLine }

function PointInsideLine(X,Y,Z,X1,Y1,Z1,X2,Y2,Z2 : TFloatType) : boolean;
begin  { Resulta True se o ponto X,Y,Z estiver entre (X1,Y1,Z1) e (X2,Y2,Z2) }
  Result := False;
  If Equal(Dist_PointToLine(X,Y,Z,X1,Y1,Z1,X2,Y2,Z2),0,RelPrecision) then    { Colinear point }
  begin
    If (EqualPoints(Point3D(X,Y,Z),Point3D(X1,Y1,Z1))) or (EqualPoints(Point3D(X,Y,Z),Point3D(X2,Y2,Z2))) then
      Result := True                                                         { Coincident to boundaries }
    Else If LowerEq(Dist_Points(X,Y,Z,(X2+X1)/2,(Y2+Y1)/2,(Z2+Z1)/2),Dist_Points(X1,Y1,Z1,X2,Y2,Z2)/2,RelPrecision) then
      Result := True;                                                        { Between two boundaries }
  end;
end;  { PointInsideLine }

function PointInsideLineR(X,Y,X1,Y1,X2,Y2 : TFloatType) : boolean;
begin  { Resulta True se o ponto X,Y estiver entre (X1,Y1) e (X2,Y2) }
  Result := False;
  If Dist_PointToLine(X,Y,X1,Y1,X2,Y2) = 0 then    { Colinear point }
  begin
    If (EqualPointsR(Point2D(X,Y),Point2D(X1,Y1))) or (EqualPointsR(Point2D(X,Y),Point2D(X2,Y2))) then
      Result := True                                                         { Coincident to boundaries }
    Else If Dist_Points(X,Y,(X2+X1)/2,(Y2+Y1)/2) <= Dist_Points(X1,Y1,X2,Y2)/2 then
      Result := True;                                                        { Between two boundaries }
  end;
end;  { PointInsideLineR }

function PointInsideLineR(X,Y,Z,X1,Y1,Z1,X2,Y2,Z2 : TFloatType) : boolean;
begin  { Resulta True se o ponto X,Y,Z estiver entre (X1,Y1,Z1) e (X2,Y2,Z2) }
  Result := False;
  If Dist_PointToLineR(X,Y,Z,X1,Y1,Z1,X2,Y2,Z2) = 0 then
  begin
    If (EqualPointsR(Point3D(X,Y,Z),Point3D(X1,Y1,Z1))) or (EqualPointsR(Point3D(X,Y,Z),Point3D(X2,Y2,Z2))) then
      Result := True
    Else If Dist_Points(X,Y,Z,(X2+X1)/2,(Y2+Y1)/2,(Z2+Z1)/2) <= Dist_Points(X1,Y1,Z1,X2,Y2,Z2)/2 then
      Result := True;
  end;
end;  { PointInsideLineR }

function PointInsideTriangle(X, Y, Z : TFloatType; T : TTriangle) : boolean;
var
  A : TFloatType;
  T1,T2,T3 : TTriangle;
begin
  Result := True;
  T1 := Triangle(X,Y,Z,T[1].X,T[1].Y,T[1].Z,T[2].X,T[2].Y,T[2].Z);  { Edge 1-2 }
  T2 := Triangle(X,Y,Z,T[2].X,T[2].Y,T[2].Z,T[3].X,T[3].Y,T[3].Z);  { Edge 2-3 }
  T3 := Triangle(X,Y,Z,T[3].X,T[3].Y,T[3].Z,T[1].X,T[1].Y,T[1].Z);  { Edge 3-1 }

  A := abs(TriangleArea(T1))+abs(TriangleArea(T2))+abs(TriangleArea(T3));

  If Greater(A,abs(TriangleArea(T)),RelPrecision) then
    Result := False;
end;  { PointInsideTriangle }

function PointInsideTriangle2D(X, Y : TFloatType; T : TTriangle) : boolean;
var
  A : TFloatType;
  T1,T2,T3 : TTriangle2D;
begin
  Result := True;
  T1 := Triangle(X,Y,T[1].Y,T[1].Z,T[2].Y,T[2].Z);  { Edge 1-2 }
  T2 := Triangle(X,Y,T[2].Y,T[2].Z,T[3].Y,T[3].Z);  { Edge 2-3 }
  T3 := Triangle(X,Y,T[3].Y,T[3].Z,T[1].Y,T[1].Z);  { Edge 3-1 }

  A := abs(TriangleArea(T1))+abs(TriangleArea(T2))+abs(TriangleArea(T3));

  If Greater(A,abs(TriangleAreaYZ(T)),RelPrecision) then
    Result := False;
end;  { PointInsideTriangle }

procedure Line_Plan_Intersection(X1,Y1,Z1,X2,Y2,Z2,Xp,Yp,Zp,XN,YN,ZN : TFloatType;
                                 var Intersect : boolean; var X,Y,Z : TFloatType);
var             { Determina interseção entre um segmento de reta e um plano }
  P1,N : T3DPoint;               { Linha NO PLANO NÃO CONTA como interseção }
  PE, D : TFloatType; strmsg : string;
begin
  PE := ProdutoEscalar(XN,YN,ZN,X2-X1,Y2-Y1,Z2-Z1);
  strmsg := '';
  If Equal(PE,0,RelPrecision)=False then
  begin
    { D é a quantidade de vetores r = (X2-X1,Y2-Y1,Z2-Z1) até a interseção }
    P1 := Point3D(Xp-X1,Yp-Y1,Zp-Z1);  N := Point3D(XN,YN,ZN);
    D := ProdutoEscalar(P1,N)/PE;     { onde : D(r.N) = P1.N , projeções em N }
    { Ponto de Interseção é (X1,Y1,Z1) + Dr }
    P1 := Point3D(X2-X1,Y2-Y1,Z2-Z1);
    P1 := FactorPoint3D(P1,[D]);
    X := P1.X + X1;  Y := P1.Y + Y1;  Z := P1.Z + Z1;
    {strmsg := strmsg + 'X1'+char(9)+'Y1'+char(9)+'Z1'+char(13)+PointToStr(X1,Y1,Z1,fffixed,18,18)+char(13)+char(13)
                     + 'X2'+char(9)+'Y2'+char(9)+'Z2'+char(13)+PointToStr(X2,Y2,Z2,fffixed,18,18)+char(13)+char(13)
                     + 'X2-X1'+char(9)+'Y2-Y1'+char(9)+'Z2-Z1'+char(13)+PointToStr(X2-X1,Y2-Y1,Z2-Z1,fffixed,18,18)+char(13)+char(13)
                     + 'D'+char(13)+FloatToStrF(D,fffixed,18,18)+char(13)+char(13)
                     + 'X'+char(9)+'Y'+char(9)+'Z'+char(13)+PointToStr(X,Y,Z,fffixed,18,18)+char(13)+char(13);

    strmsg := strmsg + 'Dist_PointToLine(X,Y,Z,X1,Y1,Z1,X2,Y2,Z2)'+char(13)+FloatToStrF(Dist_PointToLine(X,Y,Z,X1,Y1,Z1,X2,Y2,Z2),fffixed,18,18)
    +char(13)+'Dist_Points(X,Y,Z,(X2+X1)/2,(Y2+Y1)/2,(Z2+Z1)/2)'+char(13)+
    FloatToStrF(Dist_Points(X,Y,Z,(X2+X1)/2,(Y2+Y1)/2,(Z2+Z1)/2),fffixed,18,18)+char(13)+
    'Dist_Points(X1,Y1,Z1,X2,Y2,Z2)/2'+char(13)+FloatToStrF(Dist_Points(X1,Y1,Z1,X2,Y2,Z2)/2,fffixed,18,18)+char(13)+char(13);}
    If PointInsideLine(X,Y,Z,X1,Y1,Z1,X2,Y2,Z2) then
    begin
      {strmsg := strmsg + 'INSIDE';     ShowMessage(strmsg);}
      Intersect := True;
    end
    Else If PointInsideLine(X,Y,Z,X1,Y1,Z1,X2,Y2,Z2) = False then
    begin
      {strmsg := strmsg + 'not inside'; ShowMessage(strmsg);}
      Intersect := False;
      X := 0; Y := 0; Z := 0;
    end;
  end
  Else If Equal(PE,0,RelPrecision) then   { Linha perpendicular ao Vetor Normal }
  begin     { Mesmo se a linha pertence ao plano, [NÃO CONTA] COMO INTERSEÇÃO }
      Intersect := False;
      X := 0;  Y := 0; Z := 0;
  end;

end;  { Line_Plan_Intersection }

procedure Line_Plan_Intersection(X1,Y1,Z1,X2,Y2,Z2 : TFloatType; P : TPlan;
                                 var Intersect : boolean; var X,Y,Z : TFloatType);
var             { Determina interseção entre um segmento de reta e um plano }
  P1,N : T3DPoint;               { Linha NO PLANO NÃO CONTA como interseção }
  PE, D : TFloatType;
begin
  PE := ProdutoEscalar(P.XN,P.YN,P.ZN,X2-X1,Y2-Y1,Z2-Z1);
  If Equal(PE,0,RelPrecision)=False then
  begin
    { D é a quantidade de vetores r = (X2-X1,Y2-Y1,Z2-Z1) até a interseção }
    P1 := Point3D(P.X1-X1,P.Y1-Y1,P.Z1-Z1);  N := Point3D(P.XN,P.YN,P.ZN);
    D := ProdutoEscalar(P1,N)/PE;     { onde : D(r.N) = P1.N , projeções em N }
    { Ponto de Interseção é (X1,Y1,Z1) + Dr }
    P1 := Point3D(X2-X1,Y2-Y1,Z2-Z1);
    P1 := FactorPoint3D(P1,[D]);
    X := P1.X + X1;  Y := P1.Y + Y1;  Z := P1.Z + Z1;

    If PointInsideLine(X,Y,Z,X1,Y1,Z1,X2,Y2,Z2) then
    begin
      Intersect := True;
    end
    Else If PointInsideLine(X,Y,Z,X1,Y1,Z1,X2,Y2,Z2) = False then
    begin
      Intersect := False;
      X := 0; Y := 0; Z := 0;
    end;
  end
  Else If Equal(PE,0,RelPrecision) then   { Linha perpendicular ao Vetor Normal }
  begin       { Mesmo se a linha pertence ao plano, [NÃO CONTA] COMO INTERSEÇÃO }
      Intersect := False;
      X := 0;  Y := 0; Z := 0;
  end;
end;  { Line_Plan_Intersection }

procedure Line_Plan_Intersection(X1,Y1,Z1,X2,Y2,Z2 : TFloatType; P : TPlan;
                                 var Intersect : boolean; var Pts : TSetofPoints3D);
var             { Determina interseção entre um segmento de reta e um plano }
  P1,N : T3DPoint;                   { Linha NO PLANO CONTA como interseção }
  PE, D : TFloatType;
  X, Y, Z : TFloatType;
begin
  Pts.N := 0;  SetLength(Pts.P,1);
  PE := ProdutoEscalar(P.XN,P.YN,P.ZN,X2-X1,Y2-Y1,Z2-Z1);
  If Equal(PE,0,RelPrecision)=False then
  begin
    { D é a quantidade de vetores r = (X2-X1,Y2-Y1,Z2-Z1) até a intersecção }
    P1 := Point3D(P.X1-X1,P.Y1-Y1,P.Z1-Z1);  N := Point3D(P.XN,P.YN,P.ZN);
    D := ProdutoEscalar(P1,N)/PE;     { onde : D(r.N) = P1.N , projeções em N }
    { Ponto de Intersecção é (X1,Y1,Z1) + Dr }
    P1 := Point3D(X2-X1,Y2-Y1,Z2-Z1);
    P1 := FactorPoint3D(P1,[D]);
    X := P1.X + X1;  Y := P1.Y + Y1;  Z := P1.Z + Z1;

    If PointInsideLine(X,Y,Z,X1,Y1,Z1,X2,Y2,Z2) then
    begin
      Intersect := True;
      Pts.N := 1;  SetLength(Pts.P,Pts.N+1);
      Pts.P[1] := Point3D(X,Y,Z);
    end
    Else If PointInsideLine(X,Y,Z,X1,Y1,Z1,X2,Y2,Z2) = False then
    begin
      Intersect := False;
    end;
  end
  Else If Equal(PE,0,RelPrecision) then   { Linha perpendicular ao Vetor Normal }
  begin                { Se a linha pertence ao plano, [CONTA] COMO INTERSECÇÃO }
      Intersect := False;
      If Equal(Dist_PointToPlan(X1,Y1,Z1,P),0,RelPrecision) then
      begin
        Intersect := True;
        Pts.N := 2;  SetLength(Pts.P,Pts.N+1);
        Pts.P[1] := Point3D(X1,Y1,Z1);
        Pts.P[2] := Point3D(X2,Y2,Z2);
      end;
  end;
end;  { Line_Plan_Intersection }

function IntegerToRoman(N : Integer) : WideString;
const             { Converte Números Cardinais para Números Romanos }
  Arabics: Array[1..13] of integer = (1,4,5,9,10,40,50,90,100,400,500,900,1000);
  Romans: Array[1..13] of string = ('I','IV','V','IX','X','XL','L','XC','C','CD','D','CM','M') ;
var
  i: integer;
begin
   Result := '';
   If N > 0 then
   begin
     for i := 13 downto 1 do
       while (N >= Arabics[i]) do
       begin
         N := N - Arabics[i];
         Result := Result + Romans[i];
       end;
   end
   Else Result := '0';
end;  { IntegerToRoman }

function FlipBoolean(X : boolean) : boolean;
begin
  If X = False then Result := True
  Else If X then Result := False;
end;  { FlipBoolean }

function REGRA_SIMPSON(x1 : TFloatType; y1 : TFloatType; x2 : TFloatType; y2 : TFloatType; x3 : TFloatType; y3 : TFloatType): TFloatType;
var                                                          { SIMPSON COM ESPAÇAMENTO NÃO CONSTANTE }
  h1,h2 : TFloatType;                                  { (x1,y1),(x2,y2) e (x3,y3) são pontos consecutivos }
begin

  h1 := x2-x1;  h2 := x3-x2;
  Result := 0;

  If (Unequal(h1,0,RelPrecision)) and (Unequal(h2,0,RelPrecision)) and
     (Unequal(x3-x1,0,RelPrecision)) and (Lower(x1,x2,RelPrecision)) and
     (Lower(x2,x3,RelPrecision)) then
    Result := (h1+h2)*(((2-(h2/h1))*y1)+((2+(h2/h1)+(h1/h2))*y2)+((2-(h1/h2))*y3))/6  { Simpson }
    //Result := (h1*(y1+y2)/2)+(h2*(y2+y3)/2) { Trapézios }
  Else If Equal(h1,0,RelPrecision) then
    Result := h2*(y2+y3)/2                    { Trapézios }
  Else If Equal(h2,0,RelPrecision) then
    Result := h1*(y1+y2)/2                    { Trapézios }
  Else If Equal(h1,0,RelPrecision) and Equal(h2,0,RelPrecision) then
    Result := 0;

end;  { REGRA_SIMPSON }

function Hypot3D(X,Y,Z : TFloatType) : TFloatType;
begin
  Result := sqrt(sqr(X)+sqr(Y)+sqr(Z));
end;  { Hypot3D }

function Hypot3D(P : TVetor3x1) : TFloatType;
begin
  Result := sqrt(sqr(P[1])+sqr(P[2])+sqr(P[3]));
end;  { Hypot3D }

function Hypot3D(P : T3DPoint) : TFloatType;
begin
  Result := sqrt(sqr(P.X)+sqr(P.Y)+sqr(P.Z));
end;  { Hypot3D }

function Point2D(X,Y : TFloatType) : T2DPoint;
begin
  Result.X := X;  Result.Y := Y;
end;  { Point2D }

function Point3D(X,Y,Z : TFloatType) : T3DPoint;
begin
  Result.X := X;  Result.Y := Y;  Result.Z := Z;
end;  { Point3D }

procedure Point3D(X,Y,Z : TFloatType; var ResultX, ResultY, ResultZ : TFloatType);
begin
  ResultX := X;  ResultY := Y;  ResultZ := Z;
end;  { Point3D }

function Vetor3x1(X,Y,Z : TFloatType) : TVetor3x1;
begin
  Result[1] := X;  Result[2] := Y;  Result[3] := Z;
end;  { Vetor3x1 }

function ScreenPoint(P : T3DPoint; SizeRatio : TFloatType; Height, XPan, YPan : integer) : TScreenPoint;
begin
  Result.X := SizeRatio*P.X;
  Result.P.X := Round(SizeRatio*P.Y) + XPan;                   
  Result.P.Y := Height-(Round(SizeRatio*P.Z) + YPan);
end;  { ScreenPoint }

function Triangle(XP1,YP1,ZP1,XP2,YP2,ZP2,XP3,YP3,ZP3 : TFloatType) : TTriangle;
begin
  Result[1] := Point3D(XP1,YP1,ZP1);
  Result[2] := Point3D(XP2,YP2,ZP2);
  Result[3] := Point3D(XP3,YP3,ZP3);
end;  { Triangle }

function Triangle(P1, P2, P3 : T3DPoint) : TTriangle;
begin
  Result[1] := P1;  Result[2] := P2;  Result[3] := P3;
end;  { Triangle }

function Triangle(XP1,YP1,XP2,YP2,XP3,YP3 : TFloatType) : TTriangle2D;
begin
  Result[1] := Point2D(XP1,YP1);
  Result[2] := Point2D(XP2,YP2);
  Result[3] := Point2D(XP3,YP3);
end;  { Triangle }

function Triangle(P1, P2, P3 : T2DPoint) : TTriangle2D;
begin
  Result[1] := P1;  Result[2] := P2;  Result[3] := P3;
end;  { Triangle }

function TriangleXY(T : TTriangle) : TTriangle2D;
begin    { Projects a 3D triangle on the XY plan }
  Result[1].X := T[1].X;  Result[1].Y := T[1].Y;
  Result[2].X := T[2].X;  Result[2].Y := T[2].Y;
  Result[3].X := T[3].X;  Result[3].Y := T[3].Y;
end;  { TriangleXY }

function TriangleXZ(T : TTriangle) : TTriangle2D;
begin    { Projects a 3D triangle on the XZ plan }
  Result[1].X := T[1].X;  Result[1].Y := T[1].Z;
  Result[2].X := T[2].X;  Result[2].Y := T[2].Z;
  Result[3].X := T[3].X;  Result[3].Y := T[3].Z;
end;  { TriangleXZ }

function TriangleYZ(T : TTriangle) : TTriangle2D;
begin    { Projects a 3D triangle on the YZ plan }
  Result[1].X := T[1].Y;  Result[1].Y := T[1].Z;
  Result[2].X := T[2].Y;  Result[2].Y := T[2].Z;
  Result[3].X := T[3].Y;  Result[3].Y := T[3].Z;
end;  { TriangleYZ }

function RectToPoints(Rect : TRect) : TRectPoints;
begin
  Result[1] := Point(Rect.Left,Rect.Bottom);
  Result[2] := Rect.BottomRight;
  Result[3] := Point(Rect.Right,Rect.Top);
  Result[4] := Rect.TopLeft;
end;  { RectToPoints }

function PointToVector(P : T3DPoint) : TVetor3x1;
begin
  Result[1] := P.X;  Result[2] := P.Y;  Result[3] := P.Z;
end;  { PointToVector }

function VectorToPoint(P : TVetor3x1) : T3DPoint;
begin
  Result.X := P[1];  Result.Y := P[2];  Result.Z := P[3];
end;  { VectorToPoint }

function SumPoint3D(Series : TVetor3DPoint) : T3DPoint;
var
  i : integer;
begin
  Result.X := 0;  Result.Y := 0;  Result.Z := 0;
  for i := Low(Series) to High(Series) do
  begin
    Result.X := Result.X + Series[i].X;
    Result.Y := Result.Y + Series[i].Y;
    Result.Z := Result.Z + Series[i].Z;
  end;
end;  { SumPoint3D }

function SumPoint3D(A, B : T3DPoint) : T3DPoint;
begin
  Result.X := A.X + B.X;
  Result.Y := A.Y + B.Y;
  Result.Z := A.Z + B.Z;
end;  { SumPoint3D }

function SubtractPoint3D(A, B : T3DPoint) : T3DPoint;
begin
  Result.X := A.X - B.X;
  Result.Y := A.Y - B.Y;
  Result.Z := A.Z - B.Z;
end;  { SubtractPoint3D }

function FactorPoint3D(Point : T3DPoint; const Series : array of TFloatType) : T3DPoint;
var
  i : integer;
begin
  Result.X := Point.X;  Result.Y := Point.Y;  Result.Z := Point.Z;
  for i := Low(Series) to High(Series) do
  begin
    Result.X := Series[i]*Result.X;
    Result.Y := Series[i]*Result.Y;
    Result.Z := Series[i]*Result.Z;
  end;
end;  { FactorPoint3D }

procedure FactorPoint3D(Ratio : TFloatType; var Point : T3DPoint);
begin
  Point.X := Ratio*Point.X;
  Point.Y := Ratio*Point.Y;
  Point.Z := Ratio*Point.Z;
end;  { FactorPoint3D }

procedure FactorPoint3D(Ratio : TFloatType; var X, Y, Z : TFloatType);
begin
  X := Ratio*X;
  Y := Ratio*Y;
  Z := Ratio*Z;
end;  { FactorPoint3D }

procedure StretchPoint3D(Ratio : TFloatType; Ref : T3DPoint; var Point : T3DPoint);
begin
  If (Ratio <> 0) and (EqualPoints(Ref,Point) = False) then
  begin
    Point.X := ((Point.X - Ref.X)*Ratio) + Ref.X;
    Point.Y := ((Point.Y - Ref.Y)*Ratio) + Ref.Y;
    Point.Z := ((Point.Z - Ref.Z)*Ratio) + Ref.Z;
  end;
end;  { StretchPoint3D }

function PolySetToWire(N : integer; PSet : TPolySet) : TWire;
begin
  Result.N := N; Result.P := PSet;
end;  { PolySetToWire }

function EqualPoints(A, B : T2DPoint) : boolean;
begin
  Result := False;
  If (Equal(A.X,B.X,RelPrecision)) and
     (Equal(A.Y,B.Y,RelPrecision)) then
    Result := True;
end;  { EqualPoints }

function EqualPoints(AX,AY,BX,BY : TFloatType) : boolean;
begin
  Result := False;
  If (Equal(AX,BX,RelPrecision)) and
     (Equal(AY,BY,RelPrecision)) then
    Result := True;
end;  { EqualPoints }

function EqualPoints(A, B : T3DPoint) : boolean;
begin
  Result := False;
  If (Equal(A.X,B.X,RelPrecision)) and
     (Equal(A.Y,B.Y,RelPrecision)) and
     (Equal(A.Z,B.Z,RelPrecision)) then
    Result := True;
end;  { EqualPoints }

function EqualPoints(AX,AY,AZ,BX,BY,BZ : TFloatType) : boolean;
begin
  Result := False;
  If (Equal(AX,BX,RelPrecision)) and
     (Equal(AY,BY,RelPrecision)) and
     (Equal(AZ,BZ,RelPrecision)) then
    Result := True;
end;  { EqualPoints }

function EqualPointsR(A, B : T2DPoint) : boolean;
begin
  Result := False;
  If (A.X = B.X) and
     (A.Y = B.Y) then
    Result := True;
end;  { EqualPointsR }

function EqualPointsR(A, B : T3DPoint) : boolean;
begin
  Result := False;
  If (A.X = B.X) and
     (A.Y = B.Y) and
     (A.Z = B.Z) then
    Result := True;
end;  { EqualPointsR }

function EqualTriangle(A, B : TTriangle) : boolean;
begin
  Result := False;
  If (EqualPoints(A[1],B[1])) and
     (EqualPoints(A[2],B[2])) and
     (EqualPoints(A[3],B[3])) then
    Result := True;
end;  { EqualTriangles }

function EqualVectors(N1, N2 : integer; V1, V2 : TVetorN) : boolean;
var
  i, j : integer;
begin
  Result := False;
  If N1 = N2 then
  begin
    Result := True;
    i := 0;
    repeat
    begin
      i := i + 1;
      Result := Equal(V1[i],V2[i],RelPrecision);
    end;
    until((i = N1) or (Result = False));
  end;
end;  { EqualVectors }

function Dist_Points(X1,Y1,X2,Y2 : TFloatType) : TFloatType;
begin    { Calcula distância entre pontos (X1,Y1,Z1) e (X2,Y2,Z2) }
  Result := sqrt(sqr(X2-X1)+sqr(Y2-Y1));
end;  { Dist_Points }

function Dist_Points(X1,Y1,Z1,X2,Y2,Z2 : TFloatType) : TFloatType;
begin    { Calcula distância entre pontos (X1,Y1,Z1) e (X2,Y2,Z2) }
  Result := sqrt(sqr(X2-X1)+sqr(Y2-Y1)+sqr(Z2-Z1));
end;  { Dist_Points }

function Dist_Points(P1, P2 : T2DPoint) : TFloatType;
begin    { Calcula distância entre pontos P1 e P2 }
  Result := sqrt(sqr(P2.X-P1.X)+sqr(P2.Y-P1.Y));
end;  { Dist_Points }

function Dist_Points(P1, P2 : T3DPoint) : TFloatType;
begin    { Calcula distância entre pontos P1 e P2 }
  Result := sqrt(sqr(P2.X-P1.X)+sqr(P2.Y-P1.Y)+sqr(P2.Z-P1.Z));
end;  { Dist_Points }

function DistSQR_Points(X1,Y1,Z1,X2,Y2,Z2 : TFloatType) : TFloatType;
begin    { Calcula distância entre pontos (X1,Y1,Z1) e (X2,Y2,Z2) }
  Result := sqr(X2-X1)+sqr(Y2-Y1)+sqr(Z2-Z1);
end;  { DistSQR_Points }

function DistSQR_Points(P1, P2 : T3DPoint) : TFloatType;
begin    { Calcula distância ao quadrado entre pontos P1 e P2 }
  Result := sqr(P2.X-P1.X)+sqr(P2.Y-P1.Y)+sqr(P2.Z-P1.Z);
end;  { DistSQR_Points }

function Dist_PointToLine(X,Y,X1,Y1,X2,Y2 : TFloatType) : TFloatType;
var
  a,b,c : TFloatType;  r : T3DPoint;  V : TVetor3DPoint;
begin
  a := X2-X1;  b := Y2-Y1; c := (X2*Y1)-(X1*Y2);
  If Unequal(sqr(a)+sqr(b),0,RelPrecision) then
    Result := ABS(a*X-b*Y+c)/sqrt(sqr(a)+sqr(b))
  Else Result := Dist_Points(X,Y,0,X1,Y1,0);
end;  { Dist_PointToLine }

function Dist_PointToLine(X,Y,Z,X1,Y1,Z1,X2,Y2,Z2 : TFloatType) : TFloatType;
var
  a : array[1..6]of TFloatType;
  r : T3DPoint;  V : TVetor3DPoint;
begin
  a[1] := (X-X1)*(Y2-Y1);  a[2] := (Y-Y1)*(X2-X1);
  a[3] := (Y-Y1)*(Z2-Z1);  a[4] := (Z-Z1)*(Y2-Y1);
  a[5] := (X-X1)*(Z2-Z1);  a[6] := (Z-Z1)*(X2-X1);
  If (Equal(a[1],a[2],RelPrecision)) and (Equal(a[3],a[4],RelPrecision)) and
     (Equal(a[5],a[6],RelPrecision)) then
  begin
    Result := 0;
  end
  Else begin
    SetLength(V,2);
    { V[0] = (X1-X,Y1-Y,Z1-Z) }
    V[0] := Point3D(X1-X,Y1-Y,Z1-Z);
    { r = unitario(X2-X1,Y2-Y1,Z2-Z1) }
    VetorUnitario(X2-X1,Y2-Y1,Z2-Z1,r.X,r.Y,r.Z);
    { V[1] = -r*(V[0].r) }
    V[1] := FactorPoint3D(r,[-ProdutoEscalar(V[0],r)]);
    Result := Hypot3D(SumPoint3D(V));
  end;
end;  { Dist_PointToLine }

function Dist_PointToLine(P,P1,P2 : T3DPoint) : TFloatType;
var
  a : array[1..6]of TFloatType;
  r : T3DPoint;  V : TVetor3DPoint;
begin
  a[1] := (P.X-P1.X)*(P2.Y-P1.Y);  a[2] := (P.Y-P1.Y)*(P2.X-P1.X);
  a[3] := (P.Y-P1.Y)*(P2.Z-P1.Z);  a[4] := (P.Z-P1.Z)*(P2.Y-P1.Y);
  a[5] := (P.X-P1.X)*(P2.Z-P1.Z);  a[6] := (P.Z-P1.Z)*(P2.X-P1.X);
  If (Equal(a[1],a[2],RelPrecision)) and (Equal(a[3],a[4],RelPrecision)) and
     (Equal(a[5],a[6],RelPrecision)) then
  begin
    Result := 0;
  end
  Else begin
    SetLength(V,2);
    { V[0] = (P1-P) }
    V[0] := Point3D(P1.X-P.X,P1.Y-P.Y,P1.Z-P.Z);
    { r = unitario(P2-P1) }
    VetorUnitario(P2.X-P1.X,P2.Y-P1.Y,P2.Z-P1.Z,r.X,r.Y,r.Z);
    { V[1] = -r*(V[0].r) }
    V[1] := FactorPoint3D(r,[-ProdutoEscalar(V[0],r)]);
    Result := Hypot3D(SumPoint3D(V));
  end;
end;  { Dist_PointToLine }

function Dist_PointToLineR(X,Y,Z,X1,Y1,Z1,X2,Y2,Z2 : TFloatType) : TFloatType;
var
  a : array[1..6]of TFloatType;
  r : T3DPoint;  V : TVetor3DPoint;
begin
  a[1] := (X-X1)*(Y2-Y1);  a[2] := (Y-Y1)*(X2-X1);
  a[3] := (Y-Y1)*(Z2-Z1);  a[4] := (Z-Z1)*(Y2-Y1);
  a[5] := (X-X1)*(Z2-Z1);  a[6] := (Z-Z1)*(X2-X1);
  If (a[1] = a[2]) and (a[3] = a[4]) and (a[5] = a[6]) then
  begin
    Result := 0;
  end
  Else begin
    SetLength(V,2);
    { V[0] = (X1-X,Y1-Y,Z1-Z) }
    V[0] := Point3D(X1-X,Y1-Y,Z1-Z);
    { r = unitario(X2-X1,Y2-Y1,Z2-Z1) }
    VetorUnitario(X2-X1,Y2-Y1,Z2-Z1,r.X,r.Y,r.Z);
    { V[1] = -r*(V[0].r) }
    V[1] := FactorPoint3D(r,[-ProdutoEscalar(V[0],r)]);
    Result := Hypot3D(SumPoint3D(V));
  end;
end;  { Dist_PointToLineR }

function Dist_PointToPlan(X,Y,Z : TFloatType; X1,Y1,Z1,XN,YN,ZN : TFloatType) : TFloatType;
begin
  VetorUnitario(XN,YN,ZN,XN,YN,ZN);
  Result := ProdutoEscalar(X-X1,Y-Y1,Z-Z1,XN,YN,ZN);
end;  { Dist_PointToPlan }

function Dist_PointToPlan(X,Y,Z : TFloatType; P : TPlan) : TFloatType;
begin
  VetorUnitario(P.XN,P.YN,P.ZN,P.XN,P.YN,P.ZN);
  Result := ProdutoEscalar(X-P.X1,Y-P.Y1,Z-P.Z1,P.XN,P.YN,P.ZN);
end;  { Dist_PointToPlan }

procedure Projection_PointToPlan(X,Y,Z : TFloatType; X1,Y1,Z1,XN,YN,ZN : TFloatType;
                                 var XR,YR,ZR : TFloatType);
var
  R : TFloatType;
begin
  { Computes distance from point to plan }
  VetorUnitario(XN,YN,ZN,XN,YN,ZN);
  R := ProdutoEscalar(X-X1,Y-Y1,Z-Z1,XN,YN,ZN);
  { Projects the point on the plan }
  XR := X - (R*XN);
  YR := Y - (R*YN);
  ZR := Z - (R*ZN);
end;  { Projection_PointToPlan }

procedure Projection_PointToPlan(X,Y,Z : TFloatType; Plan : TPlan; var XR,YR,ZR : TFloatType);
var
  R : TFloatType;
begin
  { Computes distance from point to plan }
  VetorUnitario(Plan.XN,Plan.YN,Plan.ZN,Plan.XN,Plan.YN,Plan.ZN);
  R := ProdutoEscalar(X-Plan.X1,Y-Plan.Y1,Z-Plan.Z1,Plan.XN,Plan.YN,Plan.ZN);
  { Projects the point on the plan }
  XR := X - (R*Plan.XN);
  YR := Y - (R*Plan.YN);
  ZR := Z - (R*Plan.ZN);
end;  { Projection_PointToPlan }

function Projection_PointToPlan(P : T3DPoint; Plan : TPlan) : T3DPoint;
var
  R : TFloatType;
begin
  { Computes distance from point to plan }
  VetorUnitario(Plan.XN,Plan.YN,Plan.ZN,Plan.XN,Plan.YN,Plan.ZN);
  R := ProdutoEscalar(P.X-Plan.X1,P.Y-Plan.Y1,P.Z-Plan.Z1,Plan.XN,Plan.YN,Plan.ZN);
  { Projects the point on the plan }
  Result.X := P.X - (R*Plan.XN);
  Result.Y := P.Y - (R*Plan.YN);
  Result.Z := P.Z - (R*Plan.ZN);
end;  { Projection_PointToPlan }

function Dist_PointToTriangle(X,Y,Z : TFloatType; X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3 : TFloatType) : TFloatType;
var
  A, B, C : TFloatType;
begin
  { Vetor Normal do Plano }
  ProdutoVetorial(X3-X1,Y3-Y1,Z3-Z1,X2-X1,Y2-Y1,Z2-Z1,A,B,C);
  VetorUnitario(A,B,C,A,B,C);
  Result := ProdutoEscalar(X-X1,Y-Y1,Z-Z1,A,B,C);
end;  { Dist_PointToPlan }

function Plan_Possible(X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3 : TFloatType) : boolean;
var
  XV,YV,ZV : TFloatType;
begin
  Result := True;

  ProdutoVetorial(X3-X1,Y3-Y1,Z3-Z1,X2-X1,Y2-Y1,Z2-Z1,XV,YV,ZV);
  If EqualPoints(Point3D(XV,YV,ZV),Point3D(0,0,0)) then
    Result := False;
  If (EqualPoints(Point3D(X1,Y1,Z1),Point3D(X2,Y2,Z2))) and
     (EqualPoints(Point3D(X2,Y2,Z2),Point3D(X3,Y3,Z3))) then
    Result := False;
end;  { Plan_Possible }

function Plan3D(X1,Y1,Z1,XN,YN,ZN : TFloatType) : TPlan;
begin
  Result.X1 := X1;  Result.Y1 := Y1;  Result.Z1 := Z1;
  Result.XN := XN;  Result.YN := YN;  Result.ZN := ZN;
end;  { Plan3D }

function PlanOpposite(P : TPlan) : TPlan;
begin
  Result.X1 := P.X1;   Result.Y1 := P.Y1;   Result.Z1 := P.Z1;
  Result.XN := -P.XN;  Result.YN := -P.YN;  Result.ZN := -P.ZN;
end;  { PlanOpposite }

function Volume_Pyramid(XV,YV,ZV,X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3 : TFloatType) : TFloatType;
var
  X_B,Y_B,Z_B : array[1..3] of TFloatType;
  Area : TFloatType;
begin
  If Plan_Possible(X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3) then
  begin
    Change_Base_Plan(X1,Y1,Z1, X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3, X_B[1],Y_B[1],Z_B[1]);
    Change_Base_Plan(X2,Y2,Z2, X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3, X_B[2],Y_B[2],Z_B[2]);
    Change_Base_Plan(X3,Y3,Z3, X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3, X_B[3],Y_B[3],Z_B[3]);
  end
  Else
  begin
    X_B[1] := 0;  Y_B[1] := 0;  Z_B[1] := 0;
    X_B[2] := 0;  Y_B[2] := 0;  Z_B[2] := 0;
    X_B[3] := 0;  Y_B[3] := 0;  Z_B[3] := 0;
  end;

  Area := (1/2)*ProdutoVetorial2D(X_B[3]-X_B[1],Y_B[3]-Y_B[1],X_B[2]-X_B[1],Y_B[2]-Y_B[1]);
  Result := Dist_PointToTriangle(XV,YV,ZV,X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3)*Area/3;
end;  { Volume_Pyramid }

procedure VetorUnitario(X,Y,Z : TFloatType; var XResult,YResult,ZResult : TFloatType);
begin
  If (X = 0) and (Y = 0) and (Z = 0) then
  begin
    XResult := 0;  YResult := 0;  ZResult := 0;
  end
  Else
  begin
    XResult := X/Hypot3D(X,Y,Z);  YResult := Y/Hypot3D(X,Y,Z);
    ZResult := Z/Hypot3D(X,Y,Z);
  end;
end;  { VetorUnitario }

function VetorUnitario(P : TVetor3x1) : TVetor3x1;
begin
  If (P[1] = 0) and (P[2] = 0) and (P[3] = 0) then
  begin
    Result[1] := 0;  Result[2] := 0;  Result[3] := 0;
  end
  Else
  begin
    Result[1] := P[1]/Hypot3D(P);  Result[2] := P[2]/Hypot3D(P);
    Result[3] := P[3]/Hypot3D(P);
  end;
end;  { VetorUnitario }

function VetorUnitario(P : T3DPoint) : T3DPoint;
begin
  If (P.X = 0) and (P.Y = 0) and (P.Z = 0) then
  begin
    Result.X := 0;  Result.Y := 0;  Result.Z := 0;
  end
  Else
  begin
    Result.X := P.X/Hypot3D(P);  Result.Y := P.Y/Hypot3D(P);
    Result.Z := P.Z/Hypot3D(P);
  end;
end;  { VetorUnitario }

procedure Change_Base(X,Y,Z : TFloatType; Xo,Yo,Zo,Xx,Xy,Xz,Yx,Yy,Yz,Zx,Zy,Zz : TFloatType;
                      var XResult,YResult,ZResult : TFloatType);
var                             { Muda a origem para (Xo,Yo,Zo) e muda a base para }
  Matriz : TMatriz3x3;          { ((Xx,Xy,Xz),(Yx,Yy,Yz),(Zx,Zy,Zz)) }
  Vetor, Vetor1 : TVetor3x1;
begin
  X := X - Xo;  Y := Y - Yo;  Z := Z - Zo;

  Matriz[1,1] := Xx;  Matriz[1,2] := Yx;  Matriz[1,3] := Zx;
  Matriz[2,1] := Xy;  Matriz[2,2] := Yy;  Matriz[2,3] := Zy;
  Matriz[3,1] := Xz;  Matriz[3,2] := Yz;  Matriz[3,3] := Zz;
  If MInvertivel3x3(Matriz) then         { Matriz Invertível }
  begin
    Vetor[1] := X;  Vetor[2] := Y;  Vetor[3] := Z;
    Vetor1 := ProdutoMatrizVetor(MatrizInversa3x3(Matriz),Vetor);
    XResult := Vetor1[1];  YResult := Vetor1[2];  ZResult := Vetor1[3];
  end
  Else If MInvertivel3x3(Matriz) = False then   { Matriz Não Invertível }
  begin
    XResult := 0;  YResult := 0;  ZResult := 0;
  end;
end;  { Change_Base }

procedure Plan_BaseAxis(P : TPlan; X,Y,Z : TFloatType; var X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3 : TFloatType);
begin             { Gera três eixos unitários ortonormais a partir da normal ao plano }
                  { e do vetor de referência (X,Y,Z) }
  { Z = (X3,Y3,Z3) }
  VetorUnitario(P.XN,P.YN,P.ZN,X3,Y3,Z3);
  { X = (X1,Y1,Z1) }
  VetorUnitario(X,Y,Z,X1,Y1,Z1);
  { Y = (X2,Y2,Z2) }
  ProdutoVetorial(X3,Y3,Z3,X1,Y1,Z1,X2,Y2,Z2);
end;  { Plan_BaseAxis }

function Plan_BaseAxis(P : TPlan; X,Y,Z : TFloatType) : TMatriz3x3;
begin             { Gera três eixos unitários ortonormais a partir da normal ao plano }
                  { e do vetor de referência (X,Y,Z) }
  { Z = (X3,Y3,Z3) }
  VetorUnitario(P.XN,P.YN,P.ZN,Result[3,1],Result[3,2],Result[3,3]);
  { X = (X1,Y1,Z1) }
  VetorUnitario(X,Y,Z,Result[1,1],Result[1,2],Result[1,3]);
  { Y = (X2,Y2,Z2) }
  ProdutoVetorial(Result[3,1],Result[3,2],Result[3,3],
                  Result[1,1],Result[1,2],Result[1,3],
                  Result[2,1],Result[2,2],Result[2,3]);
end;  { Plan_BaseAxis }

procedure Change_Base_Plan(X,Y,Z, X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3 : TFloatType;
                           var XResult,YResult,ZResult : TFloatType);
var
  Xx,Xy,Xz : TFloatType;
  Yx,Yy,Yz : TFloatType;
  Zx,Zy,Zz : TFloatType;
begin
  { Vetor Base X^ = (Xx,Xy,Xz) }
  VetorUnitario(X3-X1,Y3-Y1,Z3-Z1,Xx,Xy,Xz);

  { Vetor Base Z^ = (Zx,Zy,Zz) }
  ProdutoVetorial(Xx,Xy,Xz,X2-X1,Y2-Y1,Z2-Z1,Zx,Zy,Zz);
  VetorUnitario(Zx,Zy,Zz,Zx,Zy,Zz);

  { Vetor Base Y^ = (Yx,Yy,Yz) }
  ProdutoVetorial(Zx,Zy,Zz,Xx,Xy,Xz,Yx,Yy,Yz);
  VetorUnitario(Yx,Yy,Yz,Yx,Yy,Yz);

  Change_Base_Orthonormal(X,Y,Z,X1,Y1,Z1,Xx,Xy,Xz,Yx,Yy,Yz,Zx,Zy,Zz,XResult,YResult,ZResult);
end;  { Change_Base_Plan }

procedure Change_Base_Plan(X, Y, Z : TFloatType; T : TTriangle; var XResult,YResult,ZResult : TFloatType);
var
  Xx,Xy,Xz : TFloatType;
  Yx,Yy,Yz : TFloatType;
  Zx,Zy,Zz : TFloatType;
begin
  { Vetor Base X^ = (Xx,Xy,Xz) }
  VetorUnitario(T[3].X-T[1].X,T[3].Y-T[1].Y,T[3].Z-T[1].Z,Xx,Xy,Xz);

  { Vetor Base Z^ = (Zx,Zy,Zz) }
  ProdutoVetorial(Xx,Xy,Xz,T[2].X-T[1].X,T[2].Y-T[1].Y,T[2].Z-T[1].Z,Zx,Zy,Zz);
  VetorUnitario(Zx,Zy,Zz,Zx,Zy,Zz);

  { Vetor Base Y^ = (Yx,Yy,Yz) }
  ProdutoVetorial(Zx,Zy,Zz,Xx,Xy,Xz,Yx,Yy,Yz);
  VetorUnitario(Yx,Yy,Yz,Yx,Yy,Yz);

  Change_Base_Orthonormal(X,Y,Z,T[1].X,T[1].Y,T[1].Z,Xx,Xy,Xz,Yx,Yy,Yz,Zx,Zy,Zz,XResult,YResult,ZResult);
end;  { Change_Base_Plan }

procedure Change_Base_Plan(X, Y, Z : TFloatType; P : TPlan; XRef,YRef,ZRef : TFloatType;
                           var XResult,YResult,ZResult : TFloatType);
var
  Xx,Xy,Xz : TFloatType;
  Yx,Yy,Yz : TFloatType;
  Zx,Zy,Zz : TFloatType;
begin
  { Base P }
  Plan_BaseAxis(P,XRef,YRef,ZRef,Xx,Xy,Xz,Yx,Yy,Yz,Zx,Zy,Zz);

  Change_Base_Orthonormal(X,Y,Z,P.X1,P.Y1,P.Z1,Xx,Xy,Xz,Yx,Yy,Yz,Zx,Zy,Zz,XResult,YResult,ZResult);
end;  { Change_Base_Plan }

procedure Change_Base_Orthonormal(X,Y,Z,Xo,Yo,Zo,Xx,Xy,Xz,Yx,Yy,Yz,Zx,Zy,Zz : TFloatType;
                                  var XResult,YResult,ZResult : TFloatType);
var                        { Changes origin of (X,Y,Z) to (Xo,Yo,Zo) and its  }
  Vetor : TVetor3x1;       { base to [(Xx,Xy,Xz),(Yx,Yy,Yz),(Zx,Zy,Zz)] }
  Matriz : TMatriz3x3;
begin
  Matriz := OrthonormalBase(Xx,Xy,Xz,Yx,Yy,Yz,Zx,Zy,Zz);
  Vetor := Vetor3x1(X-Xo,Y-Yo,Z-Zo);
  Vetor := ProdutoMatrizVetor(Matriz,Vetor);
  XResult := Vetor[1];  YResult := Vetor[2];  ZResult := Vetor[3];
end;  { Change_Base_Orthonormal }

function OrthonormalBase(Xx,Xy,Xz,Yx,Yy,Yz,Zx,Zy,Zz : TFloatType) : TMatriz3x3;
begin    { X = (Xx,Xy,Xz) Y = (Yx,Yy,Yz) Z = (Zx,Zy,Zz) must be orthonormal vectors }
  { X^ = (Xx,Xy,Xz) }
  VetorUnitario(Xx,Xy,Xz,Result[1,1],Result[1,2],Result[1,3]);

  { Y^ = (Yx,Yy,Yz) }
  VetorUnitario(Yx,Yy,Yz,Result[2,1],Result[2,2],Result[2,3]);

  { Z^ = (Zx,Zy,Zz) }
  VetorUnitario(Zx,Zy,Zz,Result[3,1],Result[3,2],Result[3,3]);
end;  { OrthonormalBase }

function OrthonormalBaseTriangle(T : TTriangle) : TMatriz3x3;
var                   { Finds X = (Xx,Xy,Xz) Y = (Yx,Yy,Yz) Z = (Zx,Zy,Zz) orthonormal }
  Xx,Xy,Xz : TFloatType;    { vectors and builds a orthonormal base from these vectors }
  Yx,Yy,Yz : TFloatType;
  Zx,Zy,Zz : TFloatType;
begin
  { Vetor Base X^ = (Xx,Xy,Xz) }
  VetorUnitario(T[3].X-T[1].X,T[3].Y-T[1].Y,T[3].Z-T[1].Z,Xx,Xy,Xz);

  { Vetor Base Z^ = (Zx,Zy,Zz) }
  ProdutoVetorial(Xx,Xy,Xz,T[2].X-T[1].X,T[2].Y-T[1].Y,T[2].Z-T[1].Z,Zx,Zy,Zz);
  VetorUnitario(Zx,Zy,Zz,Zx,Zy,Zz);

  { Vetor Base Y^ = (Yx,Yy,Yz) }
  ProdutoVetorial(Zx,Zy,Zz,Xx,Xy,Xz,Yx,Yy,Yz);
  VetorUnitario(Yx,Yy,Yz,Yx,Yy,Yz);

  Result := OrthonormalBase(Xx,Xy,Xz,Yx,Yy,Yz,Zx,Zy,Zz);
end;  { OrthonormalBaseTriangle }

function MatrizTrocaLinhas_F(Ndim : integer; L1 : integer; L2 : integer) : TMatrizNxN;
var                              { Gera uma Matriz que, multiplicada por outra, troca suas linhas L1 e L2 }
  i, j : integer;
begin
  MOLIdentidade := SetMatrixDim(MOLIdentidade,Ndim+1);
  Result := SetMatrixDim(Result,Ndim+1);
  for i := 1 to Ndim do
    for j := 1 to Ndim do
    begin
      MOLIdentidade[i,j] := 0;
    end;
  for i := 1 to Ndim do
    MOLIdentidade[i,i] := 1;

  Result := MOLIdentidade;

  If L1 > Ndim then  L1 := Ndim;
  If L2 > Ndim then  L2 := Ndim;
  If L1 < 1 then     L1 := 1;
  If L2 < 1 then     L2 := 1;

  Result[L1,L1] := 0;
  Result[L1,L2] := 1;

  Result[L2,L2] := 0;
  Result[L2,L1] := 1;

end;  { MatrizTrocaLinhas_F }

function MatrizCLinear_F(Ndim : integer; L1 : integer; L2 : integer;
                                                X1 : TFloatType;    X2 : TFloatType) : TMatrizNxN;
var                               { Gera uma Matriz que, multiplicada por outra, executa uma determinada combinação linear }
  i, j : integer;                 { em sua linha L1:     L1 := X1*L1 + X2*L2 }
begin
  MOLIdentidade := SetMatrixDim(MOLIdentidade,Ndim+1);
  Result := SetMatrixDim(Result,Ndim+1);
  for i := 1 to Ndim do
    for j := 1 to Ndim do
    begin
      MOLIdentidade[i,j] := 0;
    end;
  for i := 1 to Ndim do
    MOLIdentidade[i,i] := 1;

  Result := MOLIdentidade;

  If L1 > Ndim then  L1 := Ndim;
  If L2 > Ndim then  L2 := Ndim;
  If L1 < 1 then     L1 := 1;
  If L2 < 1 then     L2 := 1;

  Result[L1,L1] := X1;
  Result[L1,L2] := X2;

end;  { MatrizCLinear_F }

function MTrocaLinhas(Matriz : TMatrizNxN; Ndim : integer; L1 : integer; L2 : integer) : TMatrizNxN;
begin                       { Troca as linhas L1 e L2 de Matriz }

  Result := SetMatrixDim(Result,Ndim+1);
  Result := ProdutoMatrizesN(MatrizTrocaLinhas_F(Ndim,L1,L2),Matriz,Ndim);

end;  { MTrocaLinhas }

function MCLinear(Matriz : TMatrizNxN; Ndim : integer; L1 : integer; L2 : integer;
                                                              X1 : TFloatType;    X2 : TFloatType) : TMatrizNxN;
begin                             { Executa uma determinada combinação linear na linha L1 de Matriz }
                                  { L1 := X1*L1 + X2*L2 }
  Result := SetMatrixDim(Result,Ndim+1);
  Result := ProdutoMatrizesN(MatrizCLinear_F(Ndim,L1,L2,X1,X2),Matriz,Ndim);
end;  { MCLinear }

function ProdutoMatrizes(T : TMatriz3x3; P : TMatriz3x3) : TMatriz3x3;
var
  i,j,k : integer;                 { T:kxj  X  P:jxi }
  soma : TFloatType;
begin
  For k := 1 to 3 do
  Begin
    For i := 1 to 3 do
      begin
        soma := 0;
        For j := 1 to 3 do
          soma := soma + (T[k,j]*P[j,i]);
          Result[k,i] := soma;
      end;
  End;
end;  { ProdutoMatrizes }

function ProdutoMatrizVetor(T : TMatriz3x3; P : TVetor3x1) : TVetor3x1;
var
  j,k : integer;                 { T:kxj  X  P:jx1 }
  soma : TFloatType;
begin
  For k := 1 to 3 do
  Begin
    soma := 0;
    For j := 1 to 3 do
      soma := soma + (T[k,j]*P[j]);
    Result[k] := soma;
  End;
end;  { ProdutoMatrizVetor }

function ProdutoMatrizesN(TN : TMatrizNxN; PN : TMatrizNxN; Ndim : integer) : TMatrizNxN;
var
  i,j,k : integer;                 { TN:kxj  X  PN:jxi }
  soma : TFloatType;
begin
  Result := SetMatrixDim(Result,Ndim+1);
  For k := 1 to Ndim do
  Begin
    For i := 1 to Ndim do
      begin
        soma := 0;
        For j := 1 to Ndim do
          soma := soma + (TN[k,j]*PN[j,i]);
          Result[k,i] := soma;
      end;
  End;
end;  { ProdutoMatrizesN }

function ProdutoMatrizVetorN(T : TMatrizNxN; P : TVetorN; Ndim : integer) : TVetorN;
var
  j,k : integer;                 { T:kxj  X  P:jx1 }
  soma : TFloatType;
begin
  SetLength(Result,Ndim+1);
  For k := 1 to Ndim do
  Begin
    soma := 0;
    For j := 1 to Ndim do
      soma := soma + (T[k,j]*P[j]);
    Result[k] := soma;
  End;
end;  { ProdutoMatrizVetor }

function Array2D_Transpose(N : integer; Np : TVetorIN; Matriz : TMatrizNxN) : TMatrizNxN;
var                   { Transposição do Array bi-dimensional }
  i, j : integer;
begin
  SetLength(Result,N+1);
  for j := 1 to N do
  begin
    SetLength(Result[j],Np[j]+1);
    for i := 1 to Np[j] do
      Result[j,i] := Matriz[i,j];
  end;
end;  { Array2D_Transpose }

procedure AddValue(Index : integer; R : TFloatType; var NR : integer; var PR : TVetorN);
var                    { Acrescenta valor R a frente da posição Index }
  i : integer;
begin
  NR := High(PR);
  SetLength(PR,High(PR)+2);
  If (0<=Index) and (Index<=NR-1) then    { Index E [1,High(PR)-1] }
  begin
    for i := High(PR) downto Index+1 do
      PR[i+1] := PR[i];
    PR[Index+1] := R;
  end
  Else If Index = NR then                 { Index = N }
    PR[Index+1] := R;
  NR := High(PR);
end;  { AddValue }

procedure AddValue(Index : integer; R : integer; var NR : integer; var PR : TVetorIN);
var                    { Acrescenta valor R a frente da posição Index }
  i : integer;
begin
  NR := High(PR);
  SetLength(PR,High(PR)+2);
  If (0<=Index) and (Index<=NR-1) then    { Index E [1,High(PR)-1] }
  begin
    for i := NR downto Index+1 do
      PR[i+1] := PR[i];
    PR[Index+1] := R;
  end
  Else If Index = NR then                 { Index = N }
    PR[Index+1] := R;
  NR := High(PR);
end;  { AddValue }

procedure AddValue(Index : integer; R : TFloatType; var PR : TVetorN);
var                    { Acrescenta valor R a frente da posição Index }
  i, NR : integer;
begin
  NR := High(PR);
  SetLength(PR,High(PR)+2);
  If (0<=Index) and (Index<=NR-1) then    { Index E [1,High(PR)-1] }
  begin
    for i := NR downto Index+1 do
      PR[i+1] := PR[i];
    PR[Index+1] := R;
  end
  Else If Index = NR then                 { Index = N }
    PR[Index+1] := R;
end;  { AddValue }

procedure AddValue(Index : integer; R : integer; var PR : TVetorIN);
var                    { Acrescenta valor R a frente da posição Index }
  i, NR : integer;
begin
  NR := High(PR);
  SetLength(PR,High(PR)+2);
  If (0<=Index) and (Index<=NR-1) then    { Index E [1,High(PR)-1] }
  begin
    for i := NR downto Index+1 do
      PR[i+1] := PR[i];
    PR[Index+1] := R;
  end
  Else If Index = NR then                 { Index = N }
    PR[Index+1] := R;
end;  { AddValue }

procedure AddValue(Index : integer; R : boolean; var NR : integer; var PR : TVetorBN);
var                    { Acrescenta valor R a frente da posição Index }
  i : integer;
begin
  NR := High(PR);
  SetLength(PR,High(PR)+2);
  If (0<=Index) and (Index<=NR-1) then    { Index E [1,High(PR)-1] }
  begin
    for i := High(PR) downto Index+1 do
      PR[i+1] := PR[i];
    PR[Index+1] := R;
  end
  Else If Index = NR then                 { Index = N }
    PR[Index+1] := R;
  NR := High(PR);
end;  { AddValue }

procedure AddNewValue(Index : integer; R : TFloatType; var NR : integer; var PR : TVetorN);
var                    { Acrescenta valor R não repetido a frente da posição Index }
  i : integer;
  repeated : boolean;
begin
  i := 0;  repeated := False;
  repeat
  begin            // Confere se existe algum número igual na lista
    i := i + 1;
    If Equal(R,PR[i],RelPrecision) then
      repeated := True;
  end;
  until((i = NR) or (repeated));

  If repeated = False then     // Se não existir, insere a frente de Index
  begin
    AddValue(Index,R,NR,PR);
  end;
end;  { AddNewValue }

procedure AddNewValue(Index : integer; R : integer; var NR : integer; var PR : TVetorIN);
var                    { Acrescenta valor R não repetido a frente da posição Index }
  i : integer;
  repeated : boolean;
begin
  i := 0;  repeated := False;
  repeat
  begin            // Confere se existe algum número igual na lista
    i := i + 1;
    If R = PR[i] then
      repeated := True;
  end;
  until((i = NR) or (repeated));

  If repeated = False then     // Se não existir, insere a frente de Index
  begin
    AddValue(Index,R,NR,PR);
  end;
end;  { AddNewValue }

function FindValue(N : integer; P : TVetorN; R : TFloatType) : integer;
var                     { Procura o valor R real no vetor P de tamanho N }
  i : integer;          { e informa sua ordem Result no vetor }
begin
  i := 0; Result := 0;
  repeat
  begin
    i := i + 1;
    If Equal(R,P[i],RelPrecision) then
      Result := i;
  end;
  until((i = N) or (Result <> 0));
end;  { FindValue }

function FindValue(N : integer; P : TVetorIN; R : integer) : integer;
var                     { Procura o valor R inteiro no vetor P de tamanho N }
  i : integer;          { e informa sua ordem Result no vetor }
begin
  i := 0; Result := 0;
  repeat
  begin
    i := i + 1;
    If R = P[i] then
      Result := i;
  end;
  until((i = N) or (Result <> 0));
end;  { FindValue }

procedure Clip(N : integer; P : TVetorN; N1, N2 : integer;
               var NR : integer; PR : TVetorN);
var
  i : integer;
begin
  N1 := Min(N1,N2);  N2 := Max(N1,N2);
  If Between(N1,1,N) < 0 then  N1 := 1;
  If Between(N2,1,N) < 0 then  N2 := N;
    
  NR := 0;
  SetLength(PR,N2-N1+2);
  for i := N1 to N2 do
  begin
    NR := NR + 1;
    PR[NR] := P[i];
  end;
end;  { Clip }

procedure AddMinimum(L : TFloatType; N : integer; P : TVetorN;
                     var NR : integer; var PR : TVetorN);
var                  { Limita a lista inferiormente pelo valor L }
  i, j : integer;
begin
  { Adiciona L a lista, caso seja novo }
  AddNewValue(1,L,N,P);
  { Reordena após a inclusão }
  QuickSort(N,P);

  { Recorta a lista desde L em diante }
  i := 0;  j := 0;
  repeat
  begin
    i := i + 1;
    If Greater(P[i],L,RelPrecision) then   { P[i] > L }
      j := i;
  end;
  until((i = N) or (j > 0));
  If j > 1 then
    Clip(N,P,j-1,N,NR,PR)
  Else begin
    NR := N;  PR := P;
  end;
end;  { AddMinimum }

procedure AddMinimum(L : TFloatType; N : integer; P : TVetorN; var NR : integer;
                     var PR : TVetorN; var Index : integer);
var                    { Limita a lista inferiormente pelo valor L }
  i, j : integer;      { Index é a ordem de inserção de L }
begin
  { Adiciona L a lista, caso seja novo }
  j := N;
  AddNewValue(1,L,j,P);
  { Reordena após a inclusão }
  QuickSort(j,P);
  { Índice onde está L }
  If j > N then
    Index := FindValue(j,P,L)
  Else Index := 0;   // L não foi adicionado
  N := j;
  { Recorta a lista desde L em diante }
  i := 0;  j := 0;
  repeat
  begin
    i := i + 1;
    If Greater(P[i],L,RelPrecision) then   { P[i] > L }
      j := i;
  end;
  until((i = N) or (j > 0));
  If j > 1 then
    Clip(N,P,j-1,N,NR,PR)
  Else begin
    NR := N;  PR := P;
  end;
end;  { AddMinimum }

procedure AddMaximum(L : TFloatType; N : integer; P : TVetorN;
                     var NR : integer; var PR : TVetorN);
var                    { Limita a lista superiormente pelo valor L }
  i, j : integer;
begin
  { Adiciona L a lista, caso seja novo }
  AddNewValue(1,L,N,P);
  { Reordena após a inclusão }
  QuickSort(N,P);

  { Recorta a lista de L para baixo }
  i := 0;  j := 0;
  repeat
  begin
    i := i + 1;
    If Greater(P[i],L,RelPrecision) then   { P[i] > L }
      j := i;
  end;
  until((i = N) or (j > 0));
  If j > 1 then
    Clip(N,P,1,j-1,NR,PR)
  Else begin
    NR := N;  PR := P;
  end;
end;  { AddMaximum }

procedure AddMaximum(L : TFloatType; N : integer; P : TVetorN; var NR : integer;
                     var PR : TVetorN; var Index : integer);
var                    { Limita a lista superiormente pelo valor L }
  i, j : integer;      { Index é a ordem de inserção de L }
begin
  { Adiciona L a lista, caso seja novo }
  j := N;
  AddNewValue(1,L,j,P);
  { Reordena após a inclusão }
  QuickSort(j,P);
  { Índice onde está L }
  If j > N then
    Index := FindValue(j,P,L)
  Else Index := 0;   // L não foi adicionado
  N := j;
  { Recorta a lista de L para baixo }
  i := 0;  j := 0;
  repeat
  begin
    i := i + 1;
    If Greater(P[i],L,RelPrecision) then   { P[i] > L }
      j := i;
  end;
  until((i = N) or (j > 0));
  If j > 1 then
    Clip(N,P,1,j-1,NR,PR)
  Else begin
    NR := N;  PR := P;
  end;
end;  { AddMaximum }

function SelectionSort(N : integer; P : TVetorN) : TVetorN;
var                         { A seleção direta é um método de ordenação baseado }
  i, j, min : integer;      { na determinação dos valores mínimos da série e na }
  varaux : TFloatType;            { separação dos mesmos do resto da série. }
begin                       { A ordenação fica em ordem crescente. O(n²) }
  for i := 1 to N-1 do
  begin
    min := i;      { Inicializa a variável que contém o valor mínimo }
    for j := i+1 to N do
      if P[j] < P[min] then
        min := j;    { Localiza valor mínimo da parte não ordenada }

    if i <> min then   { se o valor mínimo não estiver na parte ordenada }
    begin
      varaux := P[i];
      P[i] := P[min];        { Permuta valor mínimo com a primeira }
      P[min] := varaux;      { posição da  parte não ordenada }
    end;
  end;
end;  { SelectionSort }

function SelectionSort(N : integer; P : TDouble) : TDouble;
var                         { A seleção direta é um método de ordenação baseado }
  i, j, min : integer;      { na determinação dos valores mínimos da série e na }
  varaux : double;          { separação dos mesmos do resto da série. O(n²) }
begin                       { A ordenação fica em ordem crescente. }
  for i := 1 to N-1 do
  begin
    min := i;      { Inicializa a variável que contém o valor mínimo }
    for j := i+1 to N do
      if P[j] < P[min] then
        min := j;    { Localiza valor mínimo da parte não ordenada }

    if i <> min then   { se o valor mínimo não estiver na parte ordenada }
    begin
      varaux := P[i];
      P[i] := P[min];        { Permuta valor mínimo com a primeira }
      P[min] := varaux;      { posição da  parte não ordenada }
    end;
  end;
  Result := P;
end;  { SelectionSort }

function SelectionSort(N : integer; P : TVetorIN) : TVetorIN;
var                         { A seleção direta é um método de ordenação baseado }
  i, j, min : integer;      { na determinação dos valores mínimos da série e na }
begin                       { separação dos mesmos do resto da série. O(n²) }
  for i := 1 to N-1 do      { A ordenação fica em ordem crescente. }
  begin
    min := i;      { Inicializa a variável que contém o valor mínimo }
    for j := i+1 to N do
      if P[j] < P[min] then
        min := j;    { Localiza valor mínimo da parte não ordenada }

    if i <> min then   { se o valor mínimo não estiver na parte ordenada }
    begin
      j := P[i];
      P[i] := P[min];   { Permuta valor mínimo com a primeira }
      P[min] := j;      { posição da  parte não ordenada }
    end;
  end;
  Result := P;
end;  { SelectionSort }

function QuickSort(N : integer; P : TVetorN) : TVetorN;
  { O quicksort é um método de ordenação baseado na determinação }
  { recursiva de um pivô e separação da série em listas de }
  { elementos menores que o pivô e maiores que o pivô. O(nlog2n) }
  { A ordenação fica em ordem crescente. }
  procedure Quick_Sort(var A: TVetorN; N1, N2: Integer);
  var
    I, F : integer;
    Piv, T : TFloatType;
  begin
    I := N1;
    F := N2;
    Piv := A[(I + F) div 2];     { pivô inicial }
    repeat
      while A[I] < Piv do        { procura A[I]>=Piv a esquerda de Piv }
        Inc(i);
      while A[F] > Piv do        { procura A[F]<=Piv a direita de Piv }
        Dec(F);
      if I <= F then             { Se F >= I }
      begin
        T := A[I];               { troca A[I] e A[F] de posição }
        A[I] := A[F];
        A[F] := T;
        Inc(I);                  { próxima busca de A[I]>=Piv }
        Dec(F);                  { próxima busca de A[F]<=Piv }
      end;
    until I > F;
    if F > N1 then
      Quick_Sort(A, N1, F);
    if I < N2 then
      Quick_Sort(A, I, N2);
  end;
begin
  Quick_Sort(P, 1, N);
  Result := P;
end;  { QuickSort }

function QuickSort(N : integer; P : TDouble) : TDouble;
  { O quicksort é um método de ordenação baseado na determinação }
  { recursiva de um pivô e separação da série em listas de }
  { elementos menores que o pivô e maiores que o pivô. O(nlog2n) }
  { A ordenação fica em ordem crescente. }
  procedure Quick_Sort(var A: TDouble; N1, N2: Integer);
  var
    I, F : integer;
    Piv, T : double;
  begin
    I := N1;
    F := N2;
    Piv := A[(I + F) div 2];     { pivô inicial }
    repeat
      while A[I] < Piv do        { procura A[I]>=Piv a esquerda de Piv }
        Inc(i);
      while A[F] > Piv do        { procura A[F]<=Piv a direita de Piv }
        Dec(F);
      if I <= F then             { Se F >= I }
      begin
        T := A[I];               { troca A[I] e A[F] de posição }
        A[I] := A[F];
        A[F] := T;
        Inc(I);                  { próxima busca de A[I]>=Piv }
        Dec(F);                  { próxima busca de A[F]<=Piv }
      end;
    until I > F;
    if F > N1 then
      Quick_Sort(A, N1, F);
    if I < N2 then
      Quick_Sort(A, I, N2);
  end;
begin
  Quick_Sort(P, 1, N);
  Result := P;
end;  { QuickSort }

function QuickSort(N : integer; P : TVetorIN) : TVetorIN;
  { O quicksort é um método de ordenação baseado na determinação }
  { recursiva de um pivô e separação da série em listas de }
  { elementos menores que o pivô e maiores que o pivô. O(nlog2n) }
  { A ordenação fica em ordem crescente. }
  procedure Quick_Sort(var A: TVetorIN; N1, N2: Integer);
  var
    I, F : integer;
    Piv, T : integer;
  begin
    I := N1;
    F := N2;
    Piv := A[(I + F) div 2];     { pivô inicial }
    repeat
      while A[I] < Piv do        { procura A[I]>=Piv a esquerda de Piv }
        Inc(i);
      while A[F] > Piv do        { procura A[F]<=Piv a direita de Piv }
        Dec(F);
      if I <= F then             { Se F >= I }
      begin
        T := A[I];               { troca A[I] e A[F] de posição }
        A[I] := A[F];
        A[F] := T;
        Inc(I);                  { próxima busca de A[I]>=Piv }
        Dec(F);                  { próxima busca de A[F]<=Piv }
      end;
    until I > F;
    if F > N1 then
      Quick_Sort(A, N1, F);
    if I < N2 then
      Quick_Sort(A, I, N2);
  end;
begin
  Quick_Sort(P, 1, N);
  Result := P;
end;  { QuickSort }

function QuickSortMap(N : integer; P  : TVetorN; var Key : TVetorIN) : TVetorN;
  { O quicksort é um método de ordenação baseado na determinação }
  { recursiva de um pivô e separação da série em listas de }
  { elementos menores que o pivô e maiores que o pivô. O(nlog2n) }
  { A ordenação fica em ordem crescente. }
  procedure Quick_Sort(var A: TVetorN; var K : TVetorIN; N1, N2: Integer);
  var
    I, F, R : integer;
    Piv, T : TFloatType;
  begin
    I := N1;
    F := N2;
    Piv := A[(I + F) div 2];     { pivô inicial }
    repeat
      while A[I] < Piv do        { procura A[I]>=Piv a esquerda de Piv }
        Inc(i);
      while A[F] > Piv do        { procura A[F]<=Piv a direita de Piv }
        Dec(F);
      if I <= F then             { Se F >= I }
      begin
        T := A[I];               { troca A[I] e A[F] de posição }
        A[I] := A[F];
        A[F] := T;
        R := K[I];
        K[I] := K[F];
        K[F] := R;
        Inc(I);                  { próxima busca de A[I]>=Piv }
        Dec(F);                  { próxima busca de A[F]<=Piv }
      end;
    until I > F;
    if F > N1 then
      Quick_Sort(A, K, N1, F);
    if I < N2 then
      Quick_Sort(A, K, I, N2);
  end;
var
  j : integer;
begin
  SetLength(Key,N+1);
  for j := 1 to N do
    Key[j] := j;
  Quick_Sort(P, Key, 1, N);
  Result := P;
end;  { QuickSortMap }

function QuickSortMap(N : integer; P  : TDouble; var Key : TVetorIN) : TDouble;
  { O quicksort é um método de ordenação baseado na determinação }
  { recursiva de um pivô e separação da série em listas de }
  { elementos menores que o pivô e maiores que o pivô. O(nlog2n) }
  { A ordenação fica em ordem crescente. }
  procedure Quick_Sort(var A: TDouble; var K : TVetorIN; N1, N2: Integer);
  var
    I, F, R : integer;
    Piv, T : double;
  begin
    I := N1;
    F := N2;
    Piv := A[(I + F) div 2];     { pivô inicial }
    repeat
      while A[I] < Piv do        { procura A[I]>=Piv a esquerda de Piv }
        Inc(i);
      while A[F] > Piv do        { procura A[F]<=Piv a direita de Piv }
        Dec(F);
      if I <= F then             { Se F >= I }
      begin
        T := A[I];               { troca A[I] e A[F] de posição }
        A[I] := A[F];
        A[F] := T;
        R := K[I];
        K[I] := K[F];
        K[F] := R;
        Inc(I);                  { próxima busca de A[I]>=Piv }
        Dec(F);                  { próxima busca de A[F]<=Piv }
      end;
    until I > F;
    if F > N1 then
      Quick_Sort(A, K, N1, F);
    if I < N2 then
      Quick_Sort(A, K, I, N2);
  end;
var
  j : integer;
begin
  SetLength(Key,N+1);
  for j := 1 to N do
    Key[j] := j;
  Quick_Sort(P, Key, 1, N);
  Result := P;
end;  { QuickSortMap }

function QuickSortMap(N : integer; P  : TVetorIN; var Key : TVetorIN) : TVetorIN;
  { O quicksort é um método de ordenação baseado na determinação }
  { recursiva de um pivô e separação da série em listas de }
  { elementos menores que o pivô e maiores que o pivô. O(nlog2n) }
  { A ordenação fica em ordem crescente. }
  procedure Quick_Sort(var A: TVetorIN; var K : TVetorIN; N1, N2: Integer);
  var
    I, F, R : integer;
    Piv, T : integer;
  begin
    I := N1;
    F := N2;
    Piv := A[(I + F) div 2];     { pivô inicial }
    repeat
      while A[I] < Piv do        { procura A[I]>=Piv a esquerda de Piv }
        Inc(i);
      while A[F] > Piv do        { procura A[F]<=Piv a direita de Piv }
        Dec(F);
      if I <= F then             { Se F >= I }
      begin
        T := A[I];               { troca A[I] e A[F] de posição }
        A[I] := A[F];
        A[F] := T;
        R := K[I];
        K[I] := K[F];
        K[F] := R;
        Inc(I);                  { próxima busca de A[I]>=Piv }
        Dec(F);                  { próxima busca de A[F]<=Piv }
      end;
    until I > F;
    if F > N1 then
      Quick_Sort(A, K, N1, F);
    if I < N2 then
      Quick_Sort(A, K, I, N2);
  end;
var
  j : integer;
begin
  SetLength(Key,N+1);
  for j := 1 to N do
    Key[j] := j;
  Quick_Sort(P, Key, 1, N);
  Result := P;
end;  { QuickSortMap }

function RefSort(N : integer; P : TVetorN; Key : TVetorIN) : TVetorN;
var                   { Ordena P conforme a lista de referência Key }
  i : integer;
begin
  SetLength(Result,N+1);
  for i := 1 to N do
    Result[i] := P[Key[i]];
end; { RefSort }

function RefSort(N : integer; P : TDouble; Key : TVetorIN) : TDouble;
var                   { Ordena P conforme a lista de referência Key }
  i : integer;
begin
  SetLength(Result,N+1);
  for i := 1 to N do
    Result[i] := P[Key[i]];
end; { RefSort }

function RefSort(N : integer; P : TVetorIN; Key : TVetorIN) : TVetorIN;
var                   { Ordena P conforme a lista de referência Key }
  i : integer;
begin
  SetLength(Result,N+1);
  for i := 1 to N do
    Result[i] := P[Key[i]];
end; { RefSort }

function RefSort(N : integer; P : TMatrizNxN; Key : TVetorIN) : TMatrizNxN;
var                   { Ordena P conforme a lista de referência Key }
  i : integer;
begin
  SetLength(Result,N+1);
  for i := 1 to N do
    Result[i] := P[Key[i]];
end; { RefSort }

function RefSort(N : integer; P : TMatrizN3; Key : TVetorIN) : TMatrizN3;
var                   { Ordena P conforme a lista de referência Key }
  i : integer;
begin
  SetLength(Result,N+1);
  for i := 1 to N do
    Result[i] := P[Key[i]];
end; { RefSort }

function RefSort(N : integer; P : TPointMatrizNxN; Key : TVetorIN) : TPointMatrizNxN;
var                   { Ordena P conforme a lista de referência Key }
  i : integer;
begin
  SetLength(Result,N+1);
  for i := 1 to N do
    Result[i] := P[Key[i]];
end; { RefSort }

function RefSort(N : integer; P : TPolySet; Key : TVetorIN) : TPolySet;
var                   { Ordena P conforme a lista de referência Key }
  i : integer;
begin
  SetLength(Result,N+1);
  for i := 1 to N do
    Result[i] := P[Key[i]];
end; { RefSort }

function RefSort(N : integer; P : TTriangles; Key : TVetorIN) : TTriangles;
var                   { Ordena P conforme a lista de referência Key }
  i : integer;
begin
  SetLength(Result,N+1);
  for i := 1 to N do
    Result[i] := P[Key[i]];
end; { RefSort }

procedure SwapPos(N : integer; var P : TVetorN; N1, N2 : integer);
var
  T : TFloatType;
begin
  If (Between(N1,1,N) >= 0) and (Between(N2,1,N) >= 0) then
  begin
    T := P[N1];
    P[N1] := P[N2];
    P[N2]:= T;
  end;
end; { SwapPos }

procedure SwapPos(N : integer; var P : TMatrizNxN; N1, N2 : integer);
var
  T : TVetorN;
begin
  If (Between(N1,1,N) >= 0) and (Between(N2,1,N) >= 0) then
  begin
    T := P[N1];
    P[N1] := P[N2];
    P[N2]:= T;
  end;
end; { SwapPos }

procedure SwapPos(N : integer; var P : TVetorIN; N1, N2 : integer);
var
  T : integer;
begin
  If (Between(N1,1,N) >= 0) and (Between(N2,1,N) >= 0) then
  begin
    T := P[N1];
    P[N1] := P[N2];
    P[N2]:= T;
  end;
end; { SwapPos }

procedure SwapPos(N : integer; var P : TMatrizINxN; N1, N2 : integer);
var
  T : TVetorIN;
begin
  If (Between(N1,1,N) >= 0) and (Between(N2,1,N) >= 0) then
  begin
    T := P[N1];
    P[N1] := P[N2];
    P[N2]:= T;
  end;
end; { SwapPos }

procedure SwapPos(N : integer; var P : TPolySet; N1, N2 : integer);
var
  T : T3DPline;
begin
  If (Between(N1,1,N) >= 0) and (Between(N2,1,N) >= 0) then
  begin
    T := P[N1];
    P[N1] := P[N2];
    P[N2]:= T;
  end;
end; { SwapPos }

procedure SwapValues(var A, B : integer);
var
  T : integer;
begin
  T := A;
  A := B;
  B := T;
end;  { SwapValues }

procedure SwapValues(var A, B : TFloatType);
var
  T : TFloatType;
begin
  T := A;
  A := B;
  B := T;
end;  { SwapValues }

function InitializeMatrix(Rows, Columns : integer; Value : TFloatType) : TMatrizNxN;
var
  i, j : integer;
begin
  SetLength(Result,Columns+1);
  for i := 0 to Columns do
    SetLength(Result[i],Rows+1);

  for i := 0 to Rows do
    for j := 0 to Columns do
      Result[j,i] := Value;
end;  { InitializeMatrix }

function InitializeMatrix(Rows, Columns : integer; Value : integer) : TMatrizINxN;
var
  i, j : integer;
begin
  SetLength(Result,Columns+1);
  for i := 0 to Columns do
    SetLength(Result[i],Rows+1);

  for i := 0 to Rows do
    for j := 0 to Columns do
      Result[j,i] := Value;
end;  { InitializeMatrix }

function InitializeMatrix(Rows, Columns : integer; Value : boolean) : TMatrizBNxN;
var
  i, j : integer;
begin
  SetLength(Result,Columns+1);
  for i := 0 to Columns do
    SetLength(Result[i],Rows+1);

  for i := 0 to Rows do
    for j := 0 to Columns do
      Result[j,i] := Value;

end;  { InitializeMatrix }

procedure InitializePoint(X, Y, Z : TFloatType; var XResult : TFloatType; var YResult : TFloatType;
                                                var ZResult : TFloatType);

begin
  XResult := X;
  YResult := Y;
  ZResult := Z;
end;  { InitializePoint }

procedure SplineCubico(X : array of TFloatType; t : array of TFloatType; Np : integer; Nintm : integer;
                       var XS : TVetorN; var NpS : integer);
var
  i, j, k : integer;         { t: vetor de parametrização dos nós do Spline Cúbico }
  ht : array of TFloatType;        { ht = t[i+1]-t[i] }
  tS : TVetorN;              { tS: vetor de parametrização de todos os pontos do Spline Cúbico }
  MatrizS : TMatrizNxN;      { MatrizS: matriz que define o sistema linear que permite determinar bS
                                        de nós interiores }
  MatrizSInv : TMatrizNxN;   { Matriz Inversa de MatrizS }
  B_bS : TVetorN;            { Vetor B da equação matricial que define bS em nós interiores: MatrizS*bS = B_bS }
  a_S, bS, cS : TVetorN;     { aS: derivadas primeiras; bS: derivadas segundas; cS: derivadas terceiras
                               do spline cúbico em cada nó fornecido }
begin                        
                            
  SetLength(ht,Np);    { Quantidade de entre espaços dos parâmetros t é igual a Np-1 }
  for i := 1 to Np-1 do
  begin
    ht[i] := t[i+1]-t[i];
  end;
  //ShowMessage('Verificação MatrizS 1');
  MatrizS := SetMatrixdim(MatrizS,Np-1);
  { Construção da Matriz Tridiagonal de coeficientes das Derivadas Segundas dos
    Pontos do Spline Cúbico }
  for i := 1 to Np-4 do
    for j := i+2 to Np-2 do
     MatrizS[i,j] := 0;
  for i := 3 to Np-2 do
    for j := 1 to i-2 do
      MatrizS[i,j] := 0;
  for i := 1 to Np-3 do
  begin
    MatrizS[i,i] := (ht[i]+ht[i+1])/3;
    MatrizS[i+1,i] := ht[i+1]/6;
    MatrizS[i,i+1] := ht[i+1]/6;
  end;
  MatrizS[Np-2,Np-2] := (ht[Np-2]+ht[Np-1])/3;

  SetLength(B_bS,Np-1);
  for i := 1 to Np-2 do
    B_bS[i] := ((X[i]-X[i+1])/ht[i])+((X[i+2]-X[i+1])/ht[i+1]);

  //ShowMessage('Verificação MatrizInv 3');
  MatrizSInv := MatrizInversa(MatrizS,Np-2);

  //ShowMessage('Verificação  bS 4');
  { Derivadas Segundas do Spline Cúbico em cada nó }
  SetLength(bS,Np-1);
  bS := ProdutoMatrizVetorN(MatrizSInv,B_bS,Np-2);

  SetLength(bS,Np+1);
  for i := Np-2 downto 1 do
  begin
    bS[i+1] := bS[i];
  end;

  { Relaxed Cubic Spline - derivadas segundas iguais a zero
    nas extremidades }
  bS[1] := 0;
  bS[Np] := 0;

  //ShowMessage('Verificação a_S 5');
  SetLength(a_S,Np+1);
  { Derivadas Primeiras do Spline Cúbico em cada nó }
  for i := 1 to Np-1 do
    a_S[i] := ((X[i+1]-X[i])/ht[i])-(((2*bS[i])+bS[i+1])*ht[i]/6);
  a_S[Np] := ((X[Np]-X[Np-1])/ht[Np-1])+((bS[Np-1]+(2*bS[Np]))*ht[Np-1]/6);

  //ShowMessage('Verificação  cS 6');
  SetLength(cS,Np+1);
  { Derivadas Terceiras do Spline Cúbico em cada nó }
  for i := 1 to Np-1 do
    cS[i] := (bS[i+1]-bS[i])/ht[i];
  cS[Np] := cS[Np-1];

  //ShowMessage('Verificação tS e XS 7');
  NpS := Np + ((Np-1)*Nintm);
  SetLength(XS,NpS+1);
  SetLength(tS,NpS+1);

  { Aplicação da Equação de cada Polinômio do Terceiro Grau - Série de Taylor }

  {assignfile(Cotas,'EText.txt');
  append(Cotas);
  writeln(Cotas);
  writeln(Cotas,'N'+char(9)+'a_S'+char(9)+'bS'+char(9)+'cS');
  writeln(Cotas);}
  k := 0;
  for i := 1 to Np-1 do
  begin
    for j := 1 to Nintm+1 do
    begin
      k := k + 1;
      tS[k] := t[i]+((j-1)*(t[i+1]-t[i])/(Nintm+1));
      XS[k] := X[i]+(a_S[i]*(ts[k]-t[i]))+((bS[i]/2)*Power(ts[k]-t[i],2))+((cS[i]/6)*Power(ts[k]-t[i],3));
    end;
    {writeln(Cotas,IntToStr(i) + char(9)+FloatToStrF(a_S[i],fffixed,7,3)+char(9)+FloatToStrF(bS[i],fffixed,7,3)+
                                  char(9)+FloatToStrF(cS[i],fffixed,7,3));}
  end;
  tS[NpS] := t[Np];
  XS[NpS] := X[Np];

  {writeln(Cotas,IntToStr(Np) + char(9)+FloatToStrF(a_S[Np],fffixed,7,3)+char(9)+FloatToStrF(bS[Np],fffixed,7,3)+
                               char(9)+FloatToStrF(cS[Np],fffixed,7,3));}

  {closefile(Cotas);}
end;  { SplineCubico }

procedure SplineCubico_Pline(Poly : TPline; Uniform_TF : boolean; var PolyResult : TPline);
var
  i : integer;
  NpolyAux : integer;
  tparam : TVetorN;
  PolyAux : TVetorN;
begin                          
  If Uniform_TF then
  Begin
    NpolyAux := Poly.Npoly;
    { Definição da Dimensão do Vetor de Parametrização (tparam) }
    SetLength(tparam,NpolyAux+1);
    { Definição dos valores do Vetor de Parametrização (tparam) }
    for i:= 1 to NpolyAux do
      tparam[i] := i;

    { Definição da Dimensão do Vetor Polyline Auxiliar (PolyAux) }
    SetLength(PolyAux,NpolyAux+1);

    { Aplicação do Spline Cúbico a Pline_S }

    PolyAux := Poly.X;
    SplineCubico(PolyAux,tparam,NpolyAux,10,PolyResult.X,PolyResult.Npoly);

    PolyAux := Poly.Y;
    SplineCubico(PolyAux,tparam,NpolyAux,10,PolyResult.Y,PolyResult.Npoly);
  End;
end;  { SplineCubico_Pline }

procedure SplineCubicoT(X : array of TFloatType; t : array of TFloatType; Np : integer; Nintm : integer;
                        var XS : TVetorN; var NpS : integer);
var
  i, j, k : integer;         { t: vetor de parametrização dos nós do Spline Cúbico }
  ht : array of TFloatType;        { ht = t[i+1]-t[i] }
  tS : TVetorN;              { tS: vetor de parametrização de todos os pontos do Spline Cúbico }
  MatrizS : TMatrizNxN;      { MatrizS: matriz que define o sistema linear que permite determinar bS
                                        de nós interiores }
  MatrizSInv : TMatrizNxN;   { Matriz Inversa de MatrizS }
  B_bS : TVetorN;            { Vetor B da equação matricial que define bS em nós interiores: MatrizS*bS = B_bS }
  a_S, bS, cS : TVetorN;     { aS: derivadas primeiras; bS: derivadas segundas; cS: derivadas terceiras
                               do spline cúbico em cada nó fornecido }
begin                         

  SetLength(ht,Np);    { Quantidade de entre espaços dos parâmetros t é igual a Np-1 }
  for i := 1 to Np-1 do
  begin
    ht[i] := t[i+1]-t[i];
  end;

  MatrizS := SetMatrixdim(MatrizS,Np+1);
  { Construção da Matriz Tridiagonal de coeficientes das Derivadas Segundas dos
    Pontos do Spline Cúbico }
  for i := 1 to Np-2 do
    for j := i+2 to Np do
      MatrizS[i,j] := 0;
  for i := 3 to Np do
    for j := 1 to i-2 do
      MatrizS[i,j] := 0;

  MatrizS[1,1] := ht[1]/3;
  MatrizS[1,2] := ht[1]/6;
  for i := 2 to Np-1 do
  begin
    MatrizS[i,i] := (ht[i-1]+ht[i])/3;
    MatrizS[i,i-1] := ht[i-1]/6;
    MatrizS[i,i+1] := ht[i]/6;
  end;

  MatrizS[Np,Np-1] := ht[Np-1]/6;
  MatrizS[Np,Np] := ht[Np-1]/3;

  SetLength(a_S,Np+1);

  a_S[1] := (X[2]-X[1])/(t[2]-t[1]);
  a_S[Np] := (X[Np]-X[Np-1])/(t[Np]-t[Np-1]);

  SetLength(B_bS,Np+1);

  B_bS[1] := ((X[2]-X[1])/(t[2]-t[1]))-a_S[1];
  B_bS[Np] := ((X[Np-1]-X[Np])/(t[Np]-t[Np-1]))+a_S[Np];
  for i := 1 to Np-2 do
    B_bS[i+1] := ((X[i]-X[i+1])/ht[i])+((X[i+2]-X[i+1])/ht[i+1]);

  //ShowMessage('Verificação MatrizInv 3');
  MatrizSInv := MatrizInversa(MatrizS,Np);

  //ShowMessage('Verificação  bS 4');
  { Derivadas Segundas do Spline Cúbico em cada nó }
  SetLength(bS,Np+1);
  bS := ProdutoMatrizVetorN(MatrizSInv,B_bS,Np);

  //ShowMessage('Verificação a_S 5');

  { Derivadas Primeiras do Spline Cúbico em cada nó }
  for i := 2 to Np-1 do
    a_S[i] := ((X[i+1]-X[i])/ht[i])-(((2*bS[i])+bS[i+1])*ht[i]/6);
  //a_S[Np] := ((X[Np]-X[Np-1])/ht[Np-1])+((bS[Np-1]+(2*bS[Np]))*ht[Np-1]/6);

  //ShowMessage('Verificação  cS 6');
  SetLength(cS,Np+1);
  { Derivadas Terceiras do Spline Cúbico em cada nó }
  for i := 1 to Np-1 do
    cS[i] := (bS[i+1]-bS[i])/ht[i];
  cS[Np] := cS[Np-1];

  //ShowMessage('Verificação tS e XS 7');
  NpS := Np + ((Np-1)*Nintm);
  SetLength(XS,NpS+1);
  SetLength(tS,NpS+1);

  { Aplicação da Equação de cada Polinômio do Terceiro Grau - Série de Taylor }

  assignfile(Cotas,'EText.txt');
  append(Cotas);
  writeln(Cotas);
  writeln(Cotas,'N'+char(9)+'a_S'+char(9)+'bS'+char(9)+'cS');
  writeln(Cotas);
  k := 0;
  for i := 1 to Np-1 do
  begin
    for j := 1 to Nintm+1 do
    begin
      k := k + 1;
      tS[k] := t[i]+((j-1)*(t[i+1]-t[i])/(Nintm+1));
      XS[k] := X[i]+(a_S[i]*(ts[k]-t[i]))+((bS[i]/2)*Power(ts[k]-t[i],2))+((cS[i]/6)*Power(ts[k]-t[i],3));
    end;
    writeln(Cotas,IntToStr(i) + char(9)+FloatToStrF(a_S[i],fffixed,7,3)+char(9)+FloatToStrF(bS[i],fffixed,7,3)+
                                  char(9)+FloatToStrF(cS[i],fffixed,7,3));
  end;
  tS[NpS] := t[Np];
  XS[NpS] := X[Np];

  writeln(Cotas,IntToStr(Np) + char(9)+FloatToStrF(a_S[Np],fffixed,7,3)+char(9)+FloatToStrF(bS[Np],fffixed,7,3)+
                               char(9)+FloatToStrF(cS[Np],fffixed,7,3));

  closefile(Cotas);
end;  { SplineCubicoT }

procedure SplineCubicoT_Pline(Poly : TPline; Uniform_TF : boolean; dTension : TFloatType; var PolyResult : TPline);
var
  i : integer;
  NpAux : integer;
  tparam : TVetorN;
  PolyAux : TVetorN;
begin                            
  If Uniform_TF then
  Begin
    NpAux := Poly.Npoly;

    { Definição da Dimensão do Vetor Polyline Auxiliar (PolyAux) }
    SetLength(PolyAux,NpAux+3);

    { Definição da Dimensão do Vetor de Parametrização (tparam) }
    SetLength(tparam,NpAux+3);
    { Definição dos valores do Vetor de Parametrização (tparam) }
    for i:= 1 to NpAux+2 do
      tparam[i] := i;

    for i := NpAux+1 downto 2 do
      PolyAux[i] := Poly.X[i-1];
    PolyAux[1] := Poly.X[1]-(dTension*(Poly.X[2]-Poly.X[1])/Hypot(Poly.X[2]-Poly.X[1],Poly.Y[2]-Poly.Y[1]));
    PolyAux[NpAux+2] := Poly.X[NpAux]+(dTension*(Poly.X[NpAux]-Poly.X[NpAux-1])/
                                       Hypot(Poly.X[NpAux]-Poly.X[NpAux-1],Poly.Y[NpAux]-Poly.Y[NpAux-1]));


    { Aplicação do Spline Cúbico com Tensão }
    SplineCubico(PolyAux,tparam,NpAux+2,10,PolyResult.X,PolyResult.Npoly);


    for i := NpAux+1 downto 2 do
      PolyAux[i] := Poly.Y[i-1];
    PolyAux[1] := Poly.Y[1]-(dTension*(Poly.Y[2]-Poly.Y[1])/Hypot(Poly.X[2]-Poly.X[1],Poly.Y[2]-Poly.Y[1]));
    PolyAux[NpAux+2] := Poly.Y[NpAux]+(dTension*(Poly.Y[NpAux]-Poly.Y[NpAux-1])/
                                       Hypot(Poly.X[NpAux]-Poly.X[NpAux-1],Poly.Y[NpAux]-Poly.Y[NpAux-1]));

    { Aplicação do Spline Cúbico com Tensão }
    SplineCubico(PolyAux,tparam,NpAux+2,10,PolyResult.Y,PolyResult.Npoly);
  End;
end;  { SplineCubico_Pline }

function CatmullRomSpline(Poly : TPline; Ts,Ts_1,Ts_N : TFloatType; Nintm : integer) : TPline;
var                                  { Ts = Tension }
  i,j,k : integer;
  MatrizPI,MatrizPE : TMatrizNxN;
  aPI,a_CRx,a_CRy,aPE : TVetorN;
  t_CR : TFloatType;
begin                            
  MatrizPI := SetMatrixDim(MatrizPI,5);
  MatrizPI[1,1] := 1;     MatrizPI[1,2] := 0;         MatrizPI[1,3] := 0;     MatrizPI[1,4] := 0;
  MatrizPI[2,1] := 0;     MatrizPI[2,2] := Ts;        MatrizPI[2,3] := -Ts;   MatrizPI[2,4] := 0;
  MatrizPI[3,1] := Ts-3;  MatrizPI[3,2] := 3-(2*Ts);  MatrizPI[3,3] := 2*Ts;  MatrizPI[3,4] := -Ts;
  MatrizPI[4,1] := 2-Ts;  MatrizPI[4,2] := Ts-2;      MatrizPI[4,3] := -Ts;   MatrizPI[4,4] := Ts;

  SetLength(aPI,5);
  SetLength(a_CRx,5);
  SetLength(a_CRy,5);

  If Poly.Npoly > 2 then
  Begin
    Result.Npoly := Poly.Npoly + ((Poly.Npoly-1)*Nintm);
    SetLength(Result.X,Result.Npoly+1);
    SetLength(Result.Y,Result.Npoly+1);

    MatrizPE := SetMatrixDim(MatrizPE,5);
    SetLength(aPE,5);

    k := 0;   { Contagem do Número de Pontos do Spline }
    { Primeira Extremidade }
    i := 1;
    MatrizPE[1,1] := 1;              MatrizPE[1,2] := 0;           MatrizPE[1,3] := 0;  MatrizPE[1,4] := 0;
    MatrizPE[2,1] := -Ts_1;          MatrizPE[2,2] := Ts_1;        MatrizPE[2,3] := 0;  MatrizPE[2,4] := 0;
    MatrizPE[3,1] := Ts+(2*Ts_1)-3;  MatrizPE[3,2] := 3-(2*Ts_1);  MatrizPE[3,3] := 0;  MatrizPE[3,4] := -Ts;
    MatrizPE[4,1] := 2-Ts-Ts_1;      MatrizPE[4,2] := Ts_1-2;      MatrizPE[4,3] := 0;  MatrizPE[4,4] := Ts;

    aPE[1] := Poly.X[i];  aPE[2] := Poly.X[i+1];  aPE[3] := 0;  aPE[4] := Poly.X[i+2];
    a_CRx := ProdutoMatrizVetorN(MatrizPE,aPE,4);
    aPE[1] := Poly.Y[i];  aPE[2] := Poly.Y[i+1];  aPE[3] := 0;  aPE[4] := Poly.Y[i+2];
    a_CRy := ProdutoMatrizVetorN(MatrizPE,aPE,4);
    for j := 1 to Nintm+1 do
    begin
      k := k + 1;
      t_CR := 0+((j-1)*(1-0)/(Nintm+1));   { <<<<<--------- parametrização }
      Result.X[k] := a_CRx[1]+(a_CRx[2]*t_CR)+(a_CRx[3]*Power(t_CR,2))+(a_CRx[4]*Power(t_CR,3));
      Result.Y[k] := a_CRy[1]+(a_CRy[2]*t_CR)+(a_CRy[3]*Power(t_CR,2))+(a_CRy[4]*Power(t_CR,3));
    end;

    { Polinômios Interiores }
    If Poly.Npoly > 3 then
      for i := 2 to Poly.Npoly-2 do
      begin
        aPI[1] := Poly.X[i];  aPI[2] := Poly.X[i+1];  aPI[3] := Poly.X[i-1];  aPI[4] := Poly.X[i+2];
        a_CRx := ProdutoMatrizVetorN(MatrizPI,aPI,4);
        aPI[1] := Poly.Y[i];  aPI[2] := Poly.Y[i+1];  aPI[3] := Poly.Y[i-1];  aPI[4] := Poly.Y[i+2];
        a_CRy := ProdutoMatrizVetorN(MatrizPI,aPI,4);
        for j := 1 to Nintm+1 do
        begin
          k := k + 1;
          t_CR := 0+((j-1)*(1-0)/(Nintm+1));   { <<<<<--------- parametrização }
          Result.X[k] := a_CRx[1]+(a_CRx[2]*t_CR)+(a_CRx[3]*Power(t_CR,2))+(a_CRx[4]*Power(t_CR,3));
          Result.Y[k] := a_CRy[1]+(a_CRy[2]*t_CR)+(a_CRy[3]*Power(t_CR,2))+(a_CRy[4]*Power(t_CR,3));
        end;
      end;

    { Última Extremidade }
    i := Poly.Npoly-1;
    MatrizPE[1,1] := 1;       MatrizPE[1,2] := 0;              MatrizPE[1,3] := 0;     MatrizPE[1,4] := 0;
    MatrizPE[2,1] := 0;       MatrizPE[2,2] := Ts;             MatrizPE[2,3] := -Ts;   MatrizPE[2,4] := 0;
    MatrizPE[3,1] := Ts_N-3;  MatrizPE[3,2] := 3-(2*Ts)-Ts_N;  MatrizPE[3,3] := 2*Ts;  MatrizPE[3,4] := 0;
    MatrizPE[4,1] := 2-Ts_N;  MatrizPE[4,2] := Ts_N+Ts-2;      MatrizPE[4,3] := -Ts;   MatrizPE[4,4] := 0;

    aPE[1] := Poly.X[i];  aPE[2] := Poly.X[i+1];  aPE[3] := Poly.X[i-1];  aPE[4] := 0;
    a_CRx := ProdutoMatrizVetorN(MatrizPE,aPE,4);
    aPE[1] := Poly.Y[i];  aPE[2] := Poly.Y[i+1];  aPE[3] := Poly.Y[i-1];  aPE[4] := 0;
    a_CRy := ProdutoMatrizVetorN(MatrizPE,aPE,4);
    for j := 1 to Nintm+1 do
    begin
      k := k + 1;
      t_CR := 0+((j-1)*(1-0)/(Nintm+1));   { <<<<<--------- parametrização }
      Result.X[k] := a_CRx[1]+(a_CRx[2]*t_CR)+(a_CRx[3]*Power(t_CR,2))+(a_CRx[4]*Power(t_CR,3));
      Result.Y[k] := a_CRy[1]+(a_CRy[2]*t_CR)+(a_CRy[3]*Power(t_CR,2))+(a_CRy[4]*Power(t_CR,3));
    end;

    Result.X[k+1] := a_CRx[1]+(a_CRx[2]*1)+(a_CRx[3]*Power(1,2))+(a_CRx[4]*Power(1,3));
    Result.Y[k+1] := a_CRy[1]+(a_CRy[2]*1)+(a_CRy[3]*Power(1,2))+(a_CRy[4]*Power(1,3));
  End
  Else If Poly.Npoly <= 2 then
  Begin
    Result.Npoly := Poly.Npoly;
    SetLength(Result.X,Result.Npoly+1);
    SetLength(Result.Y,Result.Npoly+1);
    for k := 1 to Poly.Npoly do
    begin
      Result.X[k] := Poly.X[k];
      Result.Y[k] := Poly.Y[k];
    end;
  End;

end;  { CatmullRomSpline }

function CatmullRomSpline(Poly : TPlineIN; Ts,Ts_1,Ts_N : TFloatType; Nintm : integer) : TPlineIN;
var                                  { Ts = Tension }
  i,j,k : integer;
  MatrizPI,MatrizPE : TMatrizNxN;
  aPI,a_CRx,a_CRy,aPE : TVetorN;
  t_CR : TFloatType;
begin                            
  MatrizPI := SetMatrixDim(MatrizPI,5);
  MatrizPI[1,1] := 1;     MatrizPI[1,2] := 0;         MatrizPI[1,3] := 0;     MatrizPI[1,4] := 0;
  MatrizPI[2,1] := 0;     MatrizPI[2,2] := Ts;        MatrizPI[2,3] := -Ts;   MatrizPI[2,4] := 0;
  MatrizPI[3,1] := Ts-3;  MatrizPI[3,2] := 3-(2*Ts);  MatrizPI[3,3] := 2*Ts;  MatrizPI[3,4] := -Ts;
  MatrizPI[4,1] := 2-Ts;  MatrizPI[4,2] := Ts-2;      MatrizPI[4,3] := -Ts;   MatrizPI[4,4] := Ts;

  SetLength(aPI,5);
  SetLength(a_CRx,5);
  SetLength(a_CRy,5);

  If Poly.Npoly > 2 then
  Begin
    Result.Npoly := Poly.Npoly + ((Poly.Npoly-1)*Nintm);
    SetLength(Result.X,Result.Npoly+1);
    SetLength(Result.Y,Result.Npoly+1);

    MatrizPE := SetMatrixDim(MatrizPE,5);
    SetLength(aPE,5);

    k := 0;   { Contagem do Número de Pontos do Spline }
    { Primeira Extremidade }
    i := 1;
    MatrizPE[1,1] := 1;              MatrizPE[1,2] := 0;           MatrizPE[1,3] := 0;  MatrizPE[1,4] := 0;
    MatrizPE[2,1] := -Ts_1;          MatrizPE[2,2] := Ts_1;        MatrizPE[2,3] := 0;  MatrizPE[2,4] := 0;
    MatrizPE[3,1] := Ts+(2*Ts_1)-3;  MatrizPE[3,2] := 3-(2*Ts_1);  MatrizPE[3,3] := 0;  MatrizPE[3,4] := -Ts;
    MatrizPE[4,1] := 2-Ts-Ts_1;      MatrizPE[4,2] := Ts_1-2;      MatrizPE[4,3] := 0;  MatrizPE[4,4] := Ts;

    aPE[1] := Poly.X[i];  aPE[2] := Poly.X[i+1];  aPE[3] := 0;  aPE[4] := Poly.X[i+2];
    a_CRx := ProdutoMatrizVetorN(MatrizPE,aPE,4);
    aPE[1] := Poly.Y[i];  aPE[2] := Poly.Y[i+1];  aPE[3] := 0;  aPE[4] := Poly.Y[i+2];
    a_CRy := ProdutoMatrizVetorN(MatrizPE,aPE,4);
    for j := 1 to Nintm+1 do
    begin
      k := k + 1;
      t_CR := 0+((j-1)*(1-0)/(Nintm+1));   { <<<<<--------- parametrização }
      Result.X[k] := Round(a_CRx[1]+(a_CRx[2]*t_CR)+(a_CRx[3]*Power(t_CR,2))+(a_CRx[4]*Power(t_CR,3)));
      Result.Y[k] := Round(a_CRy[1]+(a_CRy[2]*t_CR)+(a_CRy[3]*Power(t_CR,2))+(a_CRy[4]*Power(t_CR,3)));
    end;

    { Polinômios Interiores }
    If Poly.Npoly > 3 then
      for i := 2 to Poly.Npoly-2 do
      begin
        aPI[1] := Poly.X[i];  aPI[2] := Poly.X[i+1];  aPI[3] := Poly.X[i-1];  aPI[4] := Poly.X[i+2];
        a_CRx := ProdutoMatrizVetorN(MatrizPI,aPI,4);
        aPI[1] := Poly.Y[i];  aPI[2] := Poly.Y[i+1];  aPI[3] := Poly.Y[i-1];  aPI[4] := Poly.Y[i+2];
        a_CRy := ProdutoMatrizVetorN(MatrizPI,aPI,4);
        for j := 1 to Nintm+1 do
        begin
          k := k + 1;
          t_CR := 0+((j-1)*(1-0)/(Nintm+1));   { <<<<<--------- parametrização }
          Result.X[k] := Round(a_CRx[1]+(a_CRx[2]*t_CR)+(a_CRx[3]*Power(t_CR,2))+(a_CRx[4]*Power(t_CR,3)));
          Result.Y[k] := Round(a_CRy[1]+(a_CRy[2]*t_CR)+(a_CRy[3]*Power(t_CR,2))+(a_CRy[4]*Power(t_CR,3)));
        end;
      end;

    { Última Extremidade }
    i := Poly.Npoly-1;
    MatrizPE[1,1] := 1;       MatrizPE[1,2] := 0;              MatrizPE[1,3] := 0;     MatrizPE[1,4] := 0;
    MatrizPE[2,1] := 0;       MatrizPE[2,2] := Ts;             MatrizPE[2,3] := -Ts;   MatrizPE[2,4] := 0;
    MatrizPE[3,1] := Ts_N-3;  MatrizPE[3,2] := 3-(2*Ts)-Ts_N;  MatrizPE[3,3] := 2*Ts;  MatrizPE[3,4] := 0;
    MatrizPE[4,1] := 2-Ts_N;  MatrizPE[4,2] := Ts_N+Ts-2;      MatrizPE[4,3] := -Ts;   MatrizPE[4,4] := 0;

    aPE[1] := Poly.X[i];  aPE[2] := Poly.X[i+1];  aPE[3] := Poly.X[i-1];  aPE[4] := 0;
    a_CRx := ProdutoMatrizVetorN(MatrizPE,aPE,4);
    aPE[1] := Poly.Y[i];  aPE[2] := Poly.Y[i+1];  aPE[3] := Poly.Y[i-1];  aPE[4] := 0;
    a_CRy := ProdutoMatrizVetorN(MatrizPE,aPE,4);
    for j := 1 to Nintm+1 do
    begin
      k := k + 1;
      t_CR := 0+((j-1)*(1-0)/(Nintm+1));   { <<<<<--------- parametrização }
      Result.X[k] := Round(a_CRx[1]+(a_CRx[2]*t_CR)+(a_CRx[3]*Power(t_CR,2))+(a_CRx[4]*Power(t_CR,3)));
      Result.Y[k] := Round(a_CRy[1]+(a_CRy[2]*t_CR)+(a_CRy[3]*Power(t_CR,2))+(a_CRy[4]*Power(t_CR,3)));
    end;

    Result.X[k+1] := Round(a_CRx[1]+(a_CRx[2]*1)+(a_CRx[3]*Power(1,2))+(a_CRx[4]*Power(1,3)));
    Result.Y[k+1] := Round(a_CRy[1]+(a_CRy[2]*1)+(a_CRy[3]*Power(1,2))+(a_CRy[4]*Power(1,3)));
  End
  Else If Poly.Npoly <= 2 then
  Begin
    Result.Npoly := Poly.Npoly;
    SetLength(Result.X,Result.Npoly+1);
    SetLength(Result.Y,Result.Npoly+1);
    for k := 1 to Poly.Npoly do
    begin
      Result.X[k] := Poly.X[k];
      Result.Y[k] := Poly.Y[k];
    end;
  End;

end;  { CatmullRomSpline }

function CatmullRomSplineDyDx(Poly : TPline; Ts, D1, DN  : TFloatType; Nintm : integer) : TPline;
var                                  { D1,DN = Derivadas nas Extremidades }
  i,j,k : integer;
  MatrizPI,MatrizPE : TMatrizNxN;
  aPI,a_CRx,a_CRy,aPE : TVetorN;
  DY, t_CR : TFloatType;
begin
  MatrizPI := SetMatrixDim(MatrizPI,5);
  MatrizPI[1,1] := 1;     MatrizPI[1,2] := 0;         MatrizPI[1,3] := 0;     MatrizPI[1,4] := 0;
  MatrizPI[2,1] := 0;     MatrizPI[2,2] := Ts;        MatrizPI[2,3] := -Ts;   MatrizPI[2,4] := 0;
  MatrizPI[3,1] := Ts-3;  MatrizPI[3,2] := 3-(2*Ts);  MatrizPI[3,3] := 2*Ts;  MatrizPI[3,4] := -Ts;
  MatrizPI[4,1] := 2-Ts;  MatrizPI[4,2] := Ts-2;      MatrizPI[4,3] := -Ts;   MatrizPI[4,4] := Ts;

  SetLength(aPI,5);
  SetLength(a_CRx,5);
  SetLength(a_CRy,5);

  If Poly.Npoly > 2 then
  Begin
    Result.Npoly := Poly.Npoly + ((Poly.Npoly-1)*Nintm);
    SetLength(Result.X,Result.Npoly+1);
    SetLength(Result.Y,Result.Npoly+1);

    MatrizPE := SetMatrixDim(MatrizPE,5);
    SetLength(aPE,5);

    k := 0;   { Contagem do Número de Pontos do Spline }
    { Primeira Extremidade }
    i := 1;
    MatrizPE[1,1] := 1;              MatrizPE[1,2] := 0;           MatrizPE[1,3] := 0;  MatrizPE[1,4] := 0;
    MatrizPE[2,1] := -2*Ts;          MatrizPE[2,2] := 2*Ts;        MatrizPE[2,3] := 0;  MatrizPE[2,4] := 0;
    MatrizPE[3,1] := 5*Ts-3;         MatrizPE[3,2] := 3-(4*Ts);    MatrizPE[3,3] := 0;  MatrizPE[3,4] := -Ts;
    MatrizPE[4,1] := 2-3*Ts;         MatrizPE[4,2] := 2*Ts-2;      MatrizPE[4,3] := 0;  MatrizPE[4,4] := Ts;

    aPE[1] := Poly.X[i];    aPE[2] := Poly.X[i+1];  aPE[3] := 0;  aPE[4] := Poly.X[i+2];
    a_CRx := ProdutoMatrizVetorN(MatrizPE,aPE,4);
    SetLength(a_CRy,5);
    a_CRy[1] := Poly.Y[i];
    a_CRy[2] := D1*a_CRx[2];
    a_CRy[3] := 3*(Poly.Y[i+1]-Poly.Y[i])-(2*D1*a_CRx[2])-(Ts*(Poly.Y[i+2]-Poly.Y[i]));
    a_CRy[4] := 2*(Poly.Y[i]-Poly.Y[i+1])+(Ts*(Poly.Y[i+2]-Poly.Y[i]))+(D1*a_CRx[2]);

    for j := 1 to Nintm+1 do
    begin
      k := k + 1;
      t_CR := 0+((j-1)*(1-0)/(Nintm+1));   { <<<<<--------- parametrização }
      Result.X[k] := a_CRx[1]+(a_CRx[2]*t_CR)+(a_CRx[3]*Power(t_CR,2))+(a_CRx[4]*Power(t_CR,3));
      Result.Y[k] := a_CRy[1]+(a_CRy[2]*t_CR)+(a_CRy[3]*Power(t_CR,2))+(a_CRy[4]*Power(t_CR,3));
    end;

    { Polinômios Interiores }
    If Poly.Npoly > 3 then
      for i := 2 to Poly.Npoly-2 do
      begin
        aPI[1] := Poly.X[i];  aPI[2] := Poly.X[i+1];  aPI[3] := Poly.X[i-1];  aPI[4] := Poly.X[i+2];
        a_CRx := ProdutoMatrizVetorN(MatrizPI,aPI,4);
        aPI[1] := Poly.Y[i];  aPI[2] := Poly.Y[i+1];  aPI[3] := Poly.Y[i-1];  aPI[4] := Poly.Y[i+2];
        a_CRy := ProdutoMatrizVetorN(MatrizPI,aPI,4);
        for j := 1 to Nintm+1 do
        begin
          k := k + 1;
          t_CR := 0+((j-1)*(1-0)/(Nintm+1));   { <<<<<--------- parametrização }
          Result.X[k] := a_CRx[1]+(a_CRx[2]*t_CR)+(a_CRx[3]*Power(t_CR,2))+(a_CRx[4]*Power(t_CR,3));
          Result.Y[k] := a_CRy[1]+(a_CRy[2]*t_CR)+(a_CRy[3]*Power(t_CR,2))+(a_CRy[4]*Power(t_CR,3));
        end;
      end;

    { Última Extremidade }
    i := Poly.Npoly-1;
    MatrizPE[1,1] := 1;       MatrizPE[1,2] := 0;         MatrizPE[1,3] := 0;     MatrizPE[1,4] := 0;
    MatrizPE[2,1] := 0;       MatrizPE[2,2] := Ts;        MatrizPE[2,3] := -Ts;   MatrizPE[2,4] := 0;
    MatrizPE[3,1] := 2*Ts-3;  MatrizPE[3,2] := 3-(4*Ts);  MatrizPE[3,3] := 2*Ts;  MatrizPE[3,4] := 0;
    MatrizPE[4,1] := 2-2*Ts;  MatrizPE[4,2] := 3*Ts-2;    MatrizPE[4,3] := -Ts;   MatrizPE[4,4] := 0;

    aPE[1] := Poly.X[i];  aPE[2] := Poly.X[i+1];  aPE[3] := Poly.X[i-1];  aPE[4] := 0;
    a_CRx := ProdutoMatrizVetorN(MatrizPE,aPE,4);

    SetLength(a_CRy,5);
    DY := DN*(3*a_CRx[4]+2*a_CRx[3]+a_CRx[2]);
    a_CRy[1] := Poly.Y[i];
    a_CRy[2] := Ts*(Poly.Y[i+1]-Poly.Y[i-1]);
    a_CRy[3] := 3*(Poly.Y[i+1]-Poly.Y[i])-2*Ts*(Poly.Y[i+1]-Poly.Y[i-1])-DY;
    a_CRy[4] := 2*(Poly.Y[i]-Poly.Y[i+1])+DY+(Ts*(Poly.Y[i+1]-Poly.Y[i-1]));
    for j := 1 to Nintm+1 do
    begin
      k := k + 1;
      t_CR := 0+((j-1)*(1-0)/(Nintm+1));   { <<<<<--------- parametrização }
      Result.X[k] := a_CRx[1]+(a_CRx[2]*t_CR)+(a_CRx[3]*Power(t_CR,2))+(a_CRx[4]*Power(t_CR,3));
      Result.Y[k] := a_CRy[1]+(a_CRy[2]*t_CR)+(a_CRy[3]*Power(t_CR,2))+(a_CRy[4]*Power(t_CR,3));
    end;

    Result.X[k+1] := a_CRx[1]+(a_CRx[2]*1)+(a_CRx[3]*Power(1,2))+(a_CRx[4]*Power(1,3));
    Result.Y[k+1] := a_CRy[1]+(a_CRy[2]*1)+(a_CRy[3]*Power(1,2))+(a_CRy[4]*Power(1,3));
  End
  Else If Poly.Npoly <= 2 then
  Begin
    Result.Npoly := Poly.Npoly;
    SetLength(Result.X,Result.Npoly+1);
    SetLength(Result.Y,Result.Npoly+1);
    for k := 1 to Poly.Npoly do
    begin
      Result.X[k] := Poly.X[k];
      Result.Y[k] := Poly.Y[k];
    end;
  End;

end;  { CatmullRomSpline }

function CatmullRomSplineDyDx(Poly : TPlineIN; Ts, D1, DN : TFloatType; Nintm : integer) : TPlineIN;
var                                  { D1,DN = Derivadas nas Extremidades }
  i,j,k : integer;
  MatrizPI,MatrizPE : TMatrizNxN;
  aPI,a_CRx,a_CRy,aPE : TVetorN;
  DY, t_CR : TFloatType;
begin
  MatrizPI := SetMatrixDim(MatrizPI,5);
  MatrizPI[1,1] := 1;     MatrizPI[1,2] := 0;         MatrizPI[1,3] := 0;     MatrizPI[1,4] := 0;
  MatrizPI[2,1] := 0;     MatrizPI[2,2] := Ts;        MatrizPI[2,3] := -Ts;   MatrizPI[2,4] := 0;
  MatrizPI[3,1] := Ts-3;  MatrizPI[3,2] := 3-(2*Ts);  MatrizPI[3,3] := 2*Ts;  MatrizPI[3,4] := -Ts;
  MatrizPI[4,1] := 2-Ts;  MatrizPI[4,2] := Ts-2;      MatrizPI[4,3] := -Ts;   MatrizPI[4,4] := Ts;

  SetLength(aPI,5);
  SetLength(a_CRx,5);
  SetLength(a_CRy,5);

  If Poly.Npoly > 2 then
  Begin
    Result.Npoly := Poly.Npoly + ((Poly.Npoly-1)*Nintm);
    SetLength(Result.X,Result.Npoly+1);
    SetLength(Result.Y,Result.Npoly+1);

    MatrizPE := SetMatrixDim(MatrizPE,5);
    SetLength(aPE,5);

    k := 0;   { Contagem do Número de Pontos do Spline }
    { Primeira Extremidade }
    i := 1;
    MatrizPE[1,1] := 1;              MatrizPE[1,2] := 0;           MatrizPE[1,3] := 0;  MatrizPE[1,4] := 0;
    MatrizPE[2,1] := -2*Ts;          MatrizPE[2,2] := 2*Ts;        MatrizPE[2,3] := 0;  MatrizPE[2,4] := 0;
    MatrizPE[3,1] := 5*Ts-3;         MatrizPE[3,2] := 3-(4*Ts);    MatrizPE[3,3] := 0;  MatrizPE[3,4] := -Ts;
    MatrizPE[4,1] := 2-3*Ts;         MatrizPE[4,2] := 2*Ts-2;      MatrizPE[4,3] := 0;  MatrizPE[4,4] := Ts;

    aPE[1] := Poly.X[i];    aPE[2] := Poly.X[i+1];  aPE[3] := 0;  aPE[4] := Poly.X[i+2];
    a_CRx := ProdutoMatrizVetorN(MatrizPE,aPE,4);
    SetLength(a_CRy,5);
    a_CRy[1] := Poly.Y[i];
    a_CRy[2] := D1*a_CRx[2];
    a_CRy[3] := 3*(Poly.Y[i+1]-Poly.Y[i])-(2*D1*a_CRx[2])-(Ts*(Poly.Y[i+2]-Poly.Y[i]));
    a_CRy[4] := 2*(Poly.Y[i]-Poly.Y[i+1])+(Ts*(Poly.Y[i+2]-Poly.Y[i]))+(D1*a_CRx[2]);

    for j := 1 to Nintm+1 do
    begin
      k := k + 1;
      t_CR := 0+((j-1)*(1-0)/(Nintm+1));   { <<<<<--------- parametrização }
      Result.X[k] := Round(a_CRx[1]+(a_CRx[2]*t_CR)+(a_CRx[3]*Power(t_CR,2))+(a_CRx[4]*Power(t_CR,3)));
      Result.Y[k] := Round(a_CRy[1]+(a_CRy[2]*t_CR)+(a_CRy[3]*Power(t_CR,2))+(a_CRy[4]*Power(t_CR,3)));
    end;

    { Polinômios Interiores }
    If Poly.Npoly > 3 then
      for i := 2 to Poly.Npoly-2 do
      begin
        aPI[1] := Poly.X[i];  aPI[2] := Poly.X[i+1];  aPI[3] := Poly.X[i-1];  aPI[4] := Poly.X[i+2];
        a_CRx := ProdutoMatrizVetorN(MatrizPI,aPI,4);
        aPI[1] := Poly.Y[i];  aPI[2] := Poly.Y[i+1];  aPI[3] := Poly.Y[i-1];  aPI[4] := Poly.Y[i+2];
        a_CRy := ProdutoMatrizVetorN(MatrizPI,aPI,4);
        for j := 1 to Nintm+1 do
        begin
          k := k + 1;
          t_CR := 0+((j-1)*(1-0)/(Nintm+1));   { <<<<<--------- parametrização }
          Result.X[k] := Round(a_CRx[1]+(a_CRx[2]*t_CR)+(a_CRx[3]*Power(t_CR,2))+(a_CRx[4]*Power(t_CR,3)));
          Result.Y[k] := Round(a_CRy[1]+(a_CRy[2]*t_CR)+(a_CRy[3]*Power(t_CR,2))+(a_CRy[4]*Power(t_CR,3)));
        end;
      end;

    { Última Extremidade }
    i := Poly.Npoly-1;
    MatrizPE[1,1] := 1;       MatrizPE[1,2] := 0;         MatrizPE[1,3] := 0;     MatrizPE[1,4] := 0;
    MatrizPE[2,1] := 0;       MatrizPE[2,2] := Ts;        MatrizPE[2,3] := -Ts;   MatrizPE[2,4] := 0;
    MatrizPE[3,1] := 2*Ts-3;  MatrizPE[3,2] := 3-(4*Ts);  MatrizPE[3,3] := 2*Ts;  MatrizPE[3,4] := 0;
    MatrizPE[4,1] := 2-2*Ts;  MatrizPE[4,2] := 3*Ts-2;    MatrizPE[4,3] := -Ts;   MatrizPE[4,4] := 0;

    aPE[1] := Poly.X[i];  aPE[2] := Poly.X[i+1];  aPE[3] := Poly.X[i-1];  aPE[4] := 0;
    a_CRx := ProdutoMatrizVetorN(MatrizPE,aPE,4);

    SetLength(a_CRy,5);
    DY := DN*(3*a_CRx[4]+2*a_CRx[3]+a_CRx[2]);
    a_CRy[1] := Poly.Y[i];
    a_CRy[2] := Ts*(Poly.Y[i+1]-Poly.Y[i-1]);
    a_CRy[3] := 3*(Poly.Y[i+1]-Poly.Y[i])-2*Ts*(Poly.Y[i+1]-Poly.Y[i-1])-DY;
    a_CRy[4] := 2*(Poly.Y[i]-Poly.Y[i+1])+DY+(Ts*(Poly.Y[i+1]-Poly.Y[i-1]));
    for j := 1 to Nintm+1 do
    begin
      k := k + 1;
      t_CR := 0+((j-1)*(1-0)/(Nintm+1));   { <<<<<--------- parametrização }
      Result.X[k] := Round(a_CRx[1]+(a_CRx[2]*t_CR)+(a_CRx[3]*Power(t_CR,2))+(a_CRx[4]*Power(t_CR,3)));
      Result.Y[k] := Round(a_CRy[1]+(a_CRy[2]*t_CR)+(a_CRy[3]*Power(t_CR,2))+(a_CRy[4]*Power(t_CR,3)));
    end;

    Result.X[k+1] := Round(a_CRx[1]+(a_CRx[2]*1)+(a_CRx[3]*Power(1,2))+(a_CRx[4]*Power(1,3)));
    Result.Y[k+1] := Round(a_CRy[1]+(a_CRy[2]*1)+(a_CRy[3]*Power(1,2))+(a_CRy[4]*Power(1,3)));
  End
  Else If Poly.Npoly <= 2 then
  Begin
    Result.Npoly := Poly.Npoly;
    SetLength(Result.X,Result.Npoly+1);
    SetLength(Result.Y,Result.Npoly+1);
    for k := 1 to Poly.Npoly do
    begin
      Result.X[k] := Poly.X[k];
      Result.Y[k] := Poly.Y[k];
    end;
  End;

end;  { CatmullRomSpline }

function CatmullRomSpline3D(Poly : T3DPline; Ts,Ts_1,Ts_N : TFloatType; Nintm : integer) : T3DPline;
var                                  { Ts = Tension }
  i,j,k : integer;
  MatrizPI,MatrizPE : TMatrizNxN;
  aPI,a_CRx,a_CRy,a_CRz,aPE : TVetorN;
  t_CR : TFloatType;
begin                             
  MatrizPI := SetMatrixDim(MatrizPI,5);
  MatrizPI[1,1] := 1;     MatrizPI[1,2] := 0;         MatrizPI[1,3] := 0;     MatrizPI[1,4] := 0;
  MatrizPI[2,1] := 0;     MatrizPI[2,2] := Ts;        MatrizPI[2,3] := -Ts;   MatrizPI[2,4] := 0;
  MatrizPI[3,1] := Ts-3;  MatrizPI[3,2] := 3-(2*Ts);  MatrizPI[3,3] := 2*Ts;  MatrizPI[3,4] := -Ts;
  MatrizPI[4,1] := 2-Ts;  MatrizPI[4,2] := Ts-2;      MatrizPI[4,3] := -Ts;   MatrizPI[4,4] := Ts;

  SetLength(aPI,5);
  SetLength(a_CRx,5);
  SetLength(a_CRy,5);
  SetLength(a_CRz,5);

  If Poly.Npoly > 2 then
  Begin
    Result.Npoly := Poly.Npoly + ((Poly.Npoly-1)*Nintm);
    SetLength(Result.X,Result.Npoly+1);
    SetLength(Result.Y,Result.Npoly+1);
    SetLength(Result.Z,Result.Npoly+1);

    MatrizPE := SetMatrixDim(MatrizPE,5);
    SetLength(aPE,5);

    k := 0;   { Contagem do Número de Pontos do Spline }

    { Primeira Extremidade }
    i := 1;
    MatrizPE[1,1] := 1;              MatrizPE[1,2] := 0;           MatrizPE[1,3] := 0;  MatrizPE[1,4] := 0;
    MatrizPE[2,1] := -Ts_1;          MatrizPE[2,2] := Ts_1;        MatrizPE[2,3] := 0;  MatrizPE[2,4] := 0;
    MatrizPE[3,1] := Ts+(2*Ts_1)-3;  MatrizPE[3,2] := 3-(2*Ts_1);  MatrizPE[3,3] := 0;  MatrizPE[3,4] := -Ts;
    MatrizPE[4,1] := 2-Ts-Ts_1;      MatrizPE[4,2] := Ts_1-2;      MatrizPE[4,3] := 0;  MatrizPE[4,4] := Ts;

    aPE[1] := Poly.X[i];  aPE[2] := Poly.X[i+1];  aPE[3] := 0;  aPE[4] := Poly.X[i+2];
    a_CRx := ProdutoMatrizVetorN(MatrizPE,aPE,4);
    aPE[1] := Poly.Y[i];  aPE[2] := Poly.Y[i+1];  aPE[3] := 0;  aPE[4] := Poly.Y[i+2];
    a_CRy := ProdutoMatrizVetorN(MatrizPE,aPE,4);
    aPE[1] := Poly.Z[i];  aPE[2] := Poly.Z[i+1];  aPE[3] := 0;  aPE[4] := Poly.Z[i+2];
    a_CRz := ProdutoMatrizVetorN(MatrizPE,aPE,4);
    for j := 1 to Nintm+1 do
    begin
      k := k + 1;
      t_CR := 0+((j-1)*(1-0)/(Nintm+1));   { <<<<<--------- parametrização }
      Result.X[k] := a_CRx[1]+(a_CRx[2]*t_CR)+(a_CRx[3]*Power(t_CR,2))+(a_CRx[4]*Power(t_CR,3));
      Result.Y[k] := a_CRy[1]+(a_CRy[2]*t_CR)+(a_CRy[3]*Power(t_CR,2))+(a_CRy[4]*Power(t_CR,3));
      Result.Z[k] := a_CRz[1]+(a_CRz[2]*t_CR)+(a_CRz[3]*Power(t_CR,2))+(a_CRz[4]*Power(t_CR,3));
    end;

    { Polinômios Interiores }
    for i := 2 to Poly.Npoly-2 do
    begin
      aPI[1] := Poly.X[i];  aPI[2] := Poly.X[i+1];  aPI[3] := Poly.X[i-1];  aPI[4] := Poly.X[i+2];
      a_CRx := ProdutoMatrizVetorN(MatrizPI,aPI,4);
      aPI[1] := Poly.Y[i];  aPI[2] := Poly.Y[i+1];  aPI[3] := Poly.Y[i-1];  aPI[4] := Poly.Y[i+2];
      a_CRy := ProdutoMatrizVetorN(MatrizPI,aPI,4);
      aPI[1] := Poly.Z[i];  aPI[2] := Poly.Z[i+1];  aPI[3] := Poly.Z[i-1];  aPI[4] := Poly.Z[i+2];
      a_CRz := ProdutoMatrizVetorN(MatrizPI,aPI,4);
      for j := 1 to Nintm+1 do
      begin
        k := k + 1;
        t_CR := 0+((j-1)*(1-0)/(Nintm+1));   { <<<<<--------- parametrização }
        Result.X[k] := a_CRx[1]+(a_CRx[2]*t_CR)+(a_CRx[3]*Power(t_CR,2))+(a_CRx[4]*Power(t_CR,3));
        Result.Y[k] := a_CRy[1]+(a_CRy[2]*t_CR)+(a_CRy[3]*Power(t_CR,2))+(a_CRy[4]*Power(t_CR,3));
        Result.Z[k] := a_CRz[1]+(a_CRz[2]*t_CR)+(a_CRz[3]*Power(t_CR,2))+(a_CRz[4]*Power(t_CR,3));
      end;
    end;

    { Última Extremidade }
    i := Poly.Npoly-1;
    MatrizPE[1,1] := 1;       MatrizPE[1,2] := 0;              MatrizPE[1,3] := 0;     MatrizPE[1,4] := 0;
    MatrizPE[2,1] := 0;       MatrizPE[2,2] := Ts;             MatrizPE[2,3] := -Ts;   MatrizPE[2,4] := 0;
    MatrizPE[3,1] := Ts_N-3;  MatrizPE[3,2] := 3-(2*Ts)-Ts_N;  MatrizPE[3,3] := 2*Ts;  MatrizPE[3,4] := 0;
    MatrizPE[4,1] := 2-Ts_N;  MatrizPE[4,2] := Ts_N+Ts-2;      MatrizPE[4,3] := -Ts;   MatrizPE[4,4] := 0;

    aPE[1] := Poly.X[i];  aPE[2] := Poly.X[i+1];  aPE[3] := Poly.X[i-1];  aPE[4] := 0;
    a_CRx := ProdutoMatrizVetorN(MatrizPE,aPE,4);
    aPE[1] := Poly.Y[i];  aPE[2] := Poly.Y[i+1];  aPE[3] := Poly.Y[i-1];  aPE[4] := 0;
    a_CRy := ProdutoMatrizVetorN(MatrizPE,aPE,4);
    aPE[1] := Poly.Z[i];  aPE[2] := Poly.Z[i+1];  aPE[3] := Poly.Z[i-1];  aPE[4] := 0;
    a_CRz := ProdutoMatrizVetorN(MatrizPE,aPE,4);
    for j := 1 to Nintm+1 do
    begin
      k := k + 1;
      t_CR := 0+((j-1)*(1-0)/(Nintm+1));   { <<<<<--------- parametrização }
      Result.X[k] := a_CRx[1]+(a_CRx[2]*t_CR)+(a_CRx[3]*Power(t_CR,2))+(a_CRx[4]*Power(t_CR,3));
      Result.Y[k] := a_CRy[1]+(a_CRy[2]*t_CR)+(a_CRy[3]*Power(t_CR,2))+(a_CRy[4]*Power(t_CR,3));
      Result.Z[k] := a_CRz[1]+(a_CRz[2]*t_CR)+(a_CRz[3]*Power(t_CR,2))+(a_CRz[4]*Power(t_CR,3));
    end;

    Result.X[k+1] := a_CRx[1]+(a_CRx[2]*1)+(a_CRx[3]*Power(1,2))+(a_CRx[4]*Power(1,3));
    Result.Y[k+1] := a_CRy[1]+(a_CRy[2]*1)+(a_CRy[3]*Power(1,2))+(a_CRy[4]*Power(1,3));
    Result.Z[k+1] := a_CRz[1]+(a_CRz[2]*1)+(a_CRz[3]*Power(1,2))+(a_CRz[4]*Power(1,3));
  End
  Else If Poly.Npoly <= 2 then
  Begin
    Result.Npoly := Poly.Npoly;
    SetLength(Result.X,Result.Npoly+1);
    SetLength(Result.Y,Result.Npoly+1);
    SetLength(Result.Z,Result.Npoly+1);
    for k := 1 to Poly.Npoly do
    begin
      Result.X[k] := Poly.X[k];
      Result.Y[k] := Poly.Y[k];
      Result.Z[k] := Poly.Z[k];
    end;
  End;

end;  { CatmullRomSpline3D }

(*function CatmullRomSplineX(Poly : TPline; Ts,Ts_1,Ts_N : TFloatType; Nintm : integer) : TPline;
var                                  { Ts = Tension }
  i,j,k : integer;
  MatrizPI,MatrizPE : TMatrizNxN;
  aPI,a_CRx,a_CRy,aPE : TVetorN;
  t_CR : TFloatType;
begin
  MatrizPI := SetMatrixDim(MatrizPI,5);
  MatrizPI[1,1] := 1;     MatrizPI[1,2] := 0;         MatrizPI[1,3] := 0;     MatrizPI[1,4] := 0;
  MatrizPI[2,1] := 0;     MatrizPI[2,2] := Ts;        MatrizPI[2,3] := -Ts;   MatrizPI[2,4] := 0;
  MatrizPI[3,1] := Ts-3;  MatrizPI[3,2] := 3-(2*Ts);  MatrizPI[3,3] := 2*Ts;  MatrizPI[3,4] := -Ts;
  MatrizPI[4,1] := 2-Ts;  MatrizPI[4,2] := Ts-2;      MatrizPI[4,3] := -Ts;   MatrizPI[4,4] := Ts;

  SetLength(aPI,5);
  SetLength(a_CRx,5);
  SetLength(a_CRy,5);

  If Poly.Npoly > 2 then
  Begin
    Result.Npoly := Poly.Npoly + ((Poly.Npoly-1)*Nintm);
    SetLength(Result.X,Result.Npoly+1);
    SetLength(Result.Y,Result.Npoly+1);

    MatrizPE := SetMatrixDim(MatrizPE,5);
    SetLength(aPE,5);

    k := 0;   { Contagem do Número de Pontos do Spline }
    { Primeira Extremidade }
    i := 1;
    MatrizPE[1,1] := 1;              MatrizPE[1,2] := 0;           MatrizPE[1,3] := 0;  MatrizPE[1,4] := 0;
    MatrizPE[2,1] := -Ts_1;          MatrizPE[2,2] := Ts_1;        MatrizPE[2,3] := 0;  MatrizPE[2,4] := 0;
    MatrizPE[3,1] := Ts+(2*Ts_1)-3;  MatrizPE[3,2] := 3-(2*Ts_1);  MatrizPE[3,3] := 0;  MatrizPE[3,4] := -Ts;
    MatrizPE[4,1] := 2-Ts-Ts_1;      MatrizPE[4,2] := Ts_1-2;      MatrizPE[4,3] := 0;  MatrizPE[4,4] := Ts;

    aPE[1] := Poly.X[i];  aPE[2] := Poly.X[i+1];  aPE[3] := 0;  aPE[4] := Poly.X[i+2];
    a_CRx := ProdutoMatrizVetorN(MatrizPE,aPE,4);
    aPE[1] := Poly.Y[i];  aPE[2] := Poly.Y[i+1];  aPE[3] := 0;  aPE[4] := Poly.Y[i+2];
    a_CRy := ProdutoMatrizVetorN(MatrizPE,aPE,4);
    for j := 1 to Nintm+1 do
    begin
      k := k + 1;
      t_CR := 0+((j-1)*(1-0)/(Nintm+1));   { <<<<<--------- parametrização }
      Result.X[k] := Poly.X[i]+((j-1)*(Poly.X[i+1]-Poly.X[i])/(Nintm+1));
      Result.Y[k] := a_CRy[1]+(a_CRy[2]*t_CR)+(a_CRy[3]*Power(t_CR,2))+(a_CRy[4]*Power(t_CR,3));
    end;

    { Polinômios Interiores }
    for i := 2 to Poly.Npoly-2 do
    begin
      aPI[1] := Poly.X[i];  aPI[2] := Poly.X[i+1];  aPI[3] := Poly.X[i-1];  aPI[4] := Poly.X[i+2];
      a_CRx := ProdutoMatrizVetorN(MatrizPI,aPI,4);
      aPI[1] := Poly.Y[i];  aPI[2] := Poly.Y[i+1];  aPI[3] := Poly.Y[i-1];  aPI[4] := Poly.Y[i+2];
      a_CRy := ProdutoMatrizVetorN(MatrizPI,aPI,4);
      for j := 1 to Nintm+1 do
      begin
        k := k + 1;
        t_CR := 0+((j-1)*(1-0)/(Nintm+1));   { <<<<<--------- parametrização }
        Result.X[k] := Poly.X[i]+((j-1)*(Poly.X[i+1]-Poly.X[i])/(Nintm+1));
        Result.Y[k] := a_CRy[1]+(a_CRy[2]*t_CR)+(a_CRy[3]*Power(t_CR,2))+(a_CRy[4]*Power(t_CR,3));
      end;
    end;

    { Última Extremidade }
    i := Poly.Npoly-1;
    MatrizPE[1,1] := 1;       MatrizPE[1,2] := 0;              MatrizPE[1,3] := 0;     MatrizPE[1,4] := 0;
    MatrizPE[2,1] := 0;       MatrizPE[2,2] := Ts;             MatrizPE[2,3] := -Ts;   MatrizPE[2,4] := 0;
    MatrizPE[3,1] := Ts_N-3;  MatrizPE[3,2] := 3-(2*Ts)-Ts_N;  MatrizPE[3,3] := 2*Ts;  MatrizPE[3,4] := 0;
    MatrizPE[4,1] := 2-Ts_N;  MatrizPE[4,2] := Ts_N+Ts-2;      MatrizPE[4,3] := -Ts;   MatrizPE[4,4] := 0;

    aPE[1] := Poly.X[i];  aPE[2] := Poly.X[i+1];  aPE[3] := Poly.X[i-1];  aPE[4] := 0;
    a_CRx := ProdutoMatrizVetorN(MatrizPE,aPE,4);
    aPE[1] := Poly.Y[i];  aPE[2] := Poly.Y[i+1];  aPE[3] := Poly.Y[i-1];  aPE[4] := 0;
    a_CRy := ProdutoMatrizVetorN(MatrizPE,aPE,4);
    for j := 1 to Nintm+2 do
    begin
      k := k + 1;
      t_CR := 0+((j-1)*(1-0)/(Nintm+1));   { <<<<<--------- parametrização }
      Result.X[k] := Poly.X[i]+((j-1)*(Poly.X[i+1]-Poly.X[i])/(Nintm+1));
      Result.Y[k] := a_CRy[1]+(a_CRy[2]*t_CR)+(a_CRy[3]*Power(t_CR,2))+(a_CRy[4]*Power(t_CR,3));
    end;

  End
  Else If Poly.Npoly <= 2 then
  Begin
    Result.Npoly := Poly.Npoly;
    SetLength(Result.X,Result.Npoly+1);
    SetLength(Result.Y,Result.Npoly+1);
    for k := 1 to Poly.Npoly do
    begin
      Result.X[k] := Poly.X[k];
      Result.Y[k] := Poly.Y[k];
    end;
  End;

end;  { CatmullRomSplineX }

function CatmullRomSplineX(Poly : TPlineIN; Ts,Ts_1,Ts_N : TFloatType; Nintm : integer) : TPlineIN;
var                                  { Ts = Tension }
  i,j,k : integer;
  MatrizPI,MatrizPE : TMatrizNxN;
  aPI,a_CRx,a_CRy,aPE : TVetorN;
  t_CR : TFloatType;
begin
  MatrizPI := SetMatrixDim(MatrizPI,5);
  MatrizPI[1,1] := 1;     MatrizPI[1,2] := 0;         MatrizPI[1,3] := 0;     MatrizPI[1,4] := 0;
  MatrizPI[2,1] := 0;     MatrizPI[2,2] := Ts;        MatrizPI[2,3] := -Ts;   MatrizPI[2,4] := 0;
  MatrizPI[3,1] := Ts-3;  MatrizPI[3,2] := 3-(2*Ts);  MatrizPI[3,3] := 2*Ts;  MatrizPI[3,4] := -Ts;
  MatrizPI[4,1] := 2-Ts;  MatrizPI[4,2] := Ts-2;      MatrizPI[4,3] := -Ts;   MatrizPI[4,4] := Ts;

  SetLength(aPI,5);
  SetLength(a_CRx,5);
  SetLength(a_CRy,5);

  If Poly.Npoly > 2 then
  Begin
    Result.Npoly := Poly.Npoly + ((Poly.Npoly-1)*Nintm);
    SetLength(Result.X,Result.Npoly+1);
    SetLength(Result.Y,Result.Npoly+1);

    MatrizPE := SetMatrixDim(MatrizPE,5);
    SetLength(aPE,5);

    k := 0;   { Contagem do Número de Pontos do Spline }
    { Primeira Extremidade }
    i := 1;
    MatrizPE[1,1] := 1;              MatrizPE[1,2] := 0;           MatrizPE[1,3] := 0;  MatrizPE[1,4] := 0;
    MatrizPE[2,1] := -Ts_1;          MatrizPE[2,2] := Ts_1;        MatrizPE[2,3] := 0;  MatrizPE[2,4] := 0;
    MatrizPE[3,1] := Ts+(2*Ts_1)-3;  MatrizPE[3,2] := 3-(2*Ts_1);  MatrizPE[3,3] := 0;  MatrizPE[3,4] := -Ts;
    MatrizPE[4,1] := 2-Ts-Ts_1;      MatrizPE[4,2] := Ts_1-2;      MatrizPE[4,3] := 0;  MatrizPE[4,4] := Ts;

    aPE[1] := Poly.X[i];  aPE[2] := Poly.X[i+1];  aPE[3] := 0;  aPE[4] := Poly.X[i+2];
    a_CRx := ProdutoMatrizVetorN(MatrizPE,aPE,4);
    aPE[1] := Poly.Y[i];  aPE[2] := Poly.Y[i+1];  aPE[3] := 0;  aPE[4] := Poly.Y[i+2];
    a_CRy := ProdutoMatrizVetorN(MatrizPE,aPE,4);
    for j := 1 to Nintm+1 do
    begin
      k := k + 1;
      t_CR := 0+((j-1)*(1-0)/(Nintm+1));   { <<<<<--------- parametrização }
      Result.X[k] := Round(Poly.X[i]+((j-1)*(Poly.X[i+1]-Poly.X[i])/(Nintm+1)));
      Result.Y[k] := Round(a_CRy[1]+(a_CRy[2]*t_CR)+(a_CRy[3]*Power(t_CR,2))+(a_CRy[4]*Power(t_CR,3)));
    end;

    { Polinômios Interiores }
    for i := 2 to Poly.Npoly-2 do
    begin
      aPI[1] := Poly.X[i];  aPI[2] := Poly.X[i+1];  aPI[3] := Poly.X[i-1];  aPI[4] := Poly.X[i+2];
      a_CRx := ProdutoMatrizVetorN(MatrizPI,aPI,4);
      aPI[1] := Poly.Y[i];  aPI[2] := Poly.Y[i+1];  aPI[3] := Poly.Y[i-1];  aPI[4] := Poly.Y[i+2];
      a_CRy := ProdutoMatrizVetorN(MatrizPI,aPI,4);
      for j := 1 to Nintm+1 do
      begin
        k := k + 1;
        t_CR := 0+((j-1)*(1-0)/(Nintm+1));   { <<<<<--------- parametrização }
        Result.X[k] := Round(Poly.X[i]+((j-1)*(Poly.X[i+1]-Poly.X[i])/(Nintm+1)));
        Result.Y[k] := Round(a_CRy[1]+(a_CRy[2]*t_CR)+(a_CRy[3]*Power(t_CR,2))+(a_CRy[4]*Power(t_CR,3)));
      end;
    end;

    { Última Extremidade }
    i := Poly.Npoly-1;
    MatrizPE[1,1] := 1;       MatrizPE[1,2] := 0;              MatrizPE[1,3] := 0;     MatrizPE[1,4] := 0;
    MatrizPE[2,1] := 0;       MatrizPE[2,2] := Ts;             MatrizPE[2,3] := -Ts;   MatrizPE[2,4] := 0;
    MatrizPE[3,1] := Ts_N-3;  MatrizPE[3,2] := 3-(2*Ts)-Ts_N;  MatrizPE[3,3] := 2*Ts;  MatrizPE[3,4] := 0;
    MatrizPE[4,1] := 2-Ts_N;  MatrizPE[4,2] := Ts_N+Ts-2;      MatrizPE[4,3] := -Ts;   MatrizPE[4,4] := 0;

    aPE[1] := Poly.X[i];  aPE[2] := Poly.X[i+1];  aPE[3] := Poly.X[i-1];  aPE[4] := 0;
    a_CRx := ProdutoMatrizVetorN(MatrizPE,aPE,4);
    aPE[1] := Poly.Y[i];  aPE[2] := Poly.Y[i+1];  aPE[3] := Poly.Y[i-1];  aPE[4] := 0;
    a_CRy := ProdutoMatrizVetorN(MatrizPE,aPE,4);
    for j := 1 to Nintm+2 do
    begin
      k := k + 1;
      t_CR := 0+((j-1)*(1-0)/(Nintm+1));   { <<<<<--------- parametrização }
      Result.X[k] := Round(Poly.X[i]+((j-1)*(Poly.X[i+1]-Poly.X[i])/(Nintm+1)));
      Result.Y[k] := Round(a_CRy[1]+(a_CRy[2]*t_CR)+(a_CRy[3]*Power(t_CR,2))+(a_CRy[4]*Power(t_CR,3)));
    end;

  End
  Else If Poly.Npoly <= 2 then
  Begin
    Result.Npoly := Poly.Npoly;
    SetLength(Result.X,Result.Npoly+1);
    SetLength(Result.Y,Result.Npoly+1);
    for k := 1 to Poly.Npoly do
    begin
      Result.X[k] := Poly.X[k];
      Result.Y[k] := Poly.Y[k];
    end;
  End;

end;  { CatmullRomSplineX }*)

function CatmullRomSplineX(Poly : TPline; Ts_1,Ts_N : TFloatType; Nintm : integer) : TPline;
var                                                 { Ts_1 = Slope knot 1 }
  i,j,k : integer;                                  { Ts_N = Slope knot N }
  MatrizPI : TMatrizNxN;
  MatrizP3 : TMatriz3x3;
  aPI,a_CRy : TVetorN;
  t_CR : TFloatType;
  Xi,Xi2,Xi3,Xf,Xf2,Xf3 : TFloatType;
  Yi,Yf,Ti,Tf : TFloatType;
begin
  MatrizPI := SetMatrixDim(MatrizPI,4);
  SetLength(aPI,4);
  SetLength(a_CRy,4);

  If Poly.Npoly > 2 then
  Begin
    Result.Npoly := Poly.Npoly + ((Poly.Npoly-1)*Nintm);
    SetLength(Result.X,Result.Npoly+1);
    SetLength(Result.Y,Result.Npoly+1);

    k := 0;   { Contagem do Número de Pontos do Spline }
    { Primeira Extremidade }
    i := 1;
    Xi := Poly.X[i];    Xi2 := Power(Poly.X[i],2);    Xi3 := Power(Poly.X[i],3);
    Xf := Poly.X[i+1];  Xf2 := Power(Poly.X[i+1],2);  Xf3 := Power(Poly.X[i+1],3);
    Yi := Poly.Y[i];    Yf := Poly.Y[i+1];

    Ti := Ts_1;
    If not Equal(Poly.X[i],Poly.X[i+2],RelPrecision) then
      Tf := (Poly.Y[i+2]-Poly.Y[i])/(Poly.X[i+2]-Poly.X[i])
    Else Tf := 1000000000000000;    { tangente para 90 graus }

    MatrizPI[1,1] := Xi3-(3*Xi*Xf2);     MatrizPI[1,2] := Xi2-(2*Xi*Xf);     MatrizPI[1,3] := 1;
    MatrizPI[2,1] := -2*Xf3;             MatrizPI[2,2] := -Xf2;              MatrizPI[2,3] := 1;
    MatrizPI[3,1] := 3*(Xi2-Xf2);        MatrizPI[3,2] := 2*(Xi-Xf);         MatrizPI[3,3] := 0;

    aPI[1] := Yi-Xi*Tf;  aPI[2] := Yf-Xf*Tf;  aPI[3] := Ti-Tf;

    MatrizP3 := MatrixNxNTo3x3(MatrizPI);
    If MInvertivel3x3(MatrizP3) then       { Verifica se a Matriz tem Inversa }
    begin
      MatrizPI := MatrizInversa(MatrizPI,3);
      a_CRy := ProdutoMatrizVetorN(MatrizPI,aPI,3);
      a_CRy[0] := Tf-(3*Xf2*a_CRy[1])-(2*Xf*a_CRy[2]);
      for j := 1 to Nintm+1 do
      begin
        k := k + 1;
        t_CR := Poly.X[i]+((j-1)*(Poly.X[i+1]-Poly.X[i])/(Nintm+1));
        Result.X[k] := t_CR;
        Result.Y[k] := a_CRy[3]+(a_CRy[0]*t_CR)+(a_CRy[2]*Power(t_CR,2))+(a_CRy[1]*Power(t_CR,3));
      end;
    end
    Else begin
      for j := 1 to Nintm+1 do
      begin
        k := k + 1;
        t_CR := Poly.X[i]+((j-1)*(Poly.X[i+1]-Poly.X[i])/(Nintm+1));
        Result.X[k] := t_CR;
        Result.Y[k] := Poly.Y[i]+((j-1)*(Poly.Y[i+1]-Poly.Y[i])/(Nintm+1));
      end;
    end;

    { Polinômios Interiores }
    for i := 2 to Poly.Npoly-2 do
    begin
       Xi := Poly.X[i];    Xi2 := Power(Poly.X[i],2);    Xi3 := Power(Poly.X[i],3);
       Xf := Poly.X[i+1];  Xf2 := Power(Poly.X[i+1],2);  Xf3 := Power(Poly.X[i+1],3);
       Yi := Poly.Y[i];    Yf := Poly.Y[i+1];

       If not Equal(Poly.X[i-1],Poly.X[i+1],RelPrecision) then
         Ti := (Poly.Y[i+1]-Poly.Y[i-1])/(Poly.X[i+1]-Poly.X[i-1])
       Else Ti := 1000000000000000;    { tangente para 90 graus }

       If not Equal(Poly.X[i],Poly.X[i+2],RelPrecision) then
         Tf := (Poly.Y[i+2]-Poly.Y[i])/(Poly.X[i+2]-Poly.X[i])
       Else Tf := 1000000000000000;    { tangente para 90 graus }

       MatrizPI[1,1] := Xi3-(3*Xi*Xf2);     MatrizPI[1,2] := Xi2-(2*Xi*Xf);     MatrizPI[1,3] := 1;
       MatrizPI[2,1] := -2*Xf3;             MatrizPI[2,2] := -Xf2;              MatrizPI[2,3] := 1;
       MatrizPI[3,1] := 3*(Xi2-Xf2);        MatrizPI[3,2] := 2*(Xi-Xf);         MatrizPI[3,3] := 0;

      aPI[1] := Yi-Xi*Tf;  aPI[2] := Yf-Xf*Tf;  aPI[3] := Ti-Tf;

      MatrizP3 := MatrixNxNTo3x3(MatrizPI);
      If MInvertivel3x3(MatrizP3) then
      begin
        MatrizPI := MatrizInversa(MatrizPI,3);
        a_CRy := ProdutoMatrizVetorN(MatrizPI,aPI,3);
        a_CRy[0] := Tf-(3*Xf2*a_CRy[1])-(2*Xf*a_CRy[2]);
        for j := 1 to Nintm+1 do
        begin
          k := k + 1;
          t_CR := Poly.X[i]+((j-1)*(Poly.X[i+1]-Poly.X[i])/(Nintm+1));   { <<<<<--------- parametrização }
          Result.X[k] := t_CR;
          Result.Y[k] := a_CRy[3]+(a_CRy[0]*t_CR)+(a_CRy[2]*Power(t_CR,2))+(a_CRy[1]*Power(t_CR,3));
        end;
      end
      Else begin
        for j := 1 to Nintm+1 do
        begin
          k := k + 1;
          t_CR := Poly.X[i]+((j-1)*(Poly.X[i+1]-Poly.X[i])/(Nintm+1));   { <<<<<--------- parametrização }
          Result.X[k] := t_CR;
          Result.Y[k] := Poly.Y[i]+((j-1)*(Poly.Y[i+1]-Poly.Y[i])/(Nintm+1));
        end;
      end;
    end;

    { Última Extremidade }
    i := Poly.Npoly-1;
    Xi := Poly.X[i];    Xi2 := Power(Poly.X[i],2);    Xi3 := Power(Poly.X[i],3);
    Xf := Poly.X[i+1];  Xf2 := Power(Poly.X[i+1],2);  Xf3 := Power(Poly.X[i+1],3);
    Yi := Poly.Y[i];    Yf := Poly.Y[i+1];

    If not Equal(Poly.X[i-1],Poly.X[i+1],RelPrecision) then
      Ti := (Poly.Y[i+1]-Poly.Y[i-1])/(Poly.X[i+1]-Poly.X[i-1])
    Else Ti := 1000000000000000;    { tangente para 90 graus }
    Tf := Ts_N;

    MatrizPI[1,1] := Xi3-(3*Xi*Xf2);     MatrizPI[1,2] := Xi2-(2*Xi*Xf);     MatrizPI[1,3] := 1;
    MatrizPI[2,1] := -2*Xf3;             MatrizPI[2,2] := -Xf2;              MatrizPI[2,3] := 1;
    MatrizPI[3,1] := 3*(Xi2-Xf2);        MatrizPI[3,2] := 2*(Xi-Xf);         MatrizPI[3,3] := 0;

    aPI[1] := Yi-Xi*Tf;  aPI[2] := Yf-Xf*Tf;  aPI[3] := Ti-Tf;

    MatrizP3 := MatrixNxNTo3x3(MatrizPI);
    If MInvertivel3x3(MatrizP3) then       { Verifica se a Matriz tem Inversa }
    begin
      MatrizPI := MatrizInversa(MatrizPI,3);
      a_CRy := ProdutoMatrizVetorN(MatrizPI,aPI,3);
      a_CRy[0] := Tf-(3*Xf2*a_CRy[1])-(2*Xf*a_CRy[2]);
      for j := 1 to Nintm+1 do
      begin
        k := k + 1;
        t_CR := Poly.X[i]+((j-1)*(Poly.X[i+1]-Poly.X[i])/(Nintm+1));
        Result.X[k] := t_CR;
        Result.Y[k] := a_CRy[3]+(a_CRy[0]*t_CR)+(a_CRy[2]*Power(t_CR,2))+(a_CRy[1]*Power(t_CR,3));
      end;
    end
    Else begin
      for j := 1 to Nintm+1 do
      begin
        k := k + 1;
        t_CR := Poly.X[i]+((j-1)*(Poly.X[i+1]-Poly.X[i])/(Nintm+1));
        Result.X[k] := t_CR;
        Result.Y[k] := Poly.Y[i]+((j-1)*(Poly.Y[i+1]-Poly.Y[i])/(Nintm+1));
      end;
    end;
    Result.X[k+1] := Poly.X[Poly.Npoly];
    Result.Y[k+1] := Poly.Y[Poly.Npoly];
  End
  Else If Poly.Npoly <= 2 then
  Begin
    Result.Npoly := Poly.Npoly;
    SetLength(Result.X,Result.Npoly+1);
    SetLength(Result.Y,Result.Npoly+1);
    for k := 1 to Poly.Npoly do
    begin
      Result.X[k] := Poly.X[k];
      Result.Y[k] := Poly.Y[k];
    end;
  End;

end;  { CatmullRomSplineX }

function CatmullRomSplineX(Poly : TPlineIN; Ts_1,Ts_N : TFloatType; Nintm : integer) : TPlineIN;
var                                                 { Ts_1 = Slope knot 1 }
  i,j,k : integer;                                  { Ts_N = Slope knot N }
  MatrizPI : TMatrizNxN;
  MatrizP3 : TMatriz3x3;
  aPI,a_CRy : TVetorN;
  t_CR : TFloatType;
  Xi,Xi2,Xi3,Xf,Xf2,Xf3 : TFloatType;
  Yi,Yf,Ti,Tf : TFloatType;
begin
  MatrizPI := SetMatrixDim(MatrizPI,4);
  SetLength(aPI,4);
  SetLength(a_CRy,4);

  If Poly.Npoly > 2 then
  Begin
    Result.Npoly := Poly.Npoly + ((Poly.Npoly-1)*Nintm);
    SetLength(Result.X,Result.Npoly+1);
    SetLength(Result.Y,Result.Npoly+1);

    k := 0;   { Contagem do Número de Pontos do Spline }
    { Primeira Extremidade }
    i := 1;
    Xi := Poly.X[i];    Xi2 := Power(Poly.X[i],2);    Xi3 := Power(Poly.X[i],3);
    Xf := Poly.X[i+1];  Xf2 := Power(Poly.X[i+1],2);  Xf3 := Power(Poly.X[i+1],3);
    Yi := Poly.Y[i];    Yf := Poly.Y[i+1];

    Ti := Ts_1;
    If not Equal(Poly.X[i],Poly.X[i+2],RelPrecision) then
      Tf := (Poly.Y[i+2]-Poly.Y[i])/(Poly.X[i+2]-Poly.X[i])
    Else Tf := 1000000000000000;    { tangente para 90 graus }

    MatrizPI[1,1] := Xi3-(3*Xi*Xf2);     MatrizPI[1,2] := Xi2-(2*Xi*Xf);     MatrizPI[1,3] := 1;
    MatrizPI[2,1] := -2*Xf3;             MatrizPI[2,2] := -Xf2;              MatrizPI[2,3] := 1;
    MatrizPI[3,1] := 3*(Xi2-Xf2);        MatrizPI[3,2] := 2*(Xi-Xf);         MatrizPI[3,3] := 0;

    aPI[1] := Yi-Xi*Tf;  aPI[2] := Yf-Xf*Tf;  aPI[3] := Ti-Tf;

    MatrizP3 := MatrixNxNTo3x3(MatrizPI);
    If MInvertivel3x3(MatrizP3) then       { Verifica se a Matriz tem Inversa }
    begin
      MatrizPI := MatrizInversa(MatrizPI,3);
      a_CRy := ProdutoMatrizVetorN(MatrizPI,aPI,3);
      a_CRy[0] := Tf-(3*Xf2*a_CRy[1])-(2*Xf*a_CRy[2]);
      for j := 1 to Nintm+1 do
      begin
        k := k + 1;
        t_CR := Poly.X[i]+((j-1)*(Poly.X[i+1]-Poly.X[i])/(Nintm+1));
        Result.X[k] := Round(t_CR);
        Result.Y[k] := Round(a_CRy[3]+(a_CRy[0]*t_CR)+(a_CRy[2]*Power(t_CR,2))+(a_CRy[1]*Power(t_CR,3)));
      end;
    end
    Else begin
      for j := 1 to Nintm+1 do
      begin
        k := k + 1;
        t_CR := Poly.X[i]+((j-1)*(Poly.X[i+1]-Poly.X[i])/(Nintm+1));
        Result.X[k] := Round(t_CR);
        Result.Y[k] := Round(Poly.Y[i]+((j-1)*(Poly.Y[i+1]-Poly.Y[i])/(Nintm+1)));
      end;
    end;

    { Polinômios Interiores }
    for i := 2 to Poly.Npoly-2 do
    begin
       Xi := Poly.X[i];    Xi2 := Power(Poly.X[i],2);    Xi3 := Power(Poly.X[i],3);
       Xf := Poly.X[i+1];  Xf2 := Power(Poly.X[i+1],2);  Xf3 := Power(Poly.X[i+1],3);
       Yi := Poly.Y[i];    Yf := Poly.Y[i+1];

       If not Equal(Poly.X[i-1],Poly.X[i+1],RelPrecision) then
         Ti := (Poly.Y[i+1]-Poly.Y[i-1])/(Poly.X[i+1]-Poly.X[i-1])
       Else Ti := 1000000000000000;    { tangente para 90 graus }

       If not Equal(Poly.X[i],Poly.X[i+2],RelPrecision) then
         Tf := (Poly.Y[i+2]-Poly.Y[i])/(Poly.X[i+2]-Poly.X[i])
       Else Tf := 1000000000000000;    { tangente para 90 graus }

       MatrizPI[1,1] := Xi3-(3*Xi*Xf2);     MatrizPI[1,2] := Xi2-(2*Xi*Xf);     MatrizPI[1,3] := 1;
       MatrizPI[2,1] := -2*Xf3;             MatrizPI[2,2] := -Xf2;              MatrizPI[2,3] := 1;
       MatrizPI[3,1] := 3*(Xi2-Xf2);        MatrizPI[3,2] := 2*(Xi-Xf);         MatrizPI[3,3] := 0;

      aPI[1] := Yi-Xi*Tf;  aPI[2] := Yf-Xf*Tf;  aPI[3] := Ti-Tf;

      MatrizP3 := MatrixNxNTo3x3(MatrizPI);
      If MInvertivel3x3(MatrizP3) then
      begin
        MatrizPI := MatrizInversa(MatrizPI,3);
        a_CRy := ProdutoMatrizVetorN(MatrizPI,aPI,3);
        a_CRy[0] := Tf-(3*Xf2*a_CRy[1])-(2*Xf*a_CRy[2]);
        for j := 1 to Nintm+1 do
        begin
          k := k + 1;
          t_CR := Poly.X[i]+((j-1)*(Poly.X[i+1]-Poly.X[i])/(Nintm+1));   { <<<<<--------- parametrização }
          Result.X[k] := Round(t_CR);
          Result.Y[k] := Round(a_CRy[3]+(a_CRy[0]*t_CR)+(a_CRy[2]*Power(t_CR,2))+(a_CRy[1]*Power(t_CR,3)));
        end;
      end
      Else begin
        for j := 1 to Nintm+1 do
        begin
          k := k + 1;
          t_CR := Poly.X[i]+((j-1)*(Poly.X[i+1]-Poly.X[i])/(Nintm+1));   { <<<<<--------- parametrização }
          Result.X[k] := Round(t_CR);
          Result.Y[k] := Round(Poly.Y[i]+((j-1)*(Poly.Y[i+1]-Poly.Y[i])/(Nintm+1)));
        end;
      end;
    end;

    { Última Extremidade }
    i := Poly.Npoly-1;
    Xi := Poly.X[i];    Xi2 := Power(Poly.X[i],2);    Xi3 := Power(Poly.X[i],3);
    Xf := Poly.X[i+1];  Xf2 := Power(Poly.X[i+1],2);  Xf3 := Power(Poly.X[i+1],3);
    Yi := Poly.Y[i];    Yf := Poly.Y[i+1];

    If not Equal(Poly.X[i-1],Poly.X[i+1],RelPrecision) then
      Ti := (Poly.Y[i+1]-Poly.Y[i-1])/(Poly.X[i+1]-Poly.X[i-1])
    Else Ti := 1000000000000000;    { tangente para 90 graus }
    Tf := Ts_N;

    MatrizPI[1,1] := Xi3-(3*Xi*Xf2);     MatrizPI[1,2] := Xi2-(2*Xi*Xf);     MatrizPI[1,3] := 1;
    MatrizPI[2,1] := -2*Xf3;             MatrizPI[2,2] := -Xf2;              MatrizPI[2,3] := 1;
    MatrizPI[3,1] := 3*(Xi2-Xf2);        MatrizPI[3,2] := 2*(Xi-Xf);         MatrizPI[3,3] := 0;

    aPI[1] := Yi-Xi*Tf;  aPI[2] := Yf-Xf*Tf;  aPI[3] := Ti-Tf;

    MatrizP3 := MatrixNxNTo3x3(MatrizPI);
    If MInvertivel3x3(MatrizP3) then       { Verifica se a Matriz tem Inversa }
    begin
      MatrizPI := MatrizInversa(MatrizPI,3);
      a_CRy := ProdutoMatrizVetorN(MatrizPI,aPI,3);
      a_CRy[0] := Tf-(3*Xf2*a_CRy[1])-(2*Xf*a_CRy[2]);
      for j := 1 to Nintm+1 do
      begin
        k := k + 1;
        t_CR := Poly.X[i]+((j-1)*(Poly.X[i+1]-Poly.X[i])/(Nintm+1));
        Result.X[k] := Round(t_CR);
        Result.Y[k] := Round(a_CRy[3]+(a_CRy[0]*t_CR)+(a_CRy[2]*Power(t_CR,2))+(a_CRy[1]*Power(t_CR,3)));
      end;
    end
    Else begin
      for j := 1 to Nintm+1 do
      begin
        k := k + 1;
        t_CR := Poly.X[i]+((j-1)*(Poly.X[i+1]-Poly.X[i])/(Nintm+1));
        Result.X[k] := Round(t_CR);
        Result.Y[k] := Round(Poly.Y[i]+((j-1)*(Poly.Y[i+1]-Poly.Y[i])/(Nintm+1)));
      end;
    end;
    Result.X[k+1] := Poly.X[Poly.Npoly];
    Result.Y[k+1] := Poly.Y[Poly.Npoly];
  End
  Else If Poly.Npoly <= 2 then
  Begin
    Result.Npoly := Poly.Npoly;
    SetLength(Result.X,Result.Npoly+1);
    SetLength(Result.Y,Result.Npoly+1);
    for k := 1 to Poly.Npoly do
    begin
      Result.X[k] := Poly.X[k];
      Result.Y[k] := Poly.Y[k];
    end;
  End;

end;  { CatmullRomSplineX }

function Ellipse_3_Points(X1, Y1, X2, Y2, XC, YC : TFloatType; Nintm : integer; CW, Inner: Boolean) : TPline;
var                              { Arco de Elipse passando por 2 pontos com centro pré definido }
  i,j,k : integer;
  PV,m,n,a,b : TFloatType;
  Tmax,Tmin,DeltaT,T1,T2,T,r : TFloatType;
begin
  { Caso os pontos não sejam colineares }
  PV := ProdutoVetorial2D(X1-XC,Y1-YC,X2-XC,Y2-YC);

  { Calcula Coordenadas do Arco de Ellipse }
  If not Equal(PV,0,RelPrecision) then
  begin
    Result.Npoly := 2 + Nintm;
    SetLength(Result.X,Result.Npoly+1);
    SetLength(Result.Y,Result.Npoly+1);

    n := (sqr(X1-XC)-sqr(X2-XC))/((sqr(X1-XC)*sqr(Y2-YC))-(sqr(X2-XC)*sqr(Y1-YC)));
    b:= 1/sqrt(ABS(n));    { Valor Absoluto de N para evitar interrupção do programa }
    m := (sqr(Y2-YC)-sqr(Y1-YC))/((sqr(X1-XC)*sqr(Y2-YC))-(sqr(X2-XC)*sqr(Y1-YC)));
    a := 1/sqrt(ABS(m));   { Valor Absoluto de M para evitar interrupção do programa }

    { Ângulo de (X1,Y1) em Relação ao Centro (XC,YC) da Elipse }
    If not Equal(X1,XC,RelPrecision) then
      T1 := Arctan2(Y1-YC,X1-XC)
    Else begin
      If Greater(Y1,YC,RelPrecision) then
        T1 := Pi/2
      Else T1 := -Pi/2;
    end;

    { Ângulo de (X2,Y2) em Relação ao Centro (XC,YC) da Elipse }
    If not Equal(X2,XC,RelPrecision) then
      T2 := Arctan2(Y2-YC,X2-XC)
    Else begin
      If Greater(Y2,YC,RelPrecision) then
        T2 := Pi/2
      Else T2 := -Pi/2;
    end;

    k := 0;
    Tmax := Max(T1,T2);  Tmin := Min(T1,T2);
    DeltaT := Tmax-Tmin;
    { Pontos Marcados por Coordenadas Polares }
    If CW = True then
    begin     { Sentido Horário - CW }
      If Inner = True then  { Elipse - Ângulo Interno/Agudo }
      begin
        for j := 1 to Nintm+2 do
        begin
          k := k + 1;
          T := Tmax - ((j-1)*DeltaT/(Nintm+1));
          r := a*b/sqrt((sqr(b)-sqr(a))*sqr(COS(T))+sqr(a));
          Result.X[k] := XC + r*COS(T);
          Result.Y[k] := YC + r*SIN(T);
        end;
      end
      Else begin            { Elipse - Ângulo Externo/Obtuso }
        for j := 1 to Nintm+2 do
        begin
          k := k + 1;
          T := Tmin - ((j-1)*DeltaT/(Nintm+1));
          r := a*b/sqrt((sqr(b)-sqr(a))*sqr(COS(T))+sqr(a));
          Result.X[k] := XC + r*COS(T);
          Result.Y[k] := YC + r*SIN(T);
        end;
      end;
    end
    Else begin    { Sentido Anti Horário - CCW }
      If Inner = True then  { Elipse - Ângulo Interno/Agudo }
      begin
        for j := 1 to Nintm+2 do
        begin
          k := k + 1;
          T := Tmin + ((j-1)*DeltaT/(Nintm+1));
          r := a*b/sqrt((sqr(b)-sqr(a))*sqr(COS(T))+sqr(a));
          Result.X[k] := XC + r*COS(T);
          Result.Y[k] := YC + r*SIN(T);
        end;
      end
      Else begin            { Elipse - Ângulo Externo/Obtuso }
        for j := 1 to Nintm+2 do
        begin
          k := k + 1;
          T := Tmax + ((j-1)*DeltaT/(Nintm+1));
          r := a*b/sqrt((sqr(b)-sqr(a))*sqr(COS(T))+sqr(a));
          Result.X[k] := XC + r*COS(T);
          Result.Y[k] := YC + r*SIN(T);
        end;
      end;
    end
  end
  Else begin   { Pontos Colineares }
    r := sqrt(sqr(X1-XC)+sqr(Y1-YC));
    { Círculo }
    If Equal(r,Hypot(X2-XC,Y2-YC),RelPrecision) then
    begin
      Result.Npoly := 2 + Nintm;
      SetLength(Result.X,Result.Npoly+1);
      SetLength(Result.Y,Result.Npoly+1);

      { Ângulo de (X1,Y1) em Relação ao Centro (XC,YC) da Elipse }
      If not Equal(X1,XC,RelPrecision) then
        T1 := Arctan2(Y1-YC,X1-XC)
      Else begin
        If Greater(Y1,YC,RelPrecision) then
          T1 := Pi/2
        Else T1 := -Pi/2;
      end;

      { Ângulo de (X2,Y2) em Relação ao Centro (XC,YC) da Elipse }
      If not Equal(X2,XC,RelPrecision) then
        T2 := Arctan2(Y2-YC,X2-XC)
      Else begin
        If Greater(Y2,YC,RelPrecision) then
          T2 := Pi/2
        Else T2 := -Pi/2;
      end;

      k := 0;
      Tmax := Max(T1,T2);  Tmin := Min(T1,T2);
      DeltaT := Tmax-Tmin;
      { Pontos Marcados por Coordenadas Polares }
      If CW = True then
      begin     { Sentido Horário - CW }
        If Inner = True then  { Círculo - Ângulo Interno/Agudo }
        begin
          for j := 1 to Nintm+2 do
          begin
            k := k + 1;
            T := Tmax - ((j-1)*DeltaT/(Nintm+1));
            Result.X[k] := XC + r*COS(T);
            Result.Y[k] := YC + r*SIN(T);
          end;
        end
        Else begin            { Círculo - Ângulo Externo/Obtuso }
          for j := 1 to Nintm+2 do
          begin
            k := k + 1;
            T := Tmin - ((j-1)*DeltaT/(Nintm+1));
            Result.X[k] := XC + r*COS(T);
            Result.Y[k] := YC + r*SIN(T);
          end;
        end;
      end
      Else begin    { Sentido Anti Horário - CCW }
        If Inner = True then  { Elipse - Ângulo Interno/Agudo }
        begin
          for j := 1 to Nintm+2 do
          begin
            k := k + 1;
            T := Tmin + ((j-1)*DeltaT/(Nintm+1));
            Result.X[k] := XC + r*COS(T);
            Result.Y[k] := YC + r*SIN(T);
          end;
        end
        Else begin            { Elipse - Ângulo Externo/Obtuso }
          for j := 1 to Nintm+2 do
          begin
            k := k + 1;
            T := Tmax + ((j-1)*DeltaT/(Nintm+1));
            Result.X[k] := XC + r*COS(T);
            Result.Y[k] := YC + r*SIN(T);
          end;
        end;
      end;
    end
    Else begin
      Result.Npoly := 2;
      SetLength(Result.X,Result.Npoly+1);
      SetLength(Result.Y,Result.Npoly+1);

      Result.X[1] := X1;   Result.Y[1] := Y1;
      Result.X[2] := X2;   Result.Y[2] := Y2;
    end;
  end;
end;  { Ellipse_3_Points }

procedure MirrorToVector(X1,Y1,Z1,X2,Y2,Z2 : TFloatType; X,Y,Z : TFloatType;
                         var XResult, YResult, ZResult : TFloatType);
var                   { Define ponto simétrico a (X,Y,Z) em }
  A,B,C : TFloatType;       { relação ao vetor (X2-X1,Y2-Y1,Z2-Z1) }
  PE : TFloatType;
begin
  VetorUnitario(X2-X1,Y2-Y1,Z2-Z1,A,B,C);
  PE := ProdutoEscalar(X-X1,Y-Y1,Z-Z1,A,B,C);
  XResult := X1+(2*PE*A)-(X-X1);
  YResult := Y1+(2*PE*B)-(Y-Y1);
  ZResult := Z1+(2*PE*C)-(Z-Z1);
end;  { MirrorToVector }

procedure MirrorToTriangle(X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3 : TFloatType; X,Y,Z : TFloatType;
                           var XResult, YResult, ZResult : TFloatType);
var                   { Define ponto simétrico a (X,Y,Z) em relação ao }
  A,B,C : TFloatType;       { triângulo ((X1,Y1,Z1),(X2,Y2,Z2),(X3,Y3,Z3) }
  Dist : TFloatType;
begin
  { Vetor Normal do Triângulo }
  ProdutoVetorial(X3-X1,Y3-Y1,Z3-Z1,X2-X1,Y2-Y1,Z2-Z1,A,B,C);
  VetorUnitario(A,B,C,A,B,C);
  { Distância ao Plano - <0 atrás da normal, >0 a frente da normal }
  Dist := Dist_PointToTriangle(X,Y,Z,X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3);
  { Calcula Ponto Simétrico XResult, YResult, ZResult }
  XResult := X-(2*A*Dist);
  YResult := Y-(2*B*Dist);
  ZResult := Z-(2*C*Dist);
end;  { MirrorToTriangle }

procedure MirrorToPlan(X1,Y1,Z1,XN,YN,ZN : TFloatType; X,Y,Z : TFloatType;
                       var XResult, YResult, ZResult : TFloatType);
var                   { Define ponto simétrico a (X,Y,Z) em }
  Dist : TFloatType;        { relação ao plano }
begin
  { Distância ao Plano - <0 atrás da normal, >0 a frente da normal }
  Dist := ProdutoEscalar(X-X1,Y-Y1,Z-Z1,XN,YN,ZN);
  { Calcula Ponto Simétrico XResult, YResult, ZResult }
  XResult := X-(2*XN*Dist);
  YResult := Y-(2*YN*Dist);
  ZResult := Z-(2*ZN*Dist);
end;  { MirrorToPlan }

procedure MirrorToPlan(Plan : TPlan; X,Y,Z : TFloatType; var XResult, YResult, ZResult : TFloatType);
var                   { Define ponto simétrico a (X,Y,Z) em }
  Dist : TFloatType;        { relação ao plano Plan }
begin
  { Distância ao Plano - <0 atrás da normal, >0 a frente da normal }
  Dist := ProdutoEscalar(X-Plan.X1,Y-Plan.Y1,Z-Plan.Z1,Plan.XN,Plan.YN,Plan.ZN);
  { Calcula Ponto Simétrico XResult, YResult, ZResult }
  XResult := X-(2*Plan.XN*Dist);
  YResult := Y-(2*Plan.YN*Dist);
  ZResult := Z-(2*Plan.ZN*Dist);
end;  { MirrorToPlan }

function MirrorToPlan(Plan : TPlan; P : T3DPoint) : T3DPoint;
var                   { Define ponto simétrico a P em }
  Dist : TFloatType;        { relação ao plano Plan }
begin
  { Distância ao Plano - <0 atrás da normal, >0 a frente da normal }
  Dist := ProdutoEscalar(P.X-Plan.X1,P.Y-Plan.Y1,P.Z-Plan.Z1,Plan.XN,Plan.YN,Plan.ZN);
  { Calcula Ponto Simétrico XResult, YResult, ZResult }
  Result.X := P.X-(2*Plan.XN*Dist);
  Result.Y := P.Y-(2*Plan.YN*Dist);
  Result.Z := P.Z-(2*Plan.ZN*Dist);
end;  { MirrorToPlan }

procedure WriteonDXF_Poly(var DXF : text; Layer : string; color : integer; closed : boolean;
                          Initial, Final, Npoly : integer; X, Y, Z : TVetorN;
                          MinWidth, DecPlaces : integer);
var
  i : integer;
begin
  writeln(DXF,'0');                    { Identifyes the beginning of an entity }
  writeln(DXF,'POLYLINE');
  writeln(DXF,'8');                    { Layer Name}
  writeln(DXF,Layer);
  writeln(DXF,'62');                   { color }
  writeln(DXF,IntToStr(color));        { Color Chosen }

  writeln(DXF,'70');                   { Polyline flag (bit-coded; default = 0) }
  writeln(DXF,'10');                   { start point of a line or text entity }

  writeln(DXF,'66');                   { Obsolete; formerly an “entities follow flag” (optional; ignore if present) }
  writeln(DXF,'1');                    { Primary text value for an entity }

  for i := Initial to Final do
  begin
    writeln(DXF,'0');
    writeln(DXF,'VERTEX');
    writeln(DXF,'8');
    writeln(DXF,Layer);

    writeln(DXF,'10');                 { X coordinate }
    writeln(DXF,X[i]:MinWidth:DecPlaces);

    writeln(DXF,'20');                 { Y coordinate }
    writeln(DXF,Y[i]:MinWidth:DecPlaces);

    writeln(DXF,'30');                 { Z coordinate }
    writeln(DXF,Z[i]:MinWidth:DecPlaces);

    writeln(DXF,'70');                 { Polyline flag (bit-coded) Vertex flags: }
    writeln(DXF,'32');                 { 32 = 3D polyline vertex }
  end;

  If closed then
  begin
    writeln(DXF,'0');
    writeln(DXF,'VERTEX');
    writeln(DXF,'8');
    writeln(DXF,Layer);

    writeln(DXF,'10');                 { X coordinate }
    writeln(DXF,X[1]:MinWidth:DecPlaces);

    writeln(DXF,'20');                 { Y coordinate }
    writeln(DXF,Y[1]:MinWidth:DecPlaces);

    writeln(DXF,'30');                 { Z coordinate }
    writeln(DXF,Z[1]:MinWidth:DecPlaces);

    writeln(DXF,'70');                 { Polyline flag (bit-coded) Vertex flags: }
    writeln(DXF,'32');                 { 32 = 3D polyline vertex }
  end;

  writeln(DXF,'0');
  writeln(DXF,'SEQEND');               { END OF POLYLINE }
end;  { WriteonDXF_Poly }

procedure WriteonDXF_SetofPoly(var DXF : text; Layer : string; color : integer;
                               PolySet : TWire; MinWidth, DecPlaces : integer);
var
  i : integer;
begin
  for i := 1 to PolySet.N do
  begin
    WriteonDXF_Poly(DXF, Layer, color, PolySet.P[i].Closed,1,PolySet.P[i].Npoly,
                    PolySet.P[i].Npoly,PolySet.P[i].X,PolySet.P[i].Y,PolySet.P[i].Z,
                    MinWidth,DecPlaces);
  end;
end;  { WriteonDXF_SetofPoly }

procedure WriteonDXF_3DFace(var DXF : text; Layer : string; color : integer;
                            X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3 : TFloatType;
                            MinWidth, DecPlaces : integer);
begin
  writeln(DXF,'0');
  writeln(DXF,'3DFACE');
  writeln(DXF,'8');
  writeln(DXF,Layer);
  writeln(DXF,'62');  { color }
  writeln(DXF,IntToStr(color));

  writeln(DXF,'10');         { X1 }
  writeln(DXF,X1:MinWidth:DecPlaces);
  writeln(DXF,'20');         { Y1 }
  writeln(DXF,Y1:MinWidth:DecPlaces);
  writeln(DXF,'30');         { Z1 }
  writeln(DXF,Z1:MinWidth:DecPlaces);

  writeln(DXF,'11');         { X2 }
  writeln(DXF,X2:MinWidth:DecPlaces);
  writeln(DXF,'21');         { Y2 }
  writeln(DXF,Y2:MinWidth:DecPlaces);
  writeln(DXF,'31');         { Z2 }
  writeln(DXF,Z2:MinWidth:DecPlaces);

  writeln(DXF,'12');         { X3 }
  writeln(DXF,X3:MinWidth:DecPlaces);
  writeln(DXF,'22');         { Y3 }
  writeln(DXF,Y3:MinWidth:DecPlaces);
  writeln(DXF,'32');         { Z3 }
  writeln(DXF,Z3:MinWidth:DecPlaces);

  writeln(DXF,'13');         { X3 }
  writeln(DXF,X3:MinWidth:DecPlaces);
  writeln(DXF,'23');         { Y3 }
  writeln(DXF,Y3:MinWidth:DecPlaces);
  writeln(DXF,'33');         { Z3 }
  writeln(DXF,Z3:MinWidth:DecPlaces);
end;  { WriteonDXF_3DFace }

procedure WriteonTXT_Str(var TXT : text; StrTxt : string);
begin
  StrTxt := AdjustLineBreaks(StrTxt,tlbsCRLF);
  write(TXT,StrTxt);
end;  { WriteonTXT_Str }

procedure WritelnonTXT_Str(var TXT : text; StrTxt : string);
begin
  StrTxt := AdjustLineBreaks(StrTxt,tlbsCRLF);
  writeln(TXT,StrTxt);
end;  { WriteonTXT_Str }

procedure StringToText(var TXT : text; FileName, StrTxt : string);
begin
  assignfile(TXT,FileName);
  rewrite(TXT);
  StrTxt := AdjustLineBreaks(StrTxt,tlbsCRLF);
  write(TXT,StrTxt);
  closefile(TXT);
end;  { StringToText }

procedure StringToPoint(Str : string; var X : TFloatType; var Y : TFloatType; var Z : TFloatType);
var
  i, Lstr : integer;
  ch1 : char;
  str_acm : string;
begin
  Str := AdjustLineBreaks(Str,tlbsCRLF);
  Lstr := length(Str);
  { ### X - Primeira Coordenada ### }
  str_acm := '';
  i := 0;
  ch1 := #0;
  repeat
  begin
    i := i + 1;
    ch1 := Str[i];
    { Acumula caracteres numéricos da string }
    If ((ch1 <> ' ') or (ch1 <> #9) or (ch1 <> '')) and (ch1 in ['0'..'9',',','.','-']) then
      str_acm := str_acm + ch1;
    //ShowMessage(Str+#13+str_acm+'P');
  end;
  until((ch1 = ' ') or (ch1 = #9));
  //ShowMessage(str_acm);
  X := StrToFloat(str_acm);

  { Pula Espaços em Branco }
  repeat
  begin
    { Encontra a próxima coordenada }
    i := i + 1;
    ch1 := Str[i];
    //ShowMessage(ch1);
  end;
  until(ch1 in ['0'..'9',',','.','-']);
  i := i - 1;

  { ### Y - Segunda Coordenada ### }
  str_acm := '';
  repeat
  begin
    i := i + 1;
    ch1 := Str[i];
    { Acumula caracteres numéricos da string }
    If ((ch1 <> ' ') or (ch1 <> #9) or (ch1 <> '')) and (ch1 in ['0'..'9',',','.','-']) then
      str_acm := str_acm + ch1;
    //ShowMessage(IntToStr(i)+' '+Str+#13+str_acm);
  end;
  until((ch1 = ' ') or (ch1 = #9));
  //ShowMessage(str_acm);
  Y := StrToFloat(str_acm);

  { Pula Espaços em Branco }
  repeat
  begin
    { Encontra a próxima coordenada }
    i := i + 1;
    ch1 := Str[i];
  end;
  until((ch1 in ['0'..'9',',','.','-']));
  i := i - 1;

  { ### Z - Terceira Coordenada ### }
  str_acm := '';

  repeat
  begin
    i := i + 1;
    ch1 := Str[i];
    { Acumula caracteres numéricos da string }
    If ((ch1 <> ' ') or (ch1 <> #9) or (ch1 <> '') or (ch1 <> #10) or (ch1 <> #13))
        and (ch1 in ['0'..'9',',','.','-']) then
      str_acm := str_acm + ch1;
    //ShowMessage(IntToStr(i)+' '+Str+#13+str_acm+'P');
  end;
  until((ch1 = ' ') or (ch1 = #9) or (i = Lstr));
  Z := StrToFloat(str_acm);

end;  { StringToPoint }

function NumberPosStr(Start : integer; Str : string) : integer;
var                      { Fornece posição do primeiro caracter numérico após a posição Start }
  i, Lstr : integer;
  ch1 : char;
begin
  Lstr := length(Str);
  ch1 := #0;

  If (Start > 0) and (Start <= Lstr) then
    i := Start-1
  Else i := 0;

  { Pula Espaços em Branco }
  repeat
  begin
    { Encontra o número }
    i := i + 1;
    ch1 := Str[i];
    //ShowMessage(ch1);
  end;
  until((ch1 in ['0'..'9',',','.','-']) or (i = Lstr));

  Result := i;
end;  { NumberPosStr }

procedure WriteonDXFStr_Poly(var DXF : string; Layer : string; color : integer; closed : boolean;
                             Initial, Final, Npoly : integer; X, Y, Z : TVetorN;
                             Format : TFloatFormat; Precision, Digits : integer);
var
  i : integer;
begin
  DXF := DXF + '0' + #13;                    { Identifyes the beginning of an entity }
  DXF := DXF + 'POLYLINE' + #13;
  DXF := DXF + '8' + #13;                    { Layer Name}
  DXF := DXF + Layer + #13;
  DXF := DXF + '62' + #13;                   { color }
  DXF := DXF + IntToStr(color) + #13;        { Color Chosen }

  DXF := DXF + '70' + #13;                   { Polyline flag (bit-coded; default = 0) }
  DXF := DXF + '10' + #13;                   { start point of a line or text entity }

  DXF := DXF + '66' + #13;                   { Obsolete; formerly an “entities follow flag” (optional; ignore if present) }
  DXF := DXF + '1' + #13;                    { Primary text value for an entity }

  for i := Initial to Final do
  begin
    DXF := DXF + '0' + #13;
    DXF := DXF + 'VERTEX' + #13;
    DXF := DXF + '8' + #13;
    DXF := DXF + Layer + #13;

    DXF := DXF + '10' + #13;                                            { X coordinate }
    DXF := DXF + FloatToStrF(X[i],Format,Precision,Digits) + #13;

    DXF := DXF + '20' + #13;                                            { Y coordinate }
    DXF := DXF + FloatToStrF(Y[i],Format,Precision,Digits) + #13;

    DXF := DXF + '30' + #13;                                            { Z coordinate }
    DXF := DXF + FloatToStrF(Z[i],Format,Precision,Digits) + #13;

    DXF := DXF + '70' + #13;                                            { Polyline flag (bit-coded) Vertex flags: }
    DXF := DXF + '32' + #13;                                            { 32 = 3D polyline vertex }
  end;

  If closed then
  begin
    DXF := DXF + '0' + #13;
    DXF := DXF + 'VERTEX' + #13;
    DXF := DXF + '8' + #13;
    DXF := DXF + Layer + #13;

    DXF := DXF + '10' + #13;                                            { X coordinate }
    DXF := DXF + FloatToStrF(X[1],Format,Precision,Digits) + #13;

    DXF := DXF + '20' + #13;                                            { Y coordinate }
    DXF := DXF + FloatToStrF(Y[1],Format,Precision,Digits) + #13;

    DXF := DXF + '30' + #13;                                            { Z coordinate }
    DXF := DXF + FloatToStrF(Z[1],Format,Precision,Digits) + #13;

    DXF := DXF + '70' + #13;                                            { Polyline flag (bit-coded) Vertex flags: }
    DXF := DXF + '32' + #13;                                            { 32 = 3D polyline vertex }
  end;

  DXF := DXF + '0' + #13;
  DXF := DXF + 'SEQEND' + #13;                                          { END OF POLYLINE }
end;  { WriteonDXFStr_Poly }

procedure WriteonDXFStr_SetofPoly(var DXF : string; Layer : string; color : integer;
                                  PolySet : TWire;
                                  Format : TFloatFormat; Precision, Digits : integer);
var
  i : integer;
begin
  for i := 1 to PolySet.N do
  begin
    WriteonDXFStr_Poly(DXF, Layer, color, PolySet.P[i].Closed,1,PolySet.P[i].Npoly,
                       PolySet.P[i].Npoly,PolySet.P[i].X,PolySet.P[i].Y,PolySet.P[i].Z,
                       Format,Precision,Digits);
  end;
end;  { WriteonDXFStr_SetofPoly }

procedure WriteonDXFStr_3DFace(var DXF : string; Layer : string; color : integer;
                               X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3 : TFloatType;
                               Format : TFloatFormat; Precision, Digits : integer);
begin
  DXF := DXF + '0' + #13;
  DXF := DXF + '3DFACE' + #13;
  DXF := DXF + '8' + #13;
  DXF := DXF + Layer + #13;
  DXF := DXF + '62' + #13;                                              { color }
  DXF := DXF + IntToStr(color) + #13;

  DXF := DXF + '10' + #13;                                              { X1 }
  DXF := DXF + FloatToStrF(X1,Format,Precision,Digits) + #13;
  DXF := DXF + '20' + #13;                                              { Y1 }
  DXF := DXF + FloatToStrF(Y1,Format,Precision,Digits) + #13;
  DXF := DXF + '30' + #13;                                              { Z1 }
  DXF := DXF + FloatToStrF(Z1,Format,Precision,Digits) + #13;

  DXF := DXF + '11' + #13;                                              { X2 }
  DXF := DXF + FloatToStrF(X2,Format,Precision,Digits) + #13;
  DXF := DXF + '21' + #13;                                              { Y2 }
  DXF := DXF + FloatToStrF(Y2,Format,Precision,Digits) + #13;
  DXF := DXF + '31' + #13;                                              { Z2 }
  DXF := DXF + FloatToStrF(Z2,Format,Precision,Digits) + #13;

  DXF := DXF + '12' + #13;                                              { X3 }
  DXF := DXF + FloatToStrF(X3,Format,Precision,Digits) + #13;
  DXF := DXF + '22' + #13;                                              { Y3 }
  DXF := DXF + FloatToStrF(Y3,Format,Precision,Digits) + #13;
  DXF := DXF + '32' + #13;                                              { Z3 }
  DXF := DXF + FloatToStrF(Z3,Format,Precision,Digits) + #13;

  DXF := DXF + '13' + #13;                                              { X3 }
  DXF := DXF + FloatToStrF(X3,Format,Precision,Digits) + #13;
  DXF := DXF + '23' + #13;                                              { Y3 }
  DXF := DXF + FloatToStrF(Y3,Format,Precision,Digits) + #13;
  DXF := DXF + '33' + #13;                                              { Z3 }
  DXF := DXF + FloatToStrF(Z3,Format,Precision,Digits) + #13;
end;  { WriteonDXFStr_3DFace }

procedure FiltroNumerosReais(Palavra : TEdit; Chave: Char; var chaveResult : char);
var
  CurPos : integer;
begin
  If not (Chave in ['0'..'9',',','.','-',#8,#13]) then
    chaveResult:=#0;

  If Chave = '.' then Chave := ',';

  If (Chave in [',','.']) then
    chaveResult := DecimalSeparator;

  if (Chave in ['-']) then
  Begin
    if (Pos(Chave,Palavra.Text) <> Palavra.SelStart) then
    begin
      if Palavra.Text[1]<>'-'  then
      begin
        CurPos:= Palavra.SelStart;
        Palavra.Text:=Chave+Palavra.Text;
        Palavra.SelStart:=CurPos+1;
        chaveResult:=#0;
      end
      else
        chaveResult:=#0;
    end;
  End;

  If (Chave = ',') or (Chave = '.') or (Chave = '-') then
    If Pos(Chave,Palavra.Text) > 0 then
      chaveResult := #0;
end;  { FiltroNumerosReais }

procedure FiltroNumerosInteiros(Palavra : TEdit; Chave: Char; var chaveResult : char);
var
  CurPos : integer;
begin
  If not (Chave in ['0'..'9','-',#8,#13]) then
    chaveResult:=#0;

  If (Chave in ['-']) then
  Begin
    if (Pos(Chave,Palavra.Text) <> Palavra.SelStart) then
    begin
      if Palavra.Text[1]<>'-'  then
      begin
        CurPos:= Palavra.SelStart;
        Palavra.Text:=Chave+Palavra.Text;
        Palavra.SelStart:=CurPos+1;
        chaveResult:=#0;
      end
      else
        chaveResult:=#0;
    end;
  End;
  If (Chave = '-') then
    if Pos(Chave,Palavra.Text) > 0 then
        chaveResult := #0;
end;  { FiltroNumerosInteiros }

procedure FiltroNumerosNaturais(Chave: Char; var chaveResult : char);
begin
 If not (Chave in ['0'..'9',#8,#13]) then
    chaveResult:=#0;
end;  { FiltroNumerosReaisSEdit }

procedure FiltroNumerosReaisPositivos(Palavra : TEdit; Chave: Char; var chaveResult : char);
begin
  If not (Chave in ['0'..'9',',','.',#8,#13]) then
    chaveResult:=#0;

  If Chave = '.' then Chave := ',';

  If (Chave in [',','.']) then
    chaveResult := DecimalSeparator;

  If (Chave = ',') or (Chave = '.') then
    If Pos(Chave,Palavra.Text) > 0 then
      chaveResult := #0;
end;  { FiltroNumerosReaisPositivos }

function SetStrToFloat(const S : string; default : TFloatType) : TFloatType;
begin
  If S <> '' then
    Result := StrToFloat(S)
  Else If S = '' then
    Result := default;
end;  { SetStrToFloat }

function SetStrToRGBFloat(const SR, SG, SB : string; default : TRGBFloat) : TRGBFloat;
begin
  Result.R := SetStrToFloat(SR,default.R);
  Result.G := SetStrToFloat(SG,default.G);
  Result.B := SetStrToFloat(SB,default.B);
end;  { SetStrToFloat }

function SetStrToInt(const S : string; default : integer) : integer;
begin
  If S <> '' then
    Result := StrToInt(S)
  Else If S = '' then
    Result := default;
end;  { SetStrToInt }

function StartStrToFloatDefault(S : string; default : TFloatType; F : TFloatFormat; Precision, Digits : integer) : string;
begin
  If S = '' then
    Result := FloatToStrF(default,F,Precision,Digits)
  Else Result := FloatToStrF(StrToFloat(S),F,Precision,Digits);
end;  { StartStrToFloatDefault }

procedure ReadPoint(XStr,YStr,ZStr : string;
                    Default : T3DPoint; var P : T3DPoint);
begin
  with P do
  begin
    X := SetStrToFloat(XStr,Default.X);
    Y := SetStrToFloat(YStr,Default.Y);
    Z := SetStrToFloat(ZStr,Default.Z);
  end;
end;  { ReadPoint }

procedure ReadPoint(XStr,YStr,ZStr : string; XDefault,YDefault,ZDefault : TFloatType;
                    var X, Y, Z : TFloatType);
begin
  X := SetStrToFloat(XStr,XDefault);
  Y := SetStrToFloat(YStr,YDefault);
  Z := SetStrToFloat(ZStr,ZDefault);
end;  { ReadPoint }

function ExtractNaturalStr(S : string) : string;
var                           { Extrai caracteres numéricos de um conjunto de caracteres }
  i, Lstr, CurPos : integer;
  chln : char;
begin
  Lstr := length(S);

  for i := 1 to Lstr do
  begin
    chln := S[i];
    If (chln in ['0'..'9']) then
      Result := Result + chln;
  end;
end;  { ExtractNaturalStr }

function EvaluateFloatStr(Start : integer; S : string) : TFloatType;
var                      { Extrai um número real, positivo ou negativo, de um conjunto de caracteres }
  i, Lstr, DeciPos, Finish : integer;
  chln : char;
  Positive : boolean;
  Str : string;
begin
  Result := 0;
  Str := ExtractFloatStr(Start, S, Finish);
  If Str <> '' then
    Result := StrToFloat(Str);
    
  (*Result := 0;
  Lstr := length(S);
  Positive := True;
  Start := -1; Finish := -1; DeciPos := -1;
  Str := '';
  for i := 1 to Lstr do
  begin
    chln := S[i];
    If (chln in ['0'..'9']) then
      Str := Str + chln;

    If (chln in ['0'..'9']) and (Start = -1) then
      Start := i;

    If (Start <> - 1) and (Finish = -1) then
      If (chln = ',') or (chln = '.') then
        DeciPos := i;

    If (not(chln in ['0'..'9'])) and (Start <> -1) and (DeciPos <> -1) and (Finish = -1) then
      Finish := i-1;

    If chln = '-' then
      Positive := False;
  end;
  If (Str <> '') then
  begin
    Result := StrToFloat(Str);
    If Positive = False then
      Result := -Result;
    If DeciPos <> -1 then
    begin
      If Finish-DeciPos > 0 then
      Result := Result/Power(10,Finish-DeciPos);
    end;
  end;*)
end;  { EvaluateFloatStr }

function ExtractFloatStr(Start : integer; S : string; var Last : integer) : string;
var
  i, Lstr : integer;
  chln : char;
  str_acm : string;
  Numeric, Sign, DeciSep, Exponent : boolean;
begin
  Numeric := False;  Sign := False;  DeciSep := False;  Exponent := False;
  Lstr := length(S);

  If (Start > 0) and (Start <= Lstr) then
    i := Start-1
  Else i := 0;

  Last := -1;  chln := #0;
  str_acm := '';
  repeat
  begin
    i := i + 1;
    chln := S[i];
    //ShowMessage('str_acm['+IntToStr(i)+'] = '+str_acm+'P');
    If Last = -1 then
    begin

      If chln = '-' then
      begin
        { Signs will only count if they are the first element }
        If (str_acm = '') then    { Signs can only be added at the leftmost position }
        begin
          Sign := True;
          str_acm := str_acm + chln;
        end
        { If there's something already registered as number, a right-side Sign will mean two things }
        Else begin
          { Signs cannot be added at the right side of any number or Decimal Separator }
          If Numeric = True then   { End of the reading, in case there's already a valid series of digits }
          begin
            {Last := i-1;}              { ex.: -1.20----; -.20--- }
            If i > 1 then
            begin
              If (S[i-1] = 'E') or (S[i-1] = 'e') then
                str_acm := str_acm + chln
              Else begin
                Last := i-1;
              end;
            end;
          end
          Else begin               { A mixture of various characters without numeric logic}
            str_acm := '';         { So start over the reading }
            Sign := False;         { ex.: -.--- }
          end;
        end;
      end;
      If (chln in ['.',',']) then
      begin
        If (DeciSep = False) then        { Decimal Separators can only be added once }
        begin
          str_acm := str_acm + DecimalSeparator;
          DeciSep := True;
        end
        { If a Decimal Separator was already accounted, a second one will mean two things }
        Else begin
          If Numeric = True then   { End of the reading, in case there's already a valid series of digits }
            Last := i-1              { ex.: -1.20...; -0.20. }
          Else begin               { A mixture of various characters without numeric logic }
            str_acm := '';         { So start over the reading }
            DeciSep := False;      { ex.: -... }
          end;
        end;
      end;

      If (chln in ['0'..'9']) then
      begin
        Numeric := True;            { Numbers can be added after any other characters, be it Sign and/or Decimal Separator }
        str_acm := str_acm + chln;  { Ex.: -1; -2.1; -.1; -1. }
      end;

      If (chln = 'E') or (chln = 'e') then
      begin
        If Exponent = False then
        begin
          If Numeric = True then    { E for the power of 10 can only be added once and after a series of digits }
          begin                     { Ex.: 1.0E10; -.0E2; -4.E3 }
            str_acm := str_acm + chln;
            Exponent := True;
          end
          Else begin                { The abscense of a previous series of digits does not allow the insertion of E }
            str_acm := '';          { E cannot start a floating point number and cannot succeed a sign or }
          end;                      { decimal separator if there isn't any previous number }
        end                         { Ex.: -.E; .E; -E; E }
        Else begin
          Last := i-1;              { E cannot appear twice. A second one means the end of the reading }
        end;
      end;

      If chln = '+' then            { Plus (+) sign will only be registered after a valid exponential E character }
      begin
        If (i > 1) and (Exponent = True) then
        begin
          If (S[i-1] = 'E') or (S[i-1] = 'e') then
            str_acm := str_acm + chln
          Else begin                
            Last := i-1;            { If it's added after anything other than E, the reading ends }
          end;
        end;
        If Exponent = False then
        begin
          If (Numeric = True) then
          begin
            Last := i-1;            { If it's added after anything other than E, the reading ends }
          end
          Else begin
            str_acm := '';          { If it's added after anything other than E, and if there isn't any }
            Exponent := False;      { valid series of digits, the reading restarts }
          end;
        end;
      end;

      { If any character except the ones from the Floating Point System are added }
      If not (chln in ['0'..'9','-','+',',','.','E','e']) then
      begin
        { After an already accounted valid series of digits }
        If (str_acm <> '') then
        begin
          If (Numeric = True) then
            Last := i-1             { End of the reading. Ex.: -1.20A; -.20%; 120# }
          Else begin
            str_acm := '';
            Sign := False;  DeciSep := False;  Exponent := False;
          end;
        end;
      end;
    end;
    //ShowMessage('i = '+IntToStr(i)+#13+str_acm+'P');
  end;
  until((Last <> -1) or (i = Lstr));

  If (i = Lstr) and (Numeric = True) then
    Last := i;

  { The Loop does not filter the case when no number is inserted after E, E- or E+ }
  { So it's necessary to check and remove if E,E-,E+,e,e-,e+ are the last characters }
  If Last <> -1 then
  begin
    Lstr := length(str_acm);
    If (str_acm[Lstr] = '+') or (str_acm[Lstr] = '-') then
    begin
      SetLength(str_acm,Lstr-1);
      Last := Last - 1;
    end;

    Lstr := length(str_acm);
    If (str_acm[Lstr] = 'E') or (str_acm[Lstr] = 'e') then
    begin
      SetLength(str_acm,Lstr-1);
      Last := Last - 1;
    end;

    Result := str_acm;
  end
  Else Result := '';
end;  { ExtractFloatStr }

procedure ExtractFloatVectorStr(Str : string; var N : integer; var FloatVector : TVetorN);
var                                     { Extract floating point numbers from string reading from left to right }
  i, j, k, Lstr, Lstr1 : integer;       { Register the numbers in FloatVector as the type TVetorN }
  char1 : char;                         { Register the amount of numbers found as the integer N }
  str_acm : string;
begin
  Str := AdjustLineBreaks(Str,tlbsCRLF);
  Lstr := length(Str);
  Lstr1 := 0;
  char1 := #0;

  i := 1; j := 0; k := 0; str_acm := '';
  SetLength(FloatVector,j+1);
  repeat
  begin
    If (i <= Lstr) then
    begin
      str_acm := ExtractFloatStr(i, Str, k);
      Lstr1 := length(str_acm);
      If (Lstr1 > 0) and (str_acm <> '') then
      begin
        j := j + 1;
        SetLength(FloatVector,j+1);
        FloatVector[j] := StrToFloat(str_acm);
        i := k + 1;
      end
      Else i := i + 1;
    end;
  end;
  until(i > Lstr);
  N := j;
end;  { ExtractFloatVectorStr }

function FindChar(C : char; S : string) : boolean;
var                    { Finds a Char C in a String S }
  i, Lstr : integer;
  chln : char;
begin
  i := 0;
  Result := False;
  Lstr := length(S);
  repeat
  begin
    i := i + 1;
    chln := S[i];
    If chln = C then
      Result := True;
  end;
  until((Result = True) or (i = Lstr));
end;  { FindChar }

function FindFirstNatural(S : string; var Pos : integer) : integer;
var                   { Finds the position Pos of the first numeric }
  i, Lstr : integer;  { character of a string S and its value as }
  chln : char;        { the Result }
begin
  i := 0;
  Result := 0;
  Pos := -1;
  Lstr := length(S);
  repeat
  begin
    i := i + 1;
    chln := S[i];
    If (chln in ['0'..'9']) then
    begin
      Result := StrToInt(chln);
      Pos := i;
    end;
  end;
  until((Pos > 0) or (i = Lstr));
end;  { FindFirstNatural }

function FindString(S: string; Source : string) : boolean;
var
  i, j, LSource, Lstr : integer;
  StrC : string;
begin
  Source := AdjustLineBreaks(Source,tlbsCRLF);
  Result := False;
  LSource := length(Source);  Lstr := length(S);
  i := 0;  j := 0;  StrC := '';
  If LSource > Lstr then
  begin
    repeat
    begin
      i := i + 1;
      j := i-1;
      StrC := '';
      repeat
      begin
        j := j + 1;
        StrC := StrC + Source[j];
      end;
      until((j-i+1)=Lstr);
      //ShowMessage(StrC);
      If StrC = S then
        Result := True;
    end;
    until((Result = True) or (i = LSource-Lstr+1));
  end;
end;  { FindString }

{---------------------------------------------------------------------------------------------------}
{                                           TPPline                                                 }
{                                                                                                   }
{ TPPline class to gather all algorithms related to the construction of 2D polylines                }
{---------------------------------------------------------------------------------------------------}

class procedure TPPline.Reference_Pline(XOrigin, YOrigin : TFloatType; var Poly : TPline);
var                      { Altera o referencial de uma Polyline 2D }
  i : integer;
begin
  for i := 1 to Poly.Npoly do
  begin
    Poly.X[i] := Poly.X[i] - XOrigin;
    Poly.Y[i] := Poly.Y[i] - YOrigin;
  end;
end;  { TPPline.Reference_Pline }

class procedure TPPline.Move_Pline(X, Y : TFloatType; var Poly : TPline);
var                      { Translada uma Polyline 2D pelo vetor (X,Y) }
  i : integer;
begin
  for i := 1 to Poly.Npoly do
  begin
    Poly.X[i] := Poly.X[i] + X;
    Poly.Y[i] := Poly.Y[i] + Y;
  end;
end;  { TPPline.Move_Pline }

class function TPPline.Gap(Poly : TPline) : boolean;
begin          { Verifica se a Polyline 2D é aberta (True) ou fechada (False) }
  If (Equal(Poly.X[1],Poly.X[Poly.Npoly],RelPrecision)) and
     (Equal(Poly.Y[1],Poly.Y[Poly.Npoly],RelPrecision)) then
    Result := False    { Poligonal Fechada }
  Else
    Result := True;    { Poligonal Aberta }
end;  { TPPline.Gap }

class function TPPline.Gap(Poly : TPlineIN) : boolean;
begin          { Verifica se a Polyline 2D é aberta (True) ou fechada (False) }
  If (Poly.X[1]=Poly.X[Poly.Npoly]) and
     (Poly.Y[1]=Poly.Y[Poly.Npoly]) then
    Result := False    { Poligonal Fechada }
  Else
    Result := True;    { Poligonal Aberta }
end;  { TPPline.Gap }

class function TPPline.AddPoint(Poly : TPline; X, Y : TFloatType; N : integer) : TPline;
var                    { Acrescenta ponto (X,Y) a Polyline }
  i : integer;         { a frente da posição N da Polyline }
  repeated : boolean;
begin
  repeated := False;
  If Poly.Npoly > 0 then
    for i := 1 to Poly.Npoly do
      If (Equal(X,Poly.X[i],RelPrecision)) and (Equal(Y,Poly.Y[i],RelPrecision)) then
        repeated := True;

  If repeated then
  begin
    Result := Poly;
  end
  Else If repeated = False then
  begin
    Result.Npoly := Poly.Npoly+1;
    SetLength(Result.X,Result.Npoly+1);  SetLength(Result.Y,Result.Npoly+1);

    If (1<=N) and (N<=Poly.Npoly-1) then
    begin
      for i := 1 to N do
      begin
        Result.X[i] := Poly.X[i];  Result.Y[i] := Poly.Y[i];
      end;
      Result.X[N+1] := X;  Result.Y[N+1] := Y;
      for i := N+2 to Result.Npoly do
      begin
        Result.X[i] := Poly.X[i-1];  Result.Y[i] := Poly.Y[i-1];
      end;
    end
    Else If N = 0 then
    begin
      for i := 1 to Poly.Npoly do
      begin
        Result.X[i+1] := Poly.X[i];  Result.Y[i+1] := Poly.Y[i];
      end;
      Result.X[1] := X;  Result.Y[1] := Y;
    end
    Else If N = Poly.Npoly then
    begin
      for i := 1 to Poly.Npoly do
      begin
        Result.X[i] := Poly.X[i];  Result.Y[i] := Poly.Y[i];
      end;
      Result.X[Poly.Npoly+1] := X;  Result.Y[Poly.Npoly+1] := Y;
    end;
    Result.Closed := not Gap(Result);
  end;

end;  { TPPline.AddPoint }

class function TPPline.AddPoint(Poly : TPlineIN; X, Y : integer; N : integer) : TPlineIN;
var                    { Acrescenta ponto (X,Y) a Polyline }
  i : integer;         { a frente da posição N da Polyline }
  repeated : boolean;
begin
  repeated := False;
  If Poly.Npoly > 0 then
    for i := 1 to Poly.Npoly do
      If (X = Poly.X[i]) and (Y = Poly.Y[i]) then
        repeated := True;

  If repeated then
  begin
    Result := Poly;
  end
  Else If repeated = False then
  begin
    Result.Npoly := Poly.Npoly+1;
    SetLength(Result.X,Result.Npoly+1);  SetLength(Result.Y,Result.Npoly+1);

    If (1<=N) and (N<=Poly.Npoly-1) then
    begin
      for i := 1 to N do
      begin
        Result.X[i] := Poly.X[i];  Result.Y[i] := Poly.Y[i];
      end;
      Result.X[N+1] := X;  Result.Y[N+1] := Y;
      for i := N+2 to Result.Npoly do
      begin
        Result.X[i] := Poly.X[i-1];  Result.Y[i] := Poly.Y[i-1];
      end;
    end
    Else If N = 0 then
    begin
      for i := 1 to Poly.Npoly do
      begin
        Result.X[i+1] := Poly.X[i];  Result.Y[i+1] := Poly.Y[i];
      end;
      Result.X[1] := X;  Result.Y[1] := Y;
    end
    Else If N = Poly.Npoly then
    begin
      for i := 1 to Poly.Npoly do
      begin
        Result.X[i] := Poly.X[i];  Result.Y[i] := Poly.Y[i];
      end;
      Result.X[Poly.Npoly+1] := X;  Result.Y[Poly.Npoly+1] := Y;
    end;
    Result.Closed := not Gap(Result);
  end;

end;  { TPPline.AddPoint }

class procedure TPPline.RemovePoint(N : integer; X, Y : TVetorN; Npt : integer;
                                    var NResult : integer; var XResult, YResult : TVetorN);
var                        { Remove o ponto Npt da polyline (X,Y) }
  i : integer;
begin
  NResult := N-1;
  SetLength(XResult,NResult+1);  SetLength(YResult,NResult+1);

  If (1<=NPt) and (NPt<N) then
  begin
    for i := 1 to NPt do
    begin
      XResult[i] := X[i];
      YResult[i] := Y[i];
    end;
    for i := NPt to N-1 do
    begin
      XResult[i] := X[i+1];
      YResult[i] := Y[i+1];
    end;
  end
  Else If NPt = N then
  begin
    for i := 1 to N-1 do
    begin
      XResult[i] := X[i];
      YResult[i] := Y[i];
    end;
  end;
end;  { TPPline.RemovePoint }

class function TPPline.Join(Poly_1 : TPline; Poly_2 : TPline) : TPline;
var                { Une as poligonais Poly_1 e Poly_2 em uma Result, }
  i : integer;     { adicionando os pontos de Poly_2 a Poly_1 a partir }
begin              { da extremidade final de Poly_1 }
  Result := Poly_1;

  If (Poly_1.X[Poly_1.Npoly] = Poly_2.X[1]) and (Poly_1.Y[Poly_1.Npoly] = Poly_2.Y[1]) then
    Result.Npoly := Poly_1.Npoly + Poly_2.Npoly - 1
  Else
    Result.Npoly := Poly_1.Npoly + Poly_2.Npoly;

  SetLength(Result.X,Result.Npoly+1);   SetLength(Result.Y,Result.Npoly+1);
  for i := Poly_1.Npoly+1 to Result.Npoly do
  begin
    Result.X[i] := Poly_2.X[i-Result.Npoly+Poly_2.Npoly];
    Result.Y[i] := Poly_2.Y[i-Result.Npoly+Poly_2.Npoly];
  end;
end;  { TPPline.Join }

class procedure TPPline.RemoveRepeatedPts(N : integer; X, Y : TVetorN;
                                          var NResult : integer; var XResult, YResult : TVetorN);
var                              { Remove todos os pontos repetidos da polyline (X,Y) }
  i, j, k : integer;
  P_Aux : TVetorIN;
begin
  If N > 1 then
  begin
    k := 0;
    for i := 1 to N-1 do
    begin
      for j := i+1 to N do
      begin
        If Equal(X[i],X[j],RelPrecision) and
           Equal(Y[i],Y[j],RelPrecision) then
        begin
          k := k + 1;
          SetLength(P_Aux,k+1);
          P_Aux[k] := j;
        end;
      end;
    end;

    for i := 1 to k do
    begin
      RemovePoint(N,X,Y,P_Aux[i],NResult,XResult,YResult);
      N := NResult;
      X := XResult;  Y := YResult;
      for j := i to k do
        if P_Aux[j] > P_Aux[i] then
          P_Aux[j] := P_Aux[j]-1;
    end;
  end
  Else begin
    NResult := N;  XResult := X;  YResult := Y;
  end;
end;  { TPPline.RemoveRepeatedPts }

class function TPPline.Area(Poly : TPline) : TFloatType;
var                                    { Calcula somatório de áreas de triângulos formados }
  i, N : integer;                      { pelo primeiro ponto de Poly e seus demais pontos }
  X1,Y1,X2,Y2,X3,Y3 : TFloatType;   { i e i+1 (i = 2 a N-1) }
begin
  If Poly.Closed = False then
    N := Poly.Npoly
  Else N := Poly.Npoly-1;

  If N > 2 then
  Begin
    X1 := Poly.X[1];  Y1 := Poly.Y[1];
    Result := 0;
    for i := 2 to N-1 do
    begin
      X2 := Poly.X[i];    Y2 := Poly.Y[i];
      X3 := Poly.X[i+1];  Y3 := Poly.Y[i+1];
      Result := Result + (1/2)*ProdutoVetorial2D(X3-X1,Y3-Y1,X2-X1,Y2-Y1);
    end;
  End
  Else Result := 0;
end;  { TPPline.Area }

class function TPPline.CCW(Poly : TPline) : boolean;
begin               { Check if Poly is on CCW (True) way or CW (False) }
  Result := False;
  If TPPline.Area(Poly) >= 0 then       { CCW }
    Result := True
  Else Result := False;                 { CW }
end;  { TPPline.CCW }

class function TPPline.PointFromPolyline(Poly : TPlineIN; X, Y : Integer; T : integer) : integer;
var
  i : integer;
begin
  Result := 0;
  for i := 1 to Poly.Npoly do
  begin
    if ((Poly.X[i]-T)<=X) and (X<=(Poly.X[i]+T)) and
       ((Poly.Y[i]-T)<=Y) and (Y<=(Poly.Y[i]+T)) then
    begin
      Result := i;
    end;
  end;
end; { TPPline.PointFromPolyline }

class function TPPline.Sym_MainAxis(Poly : TPline; X, Y : boolean) : TPline;
var                 { Rebate Poly em relação a um dos eixos (X ou Y) }
  i : integer;      { de seu sistema de referência }
begin
  Result.Npoly := Poly.Npoly;
  SetLength(Result.X,Result.Npoly+1);
  SetLength(Result.Y,Result.Npoly+1);
  Result.Closed := Poly.Closed;
  for i := 1 to Poly.Npoly do
  begin
    If X then
      Result.X[i] := -Poly.X[i]
    Else If X = False then
      Result.X[i] := Poly.X[i];
    If Y then
      Result.Y[i] := -Poly.Y[i]
    Else If Y = False then
      Result.Y[i] := Poly.Y[i];
  end;
end;  { TPPline.Sym_MainAxis }

class function TPPline.Reset(Poly : TPline) : TPline;
begin
  Poly.Npoly := 0;  Poly.ortplan := 1;
  Poly.Closed := False;
  SetLength(Poly.X,1);  SetLength(Poly.Y,1);
  Result := Poly;
end;  { TPPline.Reset }

class function TPPline.Reset(Poly : TPlineIN) : TPlineIN;
begin
  Poly.Npoly := 0;  Poly.ortplan := 1;
  Poly.Closed := False;
  SetLength(Poly.X,1);  SetLength(Poly.Y,1);
  Result := Poly;
end;  { TPPline.Reset }

class procedure TPPline.Scan_Min(NPoly : integer; X, Y : TVetorN; DirectionScan : char;
                        Scan : TFloatType; var NResult : boolean; var ScanResult : TFloatType);
var                           { Determina se existe interseção entre a linha de grade na direção dada }
  i, j : integer;             { por DirectionScan e fornece o valor da mínima interseção ScanResult. }
  V_c : array of double;      { Se não houver interseção, NResult é False e ScanResult é zero. }
begin
  If DirectionScan = 'X' then          { Linha de Scan Vertical }
  begin
    j := 0;
    NResult := False;
    for i := 1 to NPoly-1 do
    begin
      If BetweenEq(Scan,X[i],X[i+1],RelPrecision) then
      begin                    { Interseções com Scan }
        NResult := True;
        SetLength(V_c,j+1);
        V_c[j] := Linear_Interpolation(Scan,X[i],Y[i],X[i+1],Y[i+1]);
        j := j + 1;
      end;
    end;
    If j <> 0 then             { Armazenamento da Mínima Interseção }
      ScanResult := MinValue(V_c)
    Else If j = 0 then
      ScanResult := 0;
  end
  Else If DirectionScan = 'Y' then     { Linha de Scan Horizontal }
  begin
    j := 0;
    NResult := False;
    for i := 1 to NPoly-1 do
    begin
      If BetweenEq(Scan,Y[i],Y[i+1],RelPrecision) then
      begin                    { Interseções com Scan }
        NResult := True;
        SetLength(V_c,j+1);
        V_c[j] := Linear_Interpolation(Scan,Y[i],X[i],Y[i+1],X[i+1]);
        j := j + 1;
      end;
    end;
    If j <> 0 then             { Armazenamento da Mínima Interseção }
      ScanResult := MinValue(V_c)
    Else If j = 0 then
      ScanResult := 0;
  end;

end;  { TPPline.Scan_Min }

class procedure TPPline.Scan_Max(NPoly : integer; X, Y : TVetorN; DirectionScan : char;
                        Scan : TFloatType; var NResult : boolean; var ScanResult : TFloatType);
var                           { Determina se existe interseção entre a linha de grade na direção dada }
  i, j : integer;             { por DirectionScan e fornece o valor da máxima interseção ScanResult. }
  V_c : array of double;      { Se não houver interseção, NResult é False e ScanResult é zero. }
begin
  If DirectionScan = 'X' then          { Linha de Scan Vertical }
  begin
    j := 0;
    NResult := False;
    for i := 1 to NPoly-1 do
    begin
      If BetweenEq(Scan,X[i],X[i+1],RelPrecision) then
      begin                    { Interseções com Scan }
        NResult := True;
        SetLength(V_c,j+1);
        V_c[j] := Linear_Interpolation(Scan,X[i],Y[i],X[i+1],Y[i+1]);
        j := j + 1;
      end;
    end;
    If j <> 0 then             { Armazenamento da Mínima Interseção }
      ScanResult := MaxValue(V_c)
    Else If j = 0 then
      ScanResult := 0;
  end
  Else If DirectionScan = 'Y' then     { Linha de Scan Horizontal }
  begin
    j := 0;
    NResult := False;
    for i := 1 to NPoly-1 do
    begin
      If BetweenEq(Scan,Y[i],Y[i+1],RelPrecision) then
      begin                    { Interseções com Scan }
        NResult := True;
        SetLength(V_c,j+1);
        V_c[j] := Linear_Interpolation(Scan,Y[i],X[i],Y[i+1],X[i+1]);
        j := j + 1;
      end;
    end;
    If j <> 0 then             { Armazenamento da Mínima Interseção }
      ScanResult := MaxValue(V_c)
    Else If j = 0 then
      ScanResult := 0;
  end;

end;  { TPPline.Scan_Max }

class function TPPline.MultiPoly_Scan_Min(MPol : TWire; PolyDirection : char; NPolyInitial : integer;
                            DirectionScan : char; Scan : TFloatType) : TPline;
var                          { Determina a poligonal de interseção entre a linha de grade na direção }
  i : integer;            { dada por DirectionScan e a série de poligonais MPol. }
  aux_TF : boolean;          { PolyDirection indica a direção em que as poligonais são paralelas. }
  varaux : TFloatType;
begin
  Result.Npoly := NPolyInitial;
  If PolyDirection = 'X' then
  begin
    for i := 1 to MPol.N do
    begin
      Scan_Min(MPol.P[i].Npoly,MPol.P[i].Y,MPol.P[i].Z,DirectionScan,Scan,aux_TF,varaux);
      If aux_TF then
      begin
        Result.Npoly := Result.Npoly + 1;
        SetLength(Result.X,Result.Npoly+1);  SetLength(Result.Y,Result.Npoly+1);
        Result.X[Result.Npoly] := MPol.P[i].X[1];    Result.Y[Result.Npoly] := varaux;
      end;
    end;
  end
  Else If PolyDirection = 'Y' then
  begin
    for i := 1 to MPol.N do
    begin
      Scan_Min(MPol.P[i].Npoly,MPol.P[i].X,MPol.P[i].Z,DirectionScan,Scan,aux_TF,varaux);
      If aux_TF then
      begin
        Result.Npoly := Result.Npoly + 1;
        SetLength(Result.X,Result.Npoly+1);  SetLength(Result.Y,Result.Npoly+1);
        If DirectionScan = 'X' then
        begin
          Result.X[Result.Npoly] := MPol.P[i].Y[1];    Result.Y[Result.Npoly] := varaux;
        end
        Else If DirectionScan = 'Y' then
        begin
          Result.X[Result.Npoly] := varaux;    Result.Y[Result.Npoly] := MPol.P[i].Y[1];
        end;

      end;
    end;
  end
  Else If PolyDirection = 'Z' then
  begin
    for i := 1 to MPol.N do
    begin
      Scan_Min(MPol.P[i].Npoly,MPol.P[i].X,MPol.P[i].Y,DirectionScan,Scan,aux_TF,varaux);
      If aux_TF then
      begin
        Result.Npoly := Result.Npoly + 1;
        SetLength(Result.X,Result.Npoly+1);  SetLength(Result.Y,Result.Npoly+1);
        Result.X[Result.Npoly] := varaux;    Result.Y[Result.Npoly] := MPol.P[i].Z[1];
      end;
    end;
  end;

end;  { TPPline.MultiPoly_Scan_Min }

class procedure TPPline.ScanGrid_Min(NPoly : integer; X, Y : TVetorN; DirectionScan : char; NScan : integer;
                        Grid : TVetorN; var NResult : TVetorBN; var ScanResult : TVetorN);
var                           { Determina se existe interseção entre as linhas de grade na direção dada }
  i, j, k : integer;          { por DirectionScan e fornece o valor da mínima interseção ScanResult. }
  V_c : array of double;      { Se não houver interseção, NResult é False e ScanResult é zero. }
begin
  SetLength(NResult,NScan+1);
  SetLength(ScanResult,NScan+1);
  If DirectionScan = 'X' then          { Linhas de Scan Verticais }
  begin
    for i := 1 to NScan do
    begin
      k := 0;
      NResult[i] := False;
      for j := 1 to NPoly-1 do
      begin
        If BetweenEq(Grid[i],X[j],X[j+1],RelPrecision) then
        begin                    { Interseções com Grid }
          NResult[i] := True;
          SetLength(V_c,k+1);
          V_c[k] := Linear_Interpolation(Grid[i],X[j],Y[j],X[j+1],Y[j+1]);
          k := k + 1;
        end;
      end;
      If k <> 0 then             { Armazenamento da Mínima Interseção }
        ScanResult[i] := MinValue(V_c)
      Else If k = 0 then
        ScanResult[i] := 0;
    end;
  end
  Else If DirectionScan = 'Y' then     { Linhas de Scan Horizontais }
  begin
    for i := 1 to NScan do
    begin
      k := 0;
      NResult[i] := False;
      for j := 1 to NPoly-1 do
      begin
        If BetweenEq(Grid[i],Y[j],Y[j+1],RelPrecision) then
        begin                    { Interseções com Grid }
          NResult[i] := True;
          SetLength(V_c,k+1);
          V_c[k] := Linear_Interpolation(Grid[i],Y[j],X[j],Y[j+1],X[j+1]);
          k := k + 1;
        end;
      end;
      If k <> 0 then             { Armazenamento da Mínima Interseção }
        ScanResult[i] := MinValue(V_c)
      Else If k = 0 then
        ScanResult[i] := 0;
    end;
  end;

end;  { TPPline.ScanGrid_Min }

class procedure TPPline.ScanGrid_Max(NPoly : integer; X, Y : TVetorN; DirectionScan : char; NScan : integer;
                        Grid : TVetorN; var NResult : TVetorBN; var ScanResult : TVetorN);
var                           { Determina se existe interseção entre as linhas de grade na direção dada }
  i, j, k : integer;          { por DirectionScan e fornece o valor da máxima interseção ScanResult. }
  V_c : array of double;      { Se não houver interseção, NResult é False e ScanResult é zero. }
begin
  SetLength(NResult,NScan+1);
  SetLength(ScanResult,NScan+1);
  If DirectionScan = 'X' then          { Linhas de Scan Verticais }
  begin
    for i := 1 to NScan do
    begin
      k := 0;
      NResult[i] := False;
      for j := 1 to NPoly-1 do
      begin
        If BetweenEq(Grid[i],X[j],X[j+1],RelPrecision) then
        begin                    { Interseções com Grid }
          NResult[i] := True;
          SetLength(V_c,k+1);
          V_c[k] := Linear_Interpolation(Grid[i],X[j],Y[j],X[j+1],Y[j+1]);
          k := k + 1;
        end;
      end;

      If k <> 0 then             { Armazenamento da Máxima Interseção }
        ScanResult[i] := MaxValue(V_c)
      Else If k = 0 then
        ScanResult[i] := 0;
    end;
  end
  Else If DirectionScan = 'Y' then     { Linhas de Scan Horizontais }
  begin
    for i := 1 to NScan do
    begin
      k := 0;
      NResult[i] := False;
      for j := 1 to NPoly-1 do
      begin
        If BetweenEq(Grid[i],Y[j],Y[j+1],RelPrecision) then
        begin                    { Interseções com Grid }
          NResult[i] := True;
          SetLength(V_c,k+1);
          V_c[k] := Linear_Interpolation(Grid[i],Y[j],X[j],Y[j+1],X[j+1]);
          k := k + 1;
        end;
      end;
      If k <> 0 then             { Armazenamento da Máxima Interseção }
        ScanResult[i] := MaxValue(V_c)
      Else If k = 0 then
        ScanResult[i] := 0;
    end;
  end;

end;  { TPPline.ScanGrid_Max }

class procedure TPPline.ScanGrid(NPoly : integer; X, Y : TVetorN; DirectionScan : char; NScan : integer;
                        Grid : TVetorN; var GridResult, ScanResult : TMatrizNxN;
                        var NScanResult : TVetorIN; var NResult : integer);
var                        { Determina todas as possíveis interseções entre as linhas de grade, }
  i, j, l : integer;       { se existirem, e a poligonal (X,Y). GridResult representa a linha }
begin                      { de grade correspondente a uma determinada interseção ScanResult. }
                           { A quantidade de interseções por linha de grade é NScanResult. }
                           { NResult é a quantidade de linhas de grade. }
  SetLength(NScanResult,NScan+1);  SetLength(GridResult,NScan+1);  SetLength(ScanResult,NScan+1);
  NResult := NScan;

  If DirectionScan = 'X' then          { Linhas de Scan Verticais }
  begin
    for i := 1 to NScan do
    begin
      l := 0;
      for j := 1 to NPoly-1 do
      begin
        If BetweenEq(Grid[i],X[j],X[j+1],RelPrecision) then
        begin                    { Interseções com Grid }
          l := l + 1;
          NScanResult[i] := l;
          SetLength(GridResult[i],l+1);  SetLength(ScanResult[i],l+1);
          GridResult[i,l] := Grid[i];
          ScanResult[i,l] := Linear_Interpolation(Grid[i],X[j],Y[j],X[j+1],Y[j+1]);
        end;
      end;
      NScanResult[i] := l;
    end;
  end
  Else If DirectionScan = 'Y' then     { Linhas de Scan Horizontais }
  begin
    for i := 1 to NScan do
    begin
      l := 0;
      for j := 1 to NPoly-1 do
      begin
        If BetweenEq(Grid[i],Y[j],Y[j+1],RelPrecision) then
        begin                    { Interseções com Grid }
          l := l + 1;
          NScanResult[i] := l;
          SetLength(GridResult[i],l+1);  SetLength(ScanResult[i],l+1);
          GridResult[i,l] := Grid[i];
          ScanResult[i,l] := Linear_Interpolation(Grid[i],Y[j],X[j],Y[j+1],X[j+1]);
        end;
      end;
      NScanResult[i] := l;
    end;
  end;

end;  { TPPline.ScanGrid }

class function TPPline.PointsToPline(NPts : integer; Xi, Yi, Xf, Yf : TFloatType;
                                     X, Y : TVetorN; Closed : boolean) : TPline;
var                                { Transforma conjunto de pontos em uma Poligonal }
  i, j, k : integer;               { sequenciando pontos por menor distância }
  initial, final : integer;
  varaux, Dist, DistMin : TFloatType;
begin
  { Identifica posição dos pontos iniciais e finais fornecidos }
  initial := 0;  final := 0;
  for i := 1 to NPts do
  begin
    If (X[i]=Xi) and (Y[i]=Yi) then
      initial := i;
    If (X[i]=Xf) and (Y[i]=Yf) then
      final := i;
  end;
  { Posiciona ponto inicial como primeiro da série de pontos }
  If initial <> 1 then
  begin
    varaux := X[1];
    X[1] := Xi;
    X[initial] := varaux;

    varaux := Y[1];
    Y[1] := Yi;
    Y[initial] := varaux;
  end;
  { Posiciona ponto final como último da série de pontos }
  If final <> Npts then
  begin
    varaux := X[Npts];
    X[Npts] := Xf;
    X[final] := varaux;

    varaux := Y[Npts];
    Y[Npts] := Yf;
    Y[final] := varaux;
  end;

  for i := 1 to NPts-2 do
  begin
    { Determina o ponto de menor distância a (X[i],Y[i]) }
    k := i+1;
    DistMin := Dist_Points(X[i],Y[i],0,X[k],Y[k],0);
    for j := i+1 to NPts-1 do
    begin
      Dist := Dist_Points(X[i],Y[i],0,X[j],Y[j],0);
      If Dist < DistMin then
      begin
        DistMin := Dist;
        k := j;
      end;
    end;
    { Posiciona ponto de menor distância a frente de (X[i],Y[i]) }
    If k <> i+1 then
    begin
      varaux := X[i+1];
      X[i+1] := X[k];
      X[k] := varaux;

      varaux := Y[i+1];
      Y[i+1] := Y[k];
      Y[k] := varaux;
    end;
  end;

  { Armazena Pontos Ordenados como Polyline }
  If Closed = False then
  begin
    Result.Npoly := NPts;
    Result.Closed := False;
    SetLength(Result.X,Result.Npoly+1);  SetLength(Result.Y,Result.Npoly+1);
    for i := 1 to NPts do
    begin
      Result.X[i] := X[i];  Result.Y[i] := Y[i];
    end;
  end
  Else If Closed then
  begin
    If (Xi <> Xf) and (Yi <> Yf) then
    begin
      Result.Npoly := NPts+1;
      Result.Closed := True;
      SetLength(Result.X,Result.Npoly+1);  SetLength(Result.Y,Result.Npoly+1);
      for i := 1 to NPts do
      begin
        Result.X[i] := X[i];  Result.Y[i] := Y[i];
      end;
      Result.X[NPts+1] := X[1];  Result.Y[NPts+1] := Y[1];
    end
    Else If (Xi = Xf) and (Yi = Yf) then
    begin
      Result.Npoly := NPts;
      Result.Closed := True;
      SetLength(Result.X,Result.Npoly+1);  SetLength(Result.Y,Result.Npoly+1);
      for i := 1 to NPts do
      begin
        Result.X[i] := X[i];  Result.Y[i] := Y[i];
      end;
    end;
  end;
end;  { TPPline.PointsToPline }

class procedure TPPline.Uniforme_Poligonal(NpontosE : integer; NpontosS : integer; Xpol : TVetorN; Ypol : TVetorN;
                                    var NpontosF : integer; var XpolF : TVetorN; var YpolF : TVetorN);
var                          { Aumenta número de pontos de uma Polyline 2D de NpontosE para NpontosS }
  i,j,k,ic : integer;
  PerimetroAc,PassosAc : TVetorN;     { NpontosE : número de pontos de entrada }
  XpolAux,YpolAux : TVetorN;          { NpontosS : número de pontos de saída }
  XpolAux2,YpolAux2 : TFloatType;
  Perimetro,CPassos : TFloatType;
  passoD : TFloatType;
  PontosAdicionais: integer;
begin
                                      { PerimetroAc,PassosAc : TVetorN; XpolAux,YpolAux : TVetorN; }
  Perimetro := 0;
  SetLength(PerimetroAc,NpontosE+1);
  for i := 1 to NpontosE do
  begin
    if i = 1 then
    begin
      Perimetro := 0;
      PerimetroAc[i] := Perimetro;
    end
    else
    begin
      Perimetro := Perimetro + Hypot(Xpol[i]-Xpol[i-1],Ypol[i]-Ypol[i-1]);
      PerimetroAc[i] := Perimetro;
    end;
  end;

  passoD := Perimetro/(NpontosS-NpontosE+1);
  CPassos := 0;
  SetLength(PassosAc,NpontosS-NpontosE+1);
  for i := 1 to NpontosS-NpontosE do
  begin
    CPassos := CPassos + passoD;
    PassosAc[i] := CPassos;
  end;
   SetLength(XpolAux,NpontosE+1);
   SetLength(YpolAux,NpontosE+1);
   for i := 1 to NpontosE do
   begin
     XpolAux[i] := Xpol[i];
     YpolAux[i] := Ypol[i];
   end;
   PontosAdicionais := NpontosS-NpontosE;

   if NpontosS > NpontosE then
   begin
   for j := 1 to PontosAdicionais do
   begin
     ic := 0;
     for i := 2 to NpontosE do
     begin
       if (PassosAc[j] >= PerimetroAc[i-1]) and (PassosAc[j] <= PerimetroAc[i]) and (ic = 0) then
       begin
         XpolAux2 := XpolAux[i-1] + ((XpolAux[i]-XpolAux[i-1])/Hypot(XpolAux[i]-XpolAux[i-1],YpolAux[i]-YpolAux[i-1]))*(PassosAc[j]-PerimetroAc[i-1]);
         YpolAux2 := YpolAux[i-1] + ((YpolAux[i]-YpolAux[i-1])/Hypot(XpolAux[i]-XpolAux[i-1],YpolAux[i]-YpolAux[i-1]))*(PassosAc[j]-PerimetroAc[i-1]);

         SetLength(XpolAux,NpontosE+2);
         SetLength(YpolAux,NpontosE+2);
         SetLength(PerimetroAc,NpontosE+2);
         for k := NpontosE downto i do
         begin
           XpolAux[k+1] := XpolAux[k];
           YpolAux[k+1] := YpolAux[k];
           PerimetroAc[k+1] := PerimetroAc[k];
         end;
         XpolAux[i] := XpolAux2;
         YpolAux[i] := YpolAux2;
         PerimetroAc[i] := PassosAc[j];
         NpontosE := NpontosE + 1;
         ic := 1;
       end;
     end;
  end;
  end;
  SetLength(XpolF,NpontosE+1);  SetLength(YpolF,NpontosE+1);
  for i := 1 to NpontosE do
  begin
    XpolF[i] := XpolAux[i]; YpolF[i] := YpolAux[i];
  end;
  NpontosF := NpontosE;

end;  { TPPline.Uniforme_Poligonal }

class procedure TPPline.Uniforme_PoligonalN(NpontosE : integer; NpontosS : integer; Xpol : TVetorN; Ypol : TVetorN;
                              var NpontosF : integer; var XpolF : TVetorN; var YpolF : TVetorN);
var
  i,j,k,ic : integer;
  PerimetroAc,PassosAc : TVetorN;
  XpolAux,YpolAux : TVetorN;
  XpolAux2,YpolAux2 : TFloatType;
  Perimetro,CPassos : TFloatType;
  passoD : TFloatType;
  PontosAdicionais: integer;
begin

  Perimetro := 0;

  SetLength(PerimetroAc,Max(NpontosS,NpontosE)+1);
  for i := 1 to NpontosE do
  begin
    if i = 1 then
    begin
      Perimetro := 0;
      PerimetroAc[i] := Perimetro;
    end
    else
    begin
      Perimetro := Perimetro + Hypot(Xpol[i]-Xpol[i-1],Ypol[i]-Ypol[i-1]);
      PerimetroAc[i] := Perimetro;
    end;
  end;

  SetLength(XpolAux,Max(NpontosS,NpontosE)+1);
  SetLength(YpolAux,Max(NpontosS,NpontosE)+1);
  SetLength(PassosAc,Max(NpontosS,NpontosE)+1);

  passoD := Perimetro/(NpontosS-NpontosE+1);
  CPassos := 0;
  for i := 1 to NpontosS-NpontosE do
  begin
    CPassos := CPassos + passoD;
    PassosAc[i] := CPassos;
  end;

   for i := 1 to NpontosE do
   begin
     XpolAux[i] := Xpol[i];
     YpolAux[i] := Ypol[i];
   end;
   PontosAdicionais := NpontosS-NpontosE;

   if NpontosS > NpontosE then
   begin
   for j := 1 to PontosAdicionais do
   begin
     ic := 0;
     for i := 2 to NpontosE do
     begin
       if (PassosAc[j] >= PerimetroAc[i-1]) and (PassosAc[j] <= PerimetroAc[i]) and (ic = 0) then
       begin
         XpolAux2 := XpolAux[i-1] + ((XpolAux[i]-XpolAux[i-1])/Hypot(XpolAux[i]-XpolAux[i-1],YpolAux[i]-YpolAux[i-1]))*(PassosAc[j]-PerimetroAc[i-1]);
         YpolAux2 := YpolAux[i-1] + ((YpolAux[i]-YpolAux[i-1])/Hypot(XpolAux[i]-XpolAux[i-1],YpolAux[i]-YpolAux[i-1]))*(PassosAc[j]-PerimetroAc[i-1]);

         for k := NpontosE downto i do
         begin
           XpolAux[k+1] := XpolAux[k];
           YpolAux[k+1] := YpolAux[k];
           PerimetroAc[k+1] := PerimetroAc[k];
         end;
         XpolAux[i] := XpolAux2;
         YpolAux[i] := YpolAux2;
         PerimetroAc[i] := PassosAc[j];
         NpontosE := NpontosE + 1;
         ic := 1;
       end;
     end;
  end;
  end;

  SetLength(XpolF,Max(NpontosS,NpontosE)+1);
  SetLength(YpolF,Max(NpontosS,NpontosE)+1);
  for i := 1 to NpontosE do
  begin
    XpolF[i] := XpolAux[i]; YpolF[i] := YpolAux[i];
  end;
  NpontosF := NpontosE;

end;  { TPPline.Uniforme_PoligonalN }

{---------------------------------------------------------------------------------------------------}
{                                           TPoly                                                   }
{                                                                                                   }
{ TPoly class gather all algorithms related to the construction of 3D polylines                     }
{---------------------------------------------------------------------------------------------------}

class procedure TPoly.Reference_3DPline(XOrigin, YOrigin, ZOrigin : TFloatType; var Poly : T3DPline);
var                        { Altera o referencial de uma Polyline 3D }
  i : integer;
begin
  for i := 1 to Poly.Npoly do
  begin
    Poly.X[i] := Poly.X[i] - XOrigin;
    Poly.Y[i] := Poly.Y[i] - YOrigin;
    Poly.Z[i] := Poly.Z[i] - ZOrigin;
  end;
end;  { TPoly.Referencia_3DPline }

class procedure TPoly.Move_3DPline(X, Y, Z : TFloatType; var Poly : T3DPline);
var                        { Translada uma Polyline 3D pelo vetor (X,Y,Z) }
  i : integer;
begin
  for i := 1 to Poly.Npoly do
  begin
    Poly.X[i] := Poly.X[i] + X;
    Poly.Y[i] := Poly.Y[i] + Y;
    Poly.Z[i] := Poly.Z[i] + Z;
  end;
end;  { TPoly.Move_3DPline }

class function TPoly.Poly_2DProjection(Poly : T3DPline; Plan : Word2L) : TPline;
var                   { Transforma Poly 3D em Poly 2D de acordo com o plano }
  i : integer;
begin
  Result.Npoly := Poly.Npoly;
  Result.Closed := Poly.Closed;
  SetLength(Result.X,Poly.Npoly+1);  SetLength(Result.Y,Poly.Npoly+1);
  If Plan = 'XY' then
  begin
    for i := 1 to Poly.Npoly do
    begin
      Result.X[i] := Poly.X[i];
      Result.Y[i] := Poly.Y[i];
    end;
  end
  Else If Plan = 'XZ' then
  begin
    for i := 1 to Poly.Npoly do
    begin
      Result.X[i] := Poly.X[i];
      Result.Y[i] := Poly.Z[i];
    end;
  end
  Else If Plan = 'YZ' then
  begin
    for i := 1 to Poly.Npoly do
    begin
      Result.X[i] := Poly.Y[i];
      Result.Y[i] := Poly.Z[i];
    end;
  end
  Else If Plan = 'YX' then
  begin
    for i := 1 to Poly.Npoly do
    begin
      Result.X[i] := Poly.Y[i];
      Result.Y[i] := Poly.X[i];
    end;
  end
  Else If Plan = 'ZX' then
  begin
    for i := 1 to Poly.Npoly do
    begin
      Result.X[i] := Poly.Z[i];
      Result.Y[i] := Poly.X[i];
    end;
  end
  Else If Plan = 'ZY' then
  begin
    for i := 1 to Poly.Npoly do
    begin
      Result.X[i] := Poly.Z[i];
      Result.Y[i] := Poly.Y[i];
    end;
  end;
end;  { TPoly.Poly_2DProjection }

class function TPoly.Pline_2Dto3D(Poly : TPline; DeepCoord : TFloatType; Plan : Word2L) : T3DPline;
var                   { Transforma Poly 2D em Poly 3D de acordo com o plano }
  i : integer;
begin
  Result.Npoly := Poly.Npoly;
  Result.Closed := Poly.Closed;
  SetLength(Result.X,Poly.Npoly+1);  SetLength(Result.Y,Poly.Npoly+1);
  SetLength(Result.Z,Poly.Npoly+1);
  If Plan = 'XY' then
  begin
    for i := 1 to Poly.Npoly do
    begin
      Result.X[i] := Poly.X[i];
      Result.Y[i] := Poly.Y[i];
      Result.Z[i] := DeepCoord;
    end;
  end
  Else If Plan = 'XZ' then
  begin
    for i := 1 to Poly.Npoly do
    begin
      Result.X[i] := Poly.X[i];
      Result.Z[i] := Poly.Y[i];
      Result.Y[i] := DeepCoord;
    end;
  end
  Else If Plan = 'YZ' then
  begin
    for i := 1 to Poly.Npoly do
    begin
      Result.Y[i] := Poly.X[i];
      Result.Z[i] := Poly.Y[i];
      Result.X[i] := DeepCoord;
    end;
  end
  Else If Plan = 'YX' then
  begin
    for i := 1 to Poly.Npoly do
    begin
      Result.Y[i] := Poly.X[i];
      Result.X[i] := Poly.Y[i];
      Result.Z[i] := DeepCoord;
    end;
  end
  Else If Plan = 'ZX' then
  begin
    for i := 1 to Poly.Npoly do
    begin
      Result.Z[i] := Poly.X[i];
      Result.X[i] := Poly.Y[i];
      Result.Y[i] := DeepCoord;
    end;
  end
  Else If Plan = 'ZY' then
  begin
    for i := 1 to Poly.Npoly do
    begin
      Result.Z[i] := Poly.X[i];
      Result.Y[i] := Poly.Y[i];
      Result.X[i] := DeepCoord;
    end;
  end;
end;  { TPoly.Poly_2DTo3D }

class function TPoly.Pline_2Dto3D(Poly : TPline; N : integer; X,Y,Z,XRef,YRef,ZRef : TFloatType;
                                  Plan : TPlan) : T3DPline;
var                   { Transforma Poly 2D em Poly 3D de acordo com o plano Plan, }
  i : integer;        { coincidindo o ponto N da poligonal com o (X,Y,Z) do plano }
  V : TVetor3x1;      { e seguindo o eixo de referência (XRef,YRef,ZRef). }
  M : TMatriz3x3;     { (XRef,YRef,ZRef) aponta na direção do eixo X de Poly 2D }
begin                 { e em uma direção no espaço definida pelo usuário. }
  { Projeta ponto de inserção no plano }
  Projection_PointToPlan(X,Y,Z,Plan,X,Y,Z);
  { Projeta Vetor de referência no plano }
  
  VetorUnitario(Plan.XN,Plan.YN,Plan.ZN,Plan.XN,Plan.YN,Plan.ZN);
  { Inicializa poligonal 3D }
  Result.Npoly := Poly.Npoly;
  Result.Closed := Poly.Closed;
  SetLength(Result.X,Poly.Npoly+1);  SetLength(Result.Y,Poly.Npoly+1);
  SetLength(Result.Z,Poly.Npoly+1);

  { Origem para ponto N }
  TPPline.Reference_Pline(Poly.X[N],Poly.Y[N],Poly);

  { A SEGUIR (aqui): Mudar origem de Poly 2D para o ponto N }
  { Essa Poly 2D de origem N está na base do plano, com Z = 0. Desfazendo }
  { a transformação de base, obtemos os pontos no sistema global em cima }
  { do plano. Transladamos o ponto N para (X,Y,Z) e junto todos os demais pontos. }

  { Poly 2D de origem N está na base do plano, com Z = 0 }
  for i := 1 to Poly.Npoly do
  begin
    Result.X[i] := Poly.X[i];  Result.Y[i] := Poly.Y[i];
    Result.Z[i] := 0;
  end;

  { Determina a Matriz da Base do Plano }
  M := Plan_BaseAxis(Plan,XRef,YRef,ZRef);
  { Determina a Matriz Inversa da Base Ortonormal }
  M := MatrizTransposta(M);

  { Desfaz a Mudança de Base }
  for i := 1 to Result.Npoly do
  begin
    V := Vetor3x1(Result.X[i],Result.Y[i],Result.Z[i]);
    V := ProdutoMatrizVetor(M,V);
    Result.X[i] := V[1];  Result.Y[i] := V[2];  Result.Z[i] := V[3];
  end;

  Move_3DPline(X-Result.X[N],Y-Result.Y[N],Z-Result.Z[N],Result);

end;  { TPoly.Poly_2DTo3D }

class function TPoly.Align(Poly_1 : T3DPline; Poly_2 : T3DPline) : T3DPline;
var                        { Modifica Poly_2 para obter o melhor alinhamento }
  i, j : integer;          { do primeiro ponto de Poly_1 com o primeiro de Poly_2 }
  D11,D1N,Dist : TFloatType;            { ATENÇÃO : Possibilitar reverse de pontos em Poly_2 fechada }
begin                                   { de acordo com verificação de área }
  If Poly_2.Npoly > 1 then
  begin
    If Poly_2.Closed = False then
    begin        { Poly_2 Aberta }
      D11 := Dist_Points(Poly_1.X[1],Poly_1.Y[1],Poly_1.Z[1],Poly_2.X[1],Poly_2.Y[1],Poly_2.Z[1]);
      i := Poly_2.Npoly;
      D1N := Dist_Points(Poly_1.X[1],Poly_1.Y[1],Poly_1.Z[1],Poly_2.X[i],Poly_2.Y[i],Poly_2.Z[i]);
      If D11 > D1N then
        Result := Reverse(Poly_2)
      Else Result := Poly_2;
    end
    Else If Poly_2.Closed then
    begin        { Poly_2 Fechada }
      j := 1;
      D1N := Dist_Points(Poly_1.X[1],Poly_1.Y[1],Poly_1.Z[1],Poly_2.X[1],Poly_2.Y[1],Poly_2.Z[1]);
      for i := 1 to Poly_2.Npoly do
      begin
        Dist := Dist_Points(Poly_1.X[1],Poly_1.Y[1],Poly_1.Z[1],Poly_2.X[i],Poly_2.Y[i],Poly_2.Z[i]);
        If Dist < D1N then
        begin
          j := i;
          D1N := Dist;
        end;
      end;
      Result := Renumber(Poly_2,j);
    end;
  end
  Else Result := Poly_2;
end;  { TPoly.Align }

class function TPoly.Align_R(Poly_1 : T3DPline; Poly_2 : T3DPline) : T3DPline;
var                        { Modifica Poly_2 para obter o melhor alinhamento }
  i, j : integer;          { do último ponto de Poly_1 com o primeiro de Poly_2 }
  D11,D1N,Dist : TFloatType;            { ATENÇÃO : Possibilitar reverse de pontos em Poly_2 fechada }
begin                                   { de acordo com verificação de área }
  If Poly_2.Closed = False then
  begin        { Poly_2 Aberta }
    D11 := Dist_Points(Poly_1.X[1],Poly_1.Y[1],Poly_1.Z[1],Poly_2.X[1],Poly_2.Y[1],Poly_2.Z[1]);
    i := Poly_2.Npoly;
    D1N := Dist_Points(Poly_1.X[1],Poly_1.Y[1],Poly_1.Z[1],Poly_2.X[i],Poly_2.Y[i],Poly_2.Z[i]);
    If D11 < D1N then
      Result := Reverse(Poly_2)
    Else Result := Poly_2;
  end
  Else If Poly_2.Closed then
  begin        { Poly_2 Fechada }
    j := 1;
    D1N := Dist_Points(Poly_1.X[Poly_1.Npoly],Poly_1.Y[Poly_1.Npoly],Poly_1.Z[Poly_1.Npoly],
                       Poly_2.X[1],Poly_2.Y[1],Poly_2.Z[1]);
    for i := 1 to Poly_2.Npoly do
    begin
      Dist := Dist_Points(Poly_1.X[Poly_1.Npoly],Poly_1.Y[Poly_1.Npoly],Poly_1.Z[Poly_1.Npoly],
                          Poly_2.X[i],Poly_2.Y[i],Poly_2.Z[i]);
      If Dist < D1N then
      begin
        j := i;
        D1N := Dist;
      end;
    end;
    Result := TPoly.Renumber(Poly_2,j);
  end;

end;  { TPoly.Align_R }

class function TPoly.Reverse(Poly : T3DPline) : T3DPline;
var
  i : integer;
begin
  Result.Npoly := Poly.Npoly;
  Result.Closed := Poly.Closed;
  SetLength(Result.X,Result.Npoly+1);
  SetLength(Result.Y,Result.Npoly+1);
  SetLength(Result.Z,Result.Npoly+1);

  for i := 1 to Poly.Npoly do
  begin
    Result.X[Poly.Npoly-i+1] := Poly.X[i];
    Result.Y[Poly.Npoly-i+1] := Poly.Y[i];
    Result.Z[Poly.Npoly-i+1] := Poly.Z[i];
  end;
end;  { TPoly.Reverse }

class function TPoly.Renumber(Poly : T3DPline; N1 : integer) : T3DPline;
var
  i, j : integer;
begin
  Result.Npoly := Poly.Npoly;
  Result.Closed := Poly.Closed;
  SetLength(Result.X,Result.Npoly+1);
  SetLength(Result.Y,Result.Npoly+1);
  SetLength(Result.Z,Result.Npoly+1);
  for i := 1 to Poly.Npoly-N1+1 do
  begin
    Result.X[i] := Poly.X[i+N1-1];
    Result.Y[i] := Poly.Y[i+N1-1];
    Result.Z[i] := Poly.Z[i+N1-1];
  end;
  If Poly.Closed = False then                { Poligonal Aberta }
  Begin                                      { Exemplo }
    j := Poly.Npoly-N1+2;                    { 1 2 3  4 5 6 7 8 9 10 }
    for i := j to Poly.Npoly do              { 8 9 10 1 2 3 4 5 6 7  }
    begin
      Result.X[i] := Poly.X[i-j+1];
      Result.Y[i] := Poly.Y[i-j+1];
      Result.Z[i] := Poly.Z[i-j+1];
    end;
  End
  Else If Poly.Closed then           { Poligonal Fechada }
  Begin                                      { Exemplo }
    j := Poly.Npoly-N1+2;                    { 1 2 3 4  4 5 6 7 8 9 10 }
    for i := j to Poly.Npoly do              {   8 9 10 1 2 3 4 5 6 7  }
    begin
      Result.X[i] := Poly.X[i-j+2];
      Result.Y[i] := Poly.Y[i-j+2];
      Result.Z[i] := Poly.Z[i-j+2];
    end;
  End;
end;  { TPoly.Renumber }

class function TPoly.CCW(Poly : T3DPline) : boolean;
begin
  Result := False;
  If TPoly.Volume(Poly) >= 0 then
    Result := True
  Else If TPoly.Volume(Poly) < 0 then
    Result := False;
end;  { TPoly.CCW }

class function TPoly.Volume(Poly : T3DPline) : TFloatType;
var                      { Calcula somatório do volume das pirâmides formadas }
  i, j, N : integer;     { pelo vértice no primeiro ponto de Poly e base nos }
  Volume : TFloatType;         { demais N-1 pontos }
  XV,YV,ZV,X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3 : TFloatType;
  X_B, Y_B, Z_B : array[1..3]of TFloatType;
begin
  N := Poly.Npoly-1;
  Result := 0;
  If Plan(Poly) = False then        { Poligonal 3D }     { ATENÇÃO! Erro nessa parte }
  Begin
    If N > 4 then
    Begin
      Volume := 0;
      XV := Poly.X[1];  YV := Poly.Y[1];  ZV := Poly.Z[1];
      for i := 1 to (N div 3) do
      begin
        j := (2*i)-1;
        X1 := Poly.X[j+i];    Y1 := Poly.Y[j+i];    Z1 := Poly.Z[j+i];
        X2 := Poly.X[j+i+1];  Y2 := Poly.Y[j+i+1];  Z2 := Poly.Z[j+i+1];
        X3 := Poly.X[j+i+2];  Y3 := Poly.Y[j+i+2];  Z3 := Poly.Z[j+i+2];
        Volume := Volume + Volume_Pyramid(XV,YV,ZV,X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3);

        X1 := Poly.X[j+i+1];  Y1 := Poly.Y[j+i+1];  Z1 := Poly.Z[j+i+1];
        X2 := Poly.X[j+i+2];  Y2 := Poly.Y[j+i+2];  Z2 := Poly.Z[j+i+2];
        X3 := Poly.X[j+i+3];  Y3 := Poly.Y[j+i+3];  Z3 := Poly.Z[j+i+3];
        Volume := Volume + Volume_Pyramid(XV,YV,ZV,X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3);
      end;
      Result := Volume;
      If ((N-2)mod 3 = 2) then   { N pontos: 1 = Vértice, N-1 pontos para Bases, N-2 entre espaços }
      begin          { Dois Entre Espaços de Pontos Sobrando }
        i := (N div 3)+1;
        j := (2*i)-1;
        X1 := Poly.X[j+i];    Y1 := Poly.Y[j+i];    Z1 := Poly.Z[j+i];
        X2 := Poly.X[j+i+1];  Y2 := Poly.Y[j+i+1];  Z2 := Poly.Z[j+i+1];
        X3 := Poly.X[j+i+2];  Y3 := Poly.Y[j+i+2];  Z3 := Poly.Z[j+i+2];
        Volume := Volume + Volume_Pyramid(XV,YV,ZV,X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3);
        Result := Volume;
      end
      Else If ((N-2)mod 3 = 1) then
      begin          { Um Entre Espaço de Pontos Sobrando }
        i := (N div 3)+1;
        j := (2*i)-1;
        X1 := Poly.X[j+i];    Y1 := Poly.Y[j+i];    Z1 := Poly.Z[j+i];
        X2 := Poly.X[j+i+1];  Y2 := Poly.Y[j+i+1];  Z2 := Poly.Z[j+i+1];
        X3 := Poly.X[2];      Y3 := Poly.Y[2];      Z3 := Poly.Z[2];
        Volume := Volume + Volume_Pyramid(XV,YV,ZV,X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3);
        Result := Volume;
      end;
    End
    Else If (N = 1) or (N = 2) then
      Result := 0
    Else If (N = 3) then    { Se N = 3, calcula a área do plano }
    Begin
      X1 := Poly.X[1];  Y1 := Poly.Y[1];  Z1 := Poly.Z[1];
      X2 := Poly.X[2];  Y2 := Poly.Y[2];  Z2 := Poly.Z[2];
      X3 := Poly.X[3];  Y3 := Poly.Y[3];  Z3 := Poly.Z[3];
      Change_Base_Plan(X1,Y1,Z1,X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3,X_B[1],Y_B[1],Z_B[1]);
      Change_Base_Plan(X2,Y2,Z2,X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3,X_B[2],Y_B[2],Z_B[2]);
      Change_Base_Plan(X3,Y3,Z3,X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3,X_B[3],Y_B[3],Z_B[3]);
      Result := (1/2)*ProdutoVetorial2D(X_B[3]-X_B[1],Y_B[3]-Y_B[1],X_B[2]-X_B[1],Y_B[2]-Y_B[1]);
    End;
  End
  Else If Plan(Poly) then    { Poligonal 2D }
  Begin
    Result := Area(Poly);
  End;
end;  { TPoly.Volume }

class function TPoly.Area(Poly : T3DPline) : TFloatType;
var                                    { Calcula somatório de áreas de triângulos formados }
  i, N : integer;                      { pelo primeiro ponto de Poly e seus demais pontos }
  X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3 : TFloatType;   { i e i+1 (i = 2 a N-1) }
  X_B, Y_B, Z_B : array[1..3]of TFloatType;
begin
  If Poly.Closed = False then
    N := Poly.Npoly
  Else N := Poly.Npoly-1;

  If N > 2 then
  Begin
    X1 := Poly.X[1];  Y1 := Poly.Y[1];  Z1 := Poly.Z[1];
    Result := 0;
    for i := 2 to N-1 do
    begin
      X2 := Poly.X[i];    Y2 := Poly.Y[i];    Z2 := Poly.Z[i];
      X3 := Poly.X[i+1];  Y3 := Poly.Y[i+1];  Z3 := Poly.Z[i+1];
      { Muda pontos 1, i, i+1 para a base formada pelo plano 1, i, i+1  }
      Change_Base_Plan(X1,Y1,Z1,X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3,X_B[1],Y_B[1],Z_B[1]);
      Change_Base_Plan(X2,Y2,Z2,X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3,X_B[2],Y_B[2],Z_B[2]);
      Change_Base_Plan(X3,Y3,Z3,X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3,X_B[3],Y_B[3],Z_B[3]);
      Result := Result + (1/2)*ProdutoVetorial2D(X_B[3]-X_B[1],Y_B[3]-Y_B[1],X_B[2]-X_B[1],Y_B[2]-Y_B[1]);
    end;
  End
  Else Result := 0;
end;  { TPoly.Area }

class function TPoly.Plan(Poly : T3DPline) : boolean;
var              { Verifica se uma poligonal é plana ou não }
  i, N : integer;
  XV,YV,ZV,X1,Y1,Z1 : TFloatType;
  PEscalar : TFloatType;
begin
  Result := True;
  If Poly.Closed = False then
    N := Poly.Npoly
  Else N := Poly.Npoly-1;

  If N > 3 then
  begin
    ProdutoVetorial(Poly.X[3]-Poly.X[1],Poly.Y[3]-Poly.Y[1],Poly.Z[3]-Poly.Z[1],
                    Poly.X[2]-Poly.X[1],Poly.Y[2]-Poly.Y[1],Poly.Z[2]-Poly.Z[1],
                    XV,YV,ZV);
    for i := 4 to N do
    begin
      ProdutoVetorial(Poly.X[i]-Poly.X[1],Poly.Y[i]-Poly.Y[1],Poly.Z[i]-Poly.Z[1],
                      Poly.X[2]-Poly.X[1],Poly.Y[2]-Poly.Y[1],Poly.Z[2]-Poly.Z[1],
                      X1,Y1,Z1);
      PEscalar := ProdutoEscalar(X1,Y1,Z1,XV,YV,ZV);
      If (PEscalar <> 1) or (PEscalar <> -1) then
       Result := False;
    end;
  end;
end;  { TPoly.Plan }

class function TPoly.Gap(Poly : T3DPline) : boolean;
begin          { Verifica se a Polyline é aberta (True) ou fechada (False) }
  If Poly.Npoly > 2 then
  begin
    If (Poly.X[1]=Poly.X[Poly.Npoly]) and
       (Poly.Y[1]=Poly.Y[Poly.Npoly]) and
       (Poly.Z[1]=Poly.Z[Poly.Npoly]) then
      Result := False    { Poligonal Fechada }
    Else
      Result := True;    { Poligonal Aberta }
  end
  Else Result := True;   { Poligonal Aberta }
end;  { TPoly.Gap }

class function TPoly.Gap_Coord(X1,Y1,Z1,XN,YN,ZN : TFloatType) : boolean;
begin          { Verifica se as coordenadas (X1,Y1,Z1) e (XN,YN,ZN)são iguais }
  If (X1=XN) and (Y1=YN) and (Z1=ZN) then
    Result := False    { Poligonal Fechada }
  Else
    Result := True;    { Poligonal Aberta }
end;  { TPoly.Gap_Coord }

class function TPoly.LeftofXBoundary(Poly : T3DPline; X1, X2 : TFloatType) : boolean;
var                 { Verifica se os pontos de Poly verificam X < X1,X2 }
  i : integer;
begin
  i := 0;  Result := False;
  repeat     { Verifica se algum ponto de Poly é menor que Min(X1,X2) }
  begin
    i := i + 1;
    If Lower(Poly.X[i],Min(X1,X2),RelPrecision) then    { Se existir ponto menor, a polyline não }
      Result := True;                                   { respeita a fronteira [X1,X2] }
  end;
  until((i = Poly.Npoly) or (Result = True));
end;  { TPoly.LeftofXBoundary }

class function TPoly.RightofXBoundary(Poly : T3DPline; X1, X2 : TFloatType) : boolean;
var                 { Verifica se os pontos de Poly verificam X > X1,X2 }
  i : integer;
begin
  i := 0;  Result := False;
  repeat     { Verifica se algum ponto de Poly é menor que Max(X1,X2) }
  begin
    i := i + 1;
    If Greater(Poly.X[i],Max(X1,X2),RelPrecision) then    { Se existir ponto maior, a polyline não }
      Result := True;                 { respeita a fronteira [X1,X2] }
    end;
    until((i = Poly.Npoly) or (Result = True));
end;  { TPoly.RightofXBoundary }

class function TPoly.InsideXBoundary(Poly : T3DPline; X1, X2 : TFloatType) : boolean;
var                 { Verifica se os pontos de Poly verificam X E [X1,X2] }
  i : integer;
begin
  i := 0;  Result := True;
  repeat     { Verifica se algum ponto de Poly está fora de X = X1..X2 }
  begin
    i := i + 1;
    If OutRange(Poly.X[i],X1,X2,RelPrecision) then    { Se existir ponto fora, a polyline não }
      Result := False;                                { respeita a fronteira [X1,X2] }
  end;
  until((i = Poly.Npoly) or (Result = False));
end;  { TPoly.InsideXBoundary }

class function TPoly.InsideXBoundaryEq(Poly : T3DPline; X1, X2 : TFloatType) : boolean;
var                 { Verifica se os pontos de Poly verificam X E (X1,X2) }
  i : integer;
begin
  i := 0;  Result := True;
  repeat     { Verifica se algum ponto de Poly está fora de X = X1..X2 ou em X1 ou X2 }
  begin
    i := i + 1;
    If OutRangeEq(Poly.X[i],X1,X2,RelPrecision) then  { Se existir ponto fora ou em X1 ou X2, a polyline não }
      Result := False;                                { respeita a fronteira (X1,X2) }
  end;
  until((i = Poly.Npoly) or (Result = False));
end;  { TPoly.InsideXBoundaryEq }

class function TPoly.InXCoordinate(Poly : T3DPline; X : TFloatType) : boolean;
var                 { Verifica se os pontos de Poly verificam PolySet.P[i].X E X }
  i : integer;
begin
  i := 0;  Result := True;
  repeat     { Verifica se algum ponto de Poly está fora de X }
  begin
    i := i + 1;
    If Equal(Poly.X[i],X,RelPrecision) = False then
      Result := False;
    end;
    until((i = Poly.Npoly) or (Result = False));
end;  { TPoly.InXCoordinate }

class function TPoly.InsidePlanBoundary(Poly : T3DPline; P : TPlan) : boolean;
var                 { Verifica se todos os pontos de Poly estão sobre }
  i : integer;      { o plano P ou do lado positivo do plano P }
begin               { Lado Positivo de P = lado onde a normal aponta }
  i := 0;  Result := True;
  repeat     { Verifica se algum ponto de Poly está do lado negativo de P }
  begin
    i := i + 1;
    If Dist_PointToPlan(Poly.X[i],Poly.Y[i],Poly.Z[i],P) < 0 then
      Result := False;                    { Se existir ponto fora, a polyline não }
    end;                                  { respeita a fronteira do plano }
    until((i = Poly.Npoly) or (Result = False));
end;  { TPoly.InsidePlanBoundary }

class function TPoly.InsidePlanBoundary(Poly : T3DPline; X1,Y1,Z1,XN,YN,ZN : TFloatType) : boolean;
var
  i : integer;
begin
  i := 0;  Result := True;
  repeat
  begin
    i := i + 1;
    If Lower(Dist_PointToPlan(Poly.X[i],Poly.Y[i],Poly.Z[i],X1,Y1,Z1,XN,YN,ZN),0,RelPrecision) then
      Result := False;
    end;
    until((i = Poly.Npoly) or (Result = False));
end;  { TPoly.InsidePlanBoundary }

class function TPoly.InsidePlan(Poly : T3DPline; P : TPlan) : boolean;
var                 { Verifica se os pontos de Poly estão sobre o plano P }
  i : integer;
begin
  i := 0;  Result := True;
  repeat     { Verifica se algum ponto de Poly está fora de P}
  begin
    i := i + 1;
    If IsZero(Dist_PointToPlan(Poly.X[i],Poly.Y[i],Poly.Z[i],P),RelPrecision) = False then
      Result := False;
    end;
    until((i = Poly.Npoly) or (Result = False));
end;  { TPoly.InsidePlan }

class function TPoly.InsidePlan(Poly : T3DPline; X1,Y1,Z1,XN,YN,ZN : TFloatType) : boolean;
var
  i : integer;
begin
  i := 0;  Result := True;
  repeat
  begin
    i := i + 1;
    If Equal(Dist_PointToPlan(Poly.X[i],Poly.Y[i],Poly.Z[i],X1,Y1,Z1,XN,YN,ZN),0,RelPrecision) = False then
      Result := False;
    end;
    until((i = Poly.Npoly) or (Result = False));
end;  { TPoly.InsidePlan }

class function TPoly.Close(Poly : T3DPline) : T3DPline;
begin          { É acrescentado um último ponto igual ao primeiro }
  Result := Poly;
  If Gap(Poly) then  { existe gap na polyline }
  begin
    Result.Npoly := Poly.Npoly + 1;
    SetLength(Result.X,Result.Npoly+1);   SetLength(Result.Y,Result.Npoly+1);
    SetLength(Result.Z,Result.Npoly+1);
    Result.X[Result.Npoly] := Poly.X[1];  Result.Y[Poly.Npoly] := Poly.Y[1];
    Result.Z[Result.Npoly] := Poly.Z[1];
  end;
end;  { TPoly.Close }

class function TPoly.Join(Poly_1 : T3DPline; Poly_2 : T3DPline) : T3DPline;
var                { Une as poligonais Poly_1 e Poly_2 em uma Result, }
  i : integer;     { adicionando os pontos de Poly_2 a Poly_1 a partir }
begin              { da extremidade final de Poly_1 }
  If (Poly_1.Npoly > 0) and (Poly_2.Npoly > 0) then
  begin
    Result := Poly_1;

    If (Equal(Poly_1.X[Poly_1.Npoly],Poly_2.X[1],RelPrecision)) and
       (Equal(Poly_1.Y[Poly_1.Npoly],Poly_2.Y[1],RelPrecision)) and
       (Equal(Poly_1.Z[Poly_1.Npoly],Poly_2.Z[1],RelPrecision)) then
      Result.Npoly := Poly_1.Npoly + Poly_2.Npoly - 1
    Else
     Result.Npoly := Poly_1.Npoly + Poly_2.Npoly;

    SetLength(Result.X,Result.Npoly+1);   SetLength(Result.Y,Result.Npoly+1);
    SetLength(Result.Z,Result.Npoly+1);
    for i := Poly_1.Npoly+1 to Result.Npoly do
    begin
      Result.X[i] := Poly_2.X[i-Result.Npoly+Poly_2.Npoly];
      Result.Y[i] := Poly_2.Y[i-Result.Npoly+Poly_2.Npoly];
      Result.Z[i] := Poly_2.Z[i-Result.Npoly+Poly_2.Npoly];
    end;

    Result.Closed := not Gap(Result);
  end
  Else If (Poly_1.Npoly > 0) and (Poly_2.Npoly = 0) then
    Result := Poly_1
  Else If (Poly_1.Npoly = 0) and (Poly_2.Npoly > 0) then
    Result := Poly_2
  Else If (Poly_1.Npoly = 0) and (Poly_2.Npoly = 0) then
    Result := Reset(Result);

end;  { TPoly.Join }

class function TPoly.Mirror(Poly : T3DPline; Plan : TPlan) : T3DPline;
var
  i : integer;
begin
  Result.Closed := Poly.Closed;
  i := Poly.Npoly;  Result.Npoly := i;
  SetLength(Result.X,i+1);  SetLength(Result.Y,i+1);  SetLength(Result.Z,i+1);

  for i := 1 to Poly.Npoly do
  begin
    MirrorToPlan(Plan,Poly.X[i],Poly.Y[i],Poly.Z[i],
                 Result.X[i],Result.Y[i],Result.Z[i]);
  end;

end;  { TPoly.Mirror }

class procedure TPoly.Poly_Plan_Intersection(Poly : T3DPline; P : TPlan; var Intersect : boolean;
                                                                         var Points : TSetofPoints3D);
var                            { Coleciona todos os pontos de interseção entre a poligonal Poly }
  i, j : integer;              { e o plano P }
  hit : boolean;
  Pts : TSetofPoints3D;
begin
  Intersect := False;
  Points.N := 0;  SetLength(Points.P,1);
  { Checa se existe interseção em cada linha }
  for i := 1 to Poly.Npoly-1 do
  begin
    Line_Plan_Intersection(Poly.X[i],Poly.Y[i],Poly.Z[i],Poly.X[i+1],Poly.Y[i+1],Poly.Z[i+1],P,
                           hit,Pts);
    If hit = True then
    begin
      for j := 1 to Pts.N do   { Pode haver mais de um ponto de interseção se a linha }
      begin                    { pertence ao plano }
        Points.N := Points.N + 1;  SetLength(Points.P,Points.N+1);
        Points.P[Points.N].X := Pts.P[j].X;
        Points.P[Points.N].Y := Pts.P[j].Y;
        Points.P[Points.N].Z := Pts.P[j].Z;
      end;
    end;
  end;

  { Se a poligonal é fechada, a linha de fechamento pode ter interseção }
  If Poly.Closed = True then
  begin
    i := Poly.Npoly;
    Line_Plan_Intersection(Poly.X[i],Poly.Y[i],Poly.Z[i],Poly.X[1],Poly.Y[1],Poly.Z[1],P,
                           hit,Pts);
    If hit = True then
    begin
      for j := 1 to Pts.N do   { Pode haver mais de um ponto de interseção se a linha }
      begin                    { pertence ao plano }
        Points.N := Points.N + 1;  SetLength(Points.P,Points.N+1);
        Points.P[Points.N].X := Pts.P[j].X;
        Points.P[Points.N].Y := Pts.P[j].Y;
        Points.P[Points.N].Z := Pts.P[j].Z;
      end;
    end;
  end;

  If Points.N > 0 then
    Intersect := True;
end;  { TPoly.Poly_Plan_Intersection }

class procedure TPoly.MultiPoly_Plan_Intersection(MPol : TWire; P : TPlan; var Intersect : boolean;
                                                                           var Points : TSetofPoints3D);
var                          { Determina a poligonal de interseção entre o plano P }
  i, j, k : integer;               { e a série de poligonais MPol. }
  PointsPoly : TSetofPoints3D;
  IntersectPoly : boolean;
  aux_TF : boolean;
  varaux : TFloatType;
begin
  Intersect := False;
  Points.N := 0;
  SetLength(Points.P,Points.N+1);
  k := 0;
  for i := 1 to MPol.N do    { Passa em cada Poligonal }
  begin     { Determina pontos de interseção com o plano, se existirem }
    Poly_Plan_Intersection(MPol.P[i], P, IntersectPoly, PointsPoly);
    If IntersectPoly = True then
    begin   { Coleta pontos de Interseção }
      Intersect := True;
      Points.N := Points.N + PointsPoly.N;
      SetLength(Points.P,Points.N+1);
      for j := 1 to PointsPoly.N do
      begin
        k := k + 1;
        Points.P[k].X := PointsPoly.P[j].X;
        Points.P[k].Y := PointsPoly.P[j].Y;
        Points.P[k].Z := PointsPoly.P[j].Z;
      end;
    end;
  end;
end;  { TPoly.MultiPoly_Plan_Intersection }

class function TPoly.Weld(Poly_1 : T3DPline; Poly_2 : T3DPline) : T3DPline;
var                   { Une as poligonais Poly_1 e Poly_2 por um ponto em comum }
  l, m : integer;     { mantendo o sentido de Poly_1 }
  I_TF : boolean;
begin
  If PtInCommon(Poly_1,Poly_2,l,m) then   { Se existir ponto em comum }
  begin
    //ShowMessage('l '+IntToStr(l)+char(9)+'m '+IntToStr(m));
    If (Between(l,1,Poly_1.Npoly-1) >= 0) and (Between(m,1,Poly_2.Npoly) >= 0) then
    begin
      If m = 1 then
      begin
        Poly_2 := Reverse(Poly_2);
        I_TF := PtInCommon(Poly_1,Poly_2,l,m);
      end;
      If (m < Poly_2.Npoly) then
        Poly_2 := Break(Poly_2,1,m);
      Poly_1 := Break(Poly_1,l+1,Poly_1.Npoly);
      Result := Join(Poly_2,Poly_1);
    end
    Else If (l = Poly_1.Npoly) and (Between(m,1,Poly_2.Npoly) >= 0) then
    begin
      If Between(m,2,Poly_2.Npoly-1) >= 0 then
      begin
        Poly_2 := Break(Poly_2,m+1,Poly_2.Npoly);
        Result := Join(Poly_1,Poly_2);
      end
      Else If m = 1 then
      begin
        Result := Join(Poly_1,Poly_2);
      end
      Else If m = Poly_2.Npoly then
      begin
        Poly_2 := Reverse(Poly_2);
        Result := Join(Poly_1,Poly_2);
      end;
    end;
  end
  Else
  begin
    Result := Join(Poly_1,Poly_2);
  end;
end;  { TPoly.Weld }

class function TPoly.Break(Poly : T3DPline; N1, N2 : integer) : T3DPline;
var            { Delimita uma Polyline entre seus pontos N1 e N2, com }
  i : integer; { N2 > N1 e N1,N2 < Poly.Npoly }
begin
  If N1 < 1 then N1 := 1;    If N1 > Poly.Npoly then N1 := Poly.Npoly;
  If N2 < 1 then N2 := 1;    If N2 > Poly.Npoly then N2 := Poly.Npoly;

  If N1<>N2 then
  begin
    If (Between(N1,1,Poly.Npoly)>=0) and (Between(N2,1,Poly.Npoly)>=0) then
    begin
      If N1 > N2 then
      begin
        i := N1;
        N1 := N2;
        N2 := i;
      end;
      Result.Npoly := N2-N1+1;
      SetLength(Result.X,Result.Npoly+1);
      SetLength(Result.Y,Result.Npoly+1);
      SetLength(Result.Z,Result.Npoly+1);
      for i := N1 to N2 do
      begin
        Result.X[i-N1+1] := Poly.X[i];
        Result.Y[i-N1+1] := Poly.Y[i];
        Result.Z[i-N1+1] := Poly.Z[i];
      end;

      Result.Closed := not Gap(Result);
    end
    Else
      Result := Poly;
  end
  Else If N1 = N2 then
  begin
    Result := Reset(Result);
  end;
end;  { TPoly.Break }

class procedure TPoly.Split(Poly : T3DPline; N1, N2 : integer; var Poly1, Poly2 : T3DPline);
var
  i : integer;
begin
  If N1 > N2 then
  begin
    i := N1;
    N1 := N2;
    N2 := i;
  end;
  If N1 <> N2 then
  begin
    { Poly1 from N1 to N2 }
    Poly1 := Break(Poly, N1, N2);
    Poly1.Closed := not Gap(Poly1);
    { Poly2 from N2 to N1 }
    Poly2 := Join(Break(Poly,N2,Poly.Npoly),Break(Poly,1,N1));
    Poly2.Closed := not Gap(Poly2);
  end
  Else
  begin
    Poly1 := Poly;  Poly2 := Reset(Poly2);
  end;
end;  { TPoly.Split }

class function TPoly.AddNewPoint(Poly : T3DPline; X, Y, Z : TFloatType; N : integer) : T3DPline;
var                    { Acrescenta novo ponto (X,Y,Z) a Polyline }
  i : integer;         { a frente da posição N da Polyline }
  repeated : boolean;
begin
  repeated := False;
  { Verifica se o ponto (X,Y,Z) é repetido }
  for i := 1 to Poly.Npoly do
    If (Equal(X,Poly.X[i],RelPrecision)) and
       (Equal(Y,Poly.Y[i],RelPrecision)) and
       (Equal(Z,Poly.Z[i],RelPrecision)) then
      repeated := True;
  { Se for repetido, o resultado é a polyline original }
  If repeated then
  begin
    Result := Poly;
  end
  { Senão for repetido, acrescenta o ponto a frente da posição N }
  Else If repeated = False then
  begin
    Result.Npoly := Poly.Npoly+1;
    SetLength(Result.X,Result.Npoly+1);  SetLength(Result.Y,Result.Npoly+1);
    SetLength(Result.Z,Result.Npoly+1);
    If (1<=N) and (N<=Poly.Npoly-1) then    { N E [1,Npoly-1] }
    begin
      for i := 1 to N do
      begin
        Result.X[i] := Poly.X[i];  Result.Y[i] := Poly.Y[i];  Result.Z[i] := Poly.Z[i];
      end;
      Result.X[N+1] := X;  Result.Y[N+1] := Y;  Result.Z[N+1] := Z;
      for i := N+2 to Result.Npoly do
      begin
        Result.X[i] := Poly.X[i-1];  Result.Y[i] := Poly.Y[i-1];  Result.Z[i] := Poly.Z[i-1];
      end;
    end
    Else If N = 0 then                      { N = 0 }
    begin
      for i := 1 to Poly.Npoly do
      begin
        Result.X[i+1] := Poly.X[i];  Result.Y[i+1] := Poly.Y[i];  Result.Z[i+1] := Poly.Z[i];
      end;
      Result.X[1] := X;  Result.Y[1] := Y;  Result.Z[1] := Z;
    end
    Else If N = Poly.Npoly then             { N = Npoly }
    begin
      for i := 1 to Poly.Npoly do
      begin
        Result.X[i] := Poly.X[i];  Result.Y[i] := Poly.Y[i];  Result.Z[i] := Poly.Z[i];
      end;
      Result.X[Poly.Npoly+1] := X;  Result.Y[Poly.Npoly+1] := Y;  Result.Z[Poly.Npoly+1] := Z;
    end;
    Result.Closed := not Gap(Result);
  end;
end;  { TPoly.AddNewPoint }

class procedure TPoly.AddPoint(N : integer; X, Y, Z : TFloatType; var Poly : T3DPline);
var                    { Acrescenta ponto (X,Y,Z) a Polyline }
  i : integer;         { a frente da posição N da Polyline }
begin
  { Acrescenta o ponto a frente da posição N }
  SetLength(Poly.X,Poly.Npoly+2);  SetLength(Poly.Y,Poly.Npoly+2);
  SetLength(Poly.Z,Poly.Npoly+2);  SetLength(Poly.Merged,Poly.Npoly+2);
  If (0<=N) and (N<=Poly.Npoly-1) then    { N E [0,Npoly-1] }
    for i := Poly.Npoly downto N+1 do
    begin
      Poly.X[i+1] := Poly.X[i];  Poly.Y[i+1] := Poly.Y[i];  Poly.Z[i+1] := Poly.Z[i];
      Poly.Merged[i+1] := Poly.Merged[i];
    end;

  Poly.X[N+1] := X;  Poly.Y[N+1] := Y;  Poly.Z[N+1] := Z;
  Poly.Merged[N+1] := True;
  Poly.Npoly := Poly.Npoly + 1;
  Poly.Closed := not Gap(Poly);
end;  { TPoly.AddPoint }

class procedure TPoly.AddPoint(N : integer; X, Y, Z : TFloatType; var PN : integer; var PX, PY, PZ : TVetorN);
var                    { Acrescenta ponto (X,Y,Z) a Polyline }
  i : integer;         { a frente da posição N da Polyline }
begin
  { Acrescenta o ponto a frente da posição N }
  SetLength(PX,PN+2);  SetLength(PY,PN+2);  SetLength(PZ,PN+2);
  If (0<=N) and (N<=PN-1) then    { N E [0,Npoly-1] }
    for i := PN downto N+1 do
    begin
      PX[i+1] := PX[i];  PY[i+1] := PY[i];  PZ[i+1] := PZ[i];
    end;

  PX[N+1] := X;  PY[N+1] := Y;  PZ[N+1] := Z;
  PN := PN + 1;
end;  { TPoly.AddPoint }

class function TPoly.Reset(Poly : T3DPline) : T3DPline;
begin
  with Result do
  begin
    Npoly := 0;  Closed := False;
    SetLength(X,1);  SetLength(Y,1);  SetLength(Z,1);
  end;
end;  { TPoly.Reset }

class function TPoly.EqualTest(Poly_1, Poly_2 : T3DPline) : boolean;
begin                    { Verifica se as polylines são iguais (True) ou não (False) }

  Result := False;
  If (Poly_1.Npoly = Poly_2.Npoly) and
     (Poly_1.Closed = Poly_2.Closed) then
  begin
    If (EqualVectors(Poly_1.Npoly,Poly_2.Npoly,Poly_1.X,Poly_2.X)) and
       (EqualVectors(Poly_1.Npoly,Poly_2.Npoly,Poly_1.Y,Poly_2.Y)) and
       (EqualVectors(Poly_1.Npoly,Poly_2.Npoly,Poly_1.Z,Poly_2.Z)) then
      Result := True
    Else Result := False;
  end;
end;  { TPoly.EqualTest }

class function TPoly.CoincidentTest(Poly_1, Poly_2 : T3DPline) : boolean;
var                       { Verifica se a polyline Poly_1 tem todos os seus pontos coincidentes }
  i, j, k : integer;      { com a polyline Poly_2 (True) ou não (False) }
  bool : boolean;
  P1, P2 : T3DPoint;
  strmsg : string;
begin
  Result := False;
  If Poly_1.Npoly <= Poly_2.Npoly then
  begin
    k := 0;
    for i := 1 to Poly_2.Npoly do
    begin
      bool := False; j := 0;
      repeat
      begin
        Inc(j);
        P1 := Point3D(Poly_1.X[j],Poly_1.Y[j],Poly_1.Z[j]);
        P2 := Point3D(Poly_2.X[i],Poly_2.Y[i],Poly_2.Z[i]);
        {strmsg := 'i = '+IntToStr(i)+' of '+IntToStr(Poly_2.Npoly)+char(9)+'j = '+IntToStr(j)+' of '+
                  IntToStr(Poly_1.Npoly)+char(13);
        strmsg := strmsg + 'P1 '+PointToStr(P1,char(9),fffixed,18,18)+char(13);
        strmsg := strmsg + 'P2 '+PointToStr(P2,char(9),fffixed,18,18)+char(13);}

        If EqualPoints(P1,P2) then
        begin
          Inc(k);
          bool := True;
          {strmsg := strmsg + IntToStr(k)+' TRUE '+IntToStr(Poly_1.Npoly);
          //strmsg := IntToStr(k)+' TRUE '+IntToStr(Poly_1.Npoly);
          ShowMessage(strmsg);}
        end;
      end;
      until((bool) or (j = Poly_1.Npoly));
    end;
    If k = Poly_1.Npoly then
      Result := True
    Else Result := False;
  end;
end;  { TPoly.CoincidentTest }

class function TPoly.PointIndex(X, Y, Z : TFloatType; Poly : T3DPline) : integer;
var                { Indica a ordem do Ponto (X,Y,Z) em Poly }
  i : integer;  P : T3DPoint;
begin
  Result := 0;  i := 0;  P := Point3D(X,Y,Z);
  repeat
  begin
    Inc(i);
    If EqualPoints(P,Point3D(Poly.X[i],Poly.Y[i],Poly.Z[i])) then
      Result := i;
  end;
  until((i = Poly.Npoly) or (Result <> 0));
end;  { TPoly.PointIndex }

class function TPoly.FindClosestPoint(X, Y, Z : TFloatType; Poly : T3DPline) : integer;
var
  i : integer;
  D : TFloatType;
begin
  Result := 1;
  D := Dist_Points(X,Y,Z,Poly.X[1],Poly.Y[1],Poly.Z[1]);
  for i := 1 to Poly.Npoly do
  begin
    If Lower(Dist_Points(X,Y,Z,Poly.X[i],Poly.Y[i],Poly.Z[i]),D,RelPrecision) then
    begin
      Result := i;
      D := Dist_Points(X,Y,Z,Poly.X[i],Poly.Y[i],Poly.Z[i]);
    end;
  end;
end;  { TPoly.FindClosestPoint }

class function TPoly.PtInCommon(Poly_1, Poly_2 : T3DPline; var N1, N2 : integer) : boolean;
var                             { Verifica o primeiro ponto comum entre Poly_1 e Poly_2, se }
  i, j : integer;               { ele existir (Result = True). É registrada a ordem em que }
  P1,P2 : T3DPoint;             { o ponto é encontrado em Poly_1 (N1) e em Poly_2 (N2) }
  begin                           
  i := 0;  N1 := 0;  N2 := 0;
  Result := False;
  repeat
  begin
    i := i + 1;
    for j := 1 to Poly_2.Npoly do
    begin
      {P1 := Point3D(Poly_1.X[i],Poly_1.Y[i],Poly_1.Z[i]);
      P2 := Point3D(Poly_2.X[j],Poly_2.Y[j],Poly_2.Z[j]);
      ShowMessage('i '+IntToStr(i)+' '+PointToStr(P1,fffixed,18,18)+char(13)+
                  'j '+IntToStr(j)+' '+PointToStr(P2,fffixed,18,18));}
      If (Equal(Poly_1.X[i],Poly_2.X[j],RelPrecision)) and
         (Equal(Poly_1.Y[i],Poly_2.Y[j],RelPrecision)) and
         (Equal(Poly_1.Z[i],Poly_2.Z[j],RelPrecision)) then
      begin
        Result := True;
        N1 := i;  N2 := j;
      end;
    end;
  end;
  until((i = Poly_1.Npoly) or (Result));
end;  { TPoly.PtInCommon }

class procedure TPoly.Scan_Min(NPoly : integer; X, Y, Z : TVetorN; DirectionScan : char; Scan : TFloatType;
                               AxisMinRef : byte; var NResult : boolean; var S1, S2 : TFloatType);
var                       { Determina se existe interseção entre a linha de grade na direção dada }
  i, j : integer;         { por DirectionScan e fornece o ponto de interseção (S1,S2) que possui }
  V_c, V_c1 : TDouble;    { o valor mínimo de S1 ou S2 (se AxisMinRef = 1, é S1, senão é S2). }
begin                     { Se não houver interseção, NResult é False e (S1,S2) = (0,0). }

  j := 0;
  If DirectionScan = 'X' then          { Plano de Scan Ortogonal ao eixo X }
  begin
    NResult := False;
    for i := 1 to NPoly-1 do
    begin
      If BetweenEq(Scan,X[i],X[i+1],RelPrecision) then
      begin                    { Interseções com Scan }
        NResult := True;
        SetLength(V_c,j+1);  SetLength(V_c1,j+1);
        V_c[j] := Linear_Interpolation(Scan,X[i],Y[i],X[i+1],Y[i+1]);
        V_c1[j] := Linear_Interpolation(Scan,X[i],Z[i],X[i+1],Z[i+1]);
        j := j + 1;
      end;
    end;
  end
  Else If DirectionScan = 'Y' then     { Plano de Scan Ortogonal ao eixo Y }
  begin
    NResult := False;
    for i := 1 to NPoly-1 do
    begin
      If BetweenEq(Scan,Y[i],Y[i+1],RelPrecision) then
      begin                    { Interseções com Scan }
        NResult := True;
        SetLength(V_c,j+1);  SetLength(V_c1,j+1);
        V_c[j] := Linear_Interpolation(Scan,Y[i],X[i],Y[i+1],X[i+1]);
        V_c1[j] := Linear_Interpolation(Scan,Y[i],Z[i],Y[i+1],Z[i+1]);
        j := j + 1;
      end;
    end;
  end
  Else If DirectionScan = 'Z' then     { Plano de Scan Ortogonal ao eixo Z }
  begin
    NResult := False;
    for i := 1 to NPoly-1 do
    begin
      If BetweenEq(Scan,Z[i],Z[i+1],RelPrecision) then
      begin                    { Interseções com Scan }
        NResult := True;
        SetLength(V_c,j+1);  SetLength(V_c1,j+1);
        V_c[j] := Linear_Interpolation(Scan,Z[i],X[i],Z[i+1],X[i+1]);
        V_c1[j] := Linear_Interpolation(Scan,Z[i],Y[i],Z[i+1],Y[i+1]);
        j := j + 1;
      end;
    end;
  end;
  If j <> 0 then             { Armazenamento da Mínima Interseção }
  begin
    If AxisMinRef = 1 then
    begin
      S1 := MinValue(V_c);
      S2 := V_c1[MinValueIndex(V_c)];
    end
    Else If AxisMinRef = 2 then
    begin
      S2 := MinValue(V_c1);
      S1 := V_c[MinValueIndex(V_c1)];
    end
  end
  Else If j = 0 then
  begin
    S1 := 0;  S2 := 0;
  end;

end;  { TPoly.Scan_Min }

class procedure TPoly.Scan_Max(NPoly : integer; X, Y, Z : TVetorN; DirectionScan : char; Scan : TFloatType;
                               AxisMaxRef : byte; var NResult : boolean; var S1, S2 : TFloatType);
var                       { Determina se existe interseção entre a linha de grade na direção dada }
  i, j : integer;         { por DirectionScan e fornece o ponto de interseção (S1,S2) que possui }
  V_c, V_c1 : TDouble;    { o valor mínimo de S1 ou S2 (se AxisMaxRef = 1, é S1, senão é S2). }
begin                     { Se não houver interseção, NResult é False e (S1,S2) = (0,0). }
  j := 0;
  If DirectionScan = 'X' then          { Plano de Scan Ortogonal a X }
  begin
    NResult := False;
    for i := 1 to NPoly-1 do
    begin
      If BetweenEq(Scan,X[i],X[i+1],RelPrecision) then
      begin                    { Interseções com Scan }
        NResult := True;
        SetLength(V_c,j+1);  SetLength(V_c1,j+1);
        V_c[j] := Linear_Interpolation(Scan,X[i],Y[i],X[i+1],Y[i+1]);
        V_c1[j] := Linear_Interpolation(Scan,X[i],Z[i],X[i+1],Z[i+1]);
        j := j + 1;
      end;
    end;
  end
  Else If DirectionScan = 'Y' then     { Plano de Scan Ortogonal a Y }
  begin
    NResult := False;
    for i := 1 to NPoly-1 do
    begin
      If BetweenEq(Scan,Y[i],Y[i+1],RelPrecision) then
      begin                    { Interseções com Scan }
        NResult := True;
        SetLength(V_c,j+1);  SetLength(V_c1,j+1);
        V_c[j] := Linear_Interpolation(Scan,Y[i],X[i],Y[i+1],X[i+1]);
        V_c1[j] := Linear_Interpolation(Scan,Y[i],Z[i],Y[i+1],Z[i+1]);
        j := j + 1;
      end;
    end;
  end
  Else If DirectionScan = 'Z' then     { Plano de Scan Ortogonal a Z }
  begin
    NResult := False;
    for i := 1 to NPoly-1 do
    begin
      If BetweenEq(Scan,Z[i],Z[i+1],RelPrecision) then
      begin                    { Interseções com Scan }
        NResult := True;
        SetLength(V_c,j+1);  SetLength(V_c1,j+1);
        V_c[j] := Linear_Interpolation(Scan,Z[i],X[i],Z[i+1],X[i+1]);
        V_c1[j] := Linear_Interpolation(Scan,Z[i],Y[i],Z[i+1],Y[i+1]);
        j := j + 1;
      end;
    end;
  end;
  If j <> 0 then             { Armazenamento da Mínima Interseção }
  begin
    If AxisMaxRef = 1 then
    begin
      S1 := MaxValue(V_c);
      S2 := V_c1[MaxValueIndex(V_c)];
    end
    Else If AxisMaxRef = 2 then
    begin
      S2 := MaxValue(V_c1);
      S1 := V_c[MaxValueIndex(V_c1)];
    end
  end
  Else If j = 0 then
  begin
    S1 := 0;  S2 := 0;
  end;

end;  { TPoly.Scan_Max }

class procedure TPoly.RemovePoint(N : integer; X, Y, Z : TVetorN; Npt : integer;
                                  var NResult : integer; var XResult, YResult, ZResult : TVetorN);
var                          { Remove o ponto Npt da polyline (X,Y,Z) }
  i : integer;
begin
  NResult := N-1;
  SetLength(XResult,NResult+1);  SetLength(YResult,NResult+1);
  SetLength(ZResult,NResult+1);
  If N > 1 then
  begin
    If (1<=NPt) and (NPt<N) then
    begin
      for i := 1 to NPt do
      begin
        XResult[i] := X[i];
        YResult[i] := Y[i];
        ZResult[i] := Z[i];
      end;
      for i := NPt to N-1 do
      begin
        XResult[i] := X[i+1];
        YResult[i] := Y[i+1];
        ZResult[i] := Z[i+1];
      end;
    end
    Else If NPt = N then
    begin
      for i := 1 to N-1 do
      begin
        XResult[i] := X[i];
        YResult[i] := Y[i];
        ZResult[i] := Z[i];
      end;
    end;
  end;
end;  { TPoly.RemovePoint }

class procedure TPoly.RemovePoint(Npt : integer; var N : integer; var X, Y, Z : TVetorN);
var                   { Remove o ponto Npt da polyline (X,Y,Z) }
  i : integer;
begin
  If N > 1 then
    If (1<=NPt) and (NPt<N) then
    begin
      for i := NPt to N-1 do
      begin
        X[i] := X[i+1];
        Y[i] := Y[i+1];
        Z[i] := Z[i+1];
      end;
    end;
  Dec(N);
  SetLength(X,N+1);  SetLength(Y,N+1);  SetLength(Z,N+1);
end;  { TPoly.RemovePoint }

class procedure TPoly.RemovePoint(Npt : integer; var P : T3DPline);
var                   { Remove o ponto Npt da polyline P }
  i : integer;
begin
  If P.Npoly > 1 then
  begin
    If (1<=NPt) and (NPt<P.Npoly) then
    begin
      for i := NPt to P.Npoly-1 do
      begin
        P.X[i] := P.X[i+1];
        P.Y[i] := P.Y[i+1];
        P.Z[i] := P.Z[i+1];
        P.Merged[i] := P.Merged[i+1];
      end;
    end;
  end;

  Dec(P.Npoly);
  SetLength(P.X,P.Npoly+1);  SetLength(P.Y,P.Npoly+1);  SetLength(P.Z,P.Npoly+1);
  SetLength(P.Merged,P.Npoly+1);
  P.Closed := not Gap(P);
end;  { TPoly.RemovePoint }

class procedure TPoly.RemovePoint(N : integer; P : TVetor3DPoint; Npt : integer;
                                  var NResult : integer; var PResult : TVetor3DPoint);
var                          { Remove o ponto Npt da polyline (X,Y,Z) }
  i : integer;
begin
  NResult := N-1;
  SetLength(PResult,NResult+1);
  If N > 1 then
  begin
    If (1<=NPt) and (NPt<N) then
    begin
      for i := 1 to NPt do
      begin
        PResult[i].X := P[i].X;
        PResult[i].Y := P[i].Y;
        PResult[i].Z := P[i].Z;
      end;
      for i := NPt to N-1 do
      begin
        PResult[i].X := P[i+1].X;
        PResult[i].Y := P[i+1].Y;
        PResult[i].Z := P[i+1].Z;
      end;
    end
    Else If NPt = N then
    begin
      for i := 1 to N-1 do
      begin
        PResult[i].X := P[i].X;
        PResult[i].Y := P[i].Y;
        PResult[i].Z := P[i].Z;
      end;
    end;
  end;  
end;  { TPoly.RemovePoint }

class procedure TPoly.RemoveRepeatedPts(N : integer; X, Y, Z : TVetorN; var NResult : integer;
                                        var XResult, YResult, ZResult : TVetorN);
var                              { Remove todos os pontos repetidos da polyline (X,Y,Z) }
  i, j, k : integer;
  //P_Aux : TVetorIN;
begin
  If N > 1 then
  begin
    i := 1;
    while (i < N) do
    begin
      j := i + 1;
      while (j < N) do
      begin
        If (Equal(X[i],X[j],RelPrecision)) and
           (Equal(Y[i],Y[j],RelPrecision)) and
           (Equal(Z[i],Z[j],RelPrecision)) then
        begin
          for k := j to N-1 do
          begin
            X[k] := X[k+1];
            Y[k] := Y[k+1];
            Z[k] := Z[k+1];
          end;
          N := N - 1;
        end
        Else j := j + 1;
      end;
      i := i + 1;
    end;
    SetLength(X, N + 1);    SetLength(Y, N + 1);    SetLength(Z, N + 1);

    NResult := N;   XResult := X;  YResult := Y;  ZResult := Z;
    {k := 0;
    for i := 1 to N-1 do
    begin
      for j := i+1 to N do
      begin
        If (Equal(X[i],X[j],RelPrecision)) and
           (Equal(Y[i],Y[j],RelPrecision)) and
           (Equal(Z[i],Z[j],RelPrecision)) then
        begin
          k := k + 1;
          SetLength(P_Aux,k+1);
          P_Aux[k] := j;
        end;
      end;
    end;

    for i := 1 to k do
    begin
      RemovePoint(N,X,Y,Z,P_Aux[i],NResult,XResult,YResult,ZResult);
      N := NResult;
      X := XResult;  Y := YResult;  Z := ZResult;
      for j := i to k do
        if P_Aux[j] > P_Aux[i] then
          P_Aux[j] := P_Aux[j]-1;
    end;}
  end
  Else begin
    NResult := N;  XResult := X;  YResult := Y;  ZResult := Z;
  end;
end;  { TPoly.RemoveRepeatedPts }

class procedure TPoly.RemoveRepeatedPts(N : integer; P : TVetor3DPoint;
                                        var NResult : integer; var PResult : TVetor3DPoint);
var                              { Remove todos os pontos repetidos da polyline P }
  i, j, k : integer;
  P_Aux : TVetorIN;
begin

  If N > 1 then
  begin
    i := 1;
    while (i < N) do
    begin
      j := i + 1;
      while (j < N) do
      begin
        If (Equal(P[i].X,P[j].X,RelPrecision)) and
           (Equal(P[i].Y,P[j].Y,RelPrecision)) and
           (Equal(P[i].Z,P[j].Z,RelPrecision)) then
        begin
          for k := j to N-1 do
          begin
            P[k].X := P[k+1].X;
            P[k].Y := P[k+1].Y;
            P[k].Z := P[k+1].Z;
          end;
          N := N - 1;
        end
        Else j := j + 1;
      end;
      i := i + 1;
    end;
    SetLength(P, N + 1);

    NResult := N;   PResult := P;
  end
  Else begin
    NResult := N;  PResult := P;
  end;
end;  { TPoly.RemoveRepeatedPts }

class function TPoly.RemoveRepeatedPts(N : integer; P : TVetor3DPoint) : TVetor3DPoint;
var                              { Remove todos os pontos repetidos da polyline P }
  i, j, k, l : integer;
  P_Aux : TVetorIN;
begin
  If N > 1 then
  begin
    k := 0;
    for i := 1 to N-1 do
    begin
      for j := i+1 to N do
      begin
        If (Equal(P[i].X,P[j].X,RelPrecision)) and
           (Equal(P[i].Y,P[j].Y,RelPrecision)) and
           (Equal(P[i].Z,P[j].Z,RelPrecision)) then
        begin
          RemovePoint(N,P,j,N,P);
        end;
      end;
    end;
    Result := P;
  end
  Else Result := P;
end;  { TPoly.RemoveRepeatedPts }

class function TPoly.Point(Poly : T3DPline; N : integer) : T3DPoint;
begin
  Result.X := Poly.X[N];
  Result.Y := Poly.Y[N];
  Result.Z := Poly.Z[N];
end;  { TPoly.Point }

class function TPoly.SetofPointsToPoly(NPts : integer; Xi, Yi, Zi, Xf, Yf, Zf : TFloatType;
                                       X, Y, Z : TVetorN; Closed : boolean) : T3DPline;
var                                { Transforma conjunto de pontos em uma Poligonal }
  i, j, k : integer;               { sequenciando pontos por menor distância }
  initial, final : integer;
  varaux, Dist, DistMin : TFloatType;
begin
  { Identifica posição dos pontos iniciais e finais fornecidos }
  initial := 0;  final := 0;
  for i := 1 to NPts do
  begin
    If (Equal(X[i],Xi,RelPrecision)) and (Equal(Y[i],Yi,RelPrecision)) and (Equal(Z[i],Zi,RelPrecision)) then
      initial := i;
    If (Equal(X[i],Xf,RelPrecision)) and (Equal(Y[i],Yf,RelPrecision)) and (Equal(Z[i],Zf,RelPrecision)) then
      final := i;
  end;
  { Posiciona ponto inicial como primeiro da série de pontos }
  If initial <> 1 then
  begin
    varaux := X[1];
    X[1] := Xi;
    X[initial] := varaux;

    varaux := Y[1];
    Y[1] := Yi;
    Y[initial] := varaux;

    varaux := Z[1];
    Z[1] := Zi;
    Z[initial] := varaux;
  end;
  { Posiciona ponto final como último da série de pontos }
  If final <> Npts then
  begin
    varaux := X[Npts];
    X[Npts] := Xf;
    X[final] := varaux;

    varaux := Y[Npts];
    Y[Npts] := Yf;
    Y[final] := varaux;

    varaux := Z[Npts];
    Z[Npts] := Zf;
    Z[final] := varaux;
  end;

  for i := 1 to NPts-2 do
  begin
    { Determina o ponto de menor distância a (X[i],Y[i]) }
    k := i+1;
    DistMin := Dist_Points(X[i],Y[i],Z[i],X[k],Y[k],Z[k]);
    for j := i+1 to NPts-1 do
    begin
      Dist := Dist_Points(X[i],Y[i],Z[i],X[j],Y[j],Z[j]);
      If Lower(Dist,DistMin,RelPrecision) then
      begin
        DistMin := Dist;
        k := j;
      end;
    end;
    { Posiciona ponto de menor distância a frente de (X[i],Y[i]) }
    If k <> i+1 then
    begin
      varaux := X[i+1];
      X[i+1] := X[k];
      X[k] := varaux;

      varaux := Y[i+1];
      Y[i+1] := Y[k];
      Y[k] := varaux;

      varaux := Z[i+1];
      Z[i+1] := Z[k];
      Z[k] := varaux;
    end;
  end;

  { Armazena Pontos Ordenados como Polyline }
  If Closed = False then
  begin
    Result.Npoly := NPts;
    Result.Closed := False;
    SetLength(Result.X,Result.Npoly+1);  SetLength(Result.Y,Result.Npoly+1);
    SetLength(Result.Z,Result.Npoly+1);
    for i := 1 to NPts do
    begin
      Result.X[i] := X[i];  Result.Y[i] := Y[i];  Result.Z[i] := Z[i];
    end;
  end
  Else If Closed then
  begin
    If not((Equal(Xi,Xf,RelPrecision)) and (Equal(Yi,Yf,RelPrecision)) and (Equal(Zi,Zf,RelPrecision))) then
    begin
      Result.Npoly := NPts+1;
      Result.Closed := True;
      SetLength(Result.X,Result.Npoly+1);  SetLength(Result.Y,Result.Npoly+1);
      SetLength(Result.Z,Result.Npoly+1);
      for i := 1 to NPts do
      begin
        Result.X[i] := X[i];  Result.Y[i] := Y[i];  Result.Z[i] := Z[i];
      end;
      Result.X[NPts+1] := X[1];  Result.Y[NPts+1] := Y[1];  Result.Z[NPts+1] := Z[1];
    end
    Else
    begin
      Result.Npoly := NPts;
      Result.Closed := True;
      SetLength(Result.X,Result.Npoly+1);  SetLength(Result.Y,Result.Npoly+1);
      SetLength(Result.Z,Result.Npoly+1);
      for i := 1 to NPts do
      begin
        Result.X[i] := X[i];  Result.Y[i] := Y[i];  Result.Z[i] := Z[i];
      end;
    end;
  end;
end;  { TPoly.SetofPointsToPoly }

class function TPoly.SetofPointsToPoly(Xi,Yi,Zi,Xf,Yf,Zf : TFloatType;
                                       Pts : TSetofPoints3D; Closed : boolean) : T3DPline;
var                                { Transforma conjunto de pontos em uma Poligonal }
  i, j, k : integer;               { sequenciando pontos por menor distância }
  initial, final : integer;
  varaux, Dist, DistMin : TFloatType;
begin
  { Identifica posição dos pontos iniciais e finais fornecidos }
  initial := 0;  final := 0;
  for i := 1 to Pts.N do
  begin
    If (Equal(Pts.P[i].X,Xi,RelPrecision)) and (Equal(Pts.P[i].Y,Yi,RelPrecision)) and (Equal(Pts.P[i].Z,Zi,RelPrecision)) then
      initial := i;
    If (Equal(Pts.P[i].X,Xf,RelPrecision)) and (Equal(Pts.P[i].Y,Yf,RelPrecision)) and (Equal(Pts.P[i].Z,Zf,RelPrecision)) then
      final := i;
  end;
  { Posiciona ponto inicial como primeiro da série de pontos }
  If initial <> 1 then
  begin
    varaux := Pts.P[1].X;
    Pts.P[1].X := Xi;
    Pts.P[initial].X := varaux;

    varaux := Pts.P[1].Y;
    Pts.P[1].Y := Yi;
    Pts.P[initial].Y := varaux;

    varaux := Pts.P[1].Z;
    Pts.P[1].Z := Zi;
    Pts.P[initial].Z := varaux;
  end;
  { Posiciona ponto final como último da série de pontos }
  If final <> Pts.N then
  begin
    varaux := Pts.P[Pts.N].X;
    Pts.P[Pts.N].X := Xf;
    Pts.P[final].X := varaux;

    varaux := Pts.P[Pts.N].Y;
    Pts.P[Pts.N].Y := Yf;
    Pts.P[final].Y := varaux;

    varaux := Pts.P[Pts.N].Z;
    Pts.P[Pts.N].Z := Zf;
    Pts.P[final].Z := varaux;
  end;

  for i := 1 to Pts.N-2 do
  begin
    { Determina o ponto de menor distância a (X[i],Y[i]) }
    k := i+1;
    DistMin := Dist_Points(Pts.P[i].X,Pts.P[i].Y,Pts.P[i].Z,
                           Pts.P[k].X,Pts.P[k].Y,Pts.P[k].Z);
    for j := i+1 to Pts.N-1 do
    begin
      Dist := Dist_Points(Pts.P[i].X,Pts.P[i].Y,Pts.P[i].Z,
                          Pts.P[j].X,Pts.P[j].Y,Pts.P[j].Z);
      If Lower(Dist,DistMin,RelPrecision) then
      begin
        DistMin := Dist;
        k := j;
      end;
    end;
    { Posiciona ponto de menor distância a frente de (X[i],Y[i]) }
    If k <> i+1 then
    begin
      varaux := Pts.P[i+1].X;
      Pts.P[i+1].X := Pts.P[k].X;
      Pts.P[k].X := varaux;

      varaux := Pts.P[i+1].Y;
      Pts.P[i+1].Y := Pts.P[k].Y;
      Pts.P[k].Y := varaux;

      varaux := Pts.P[i+1].Z;
      Pts.P[i+1].Z := Pts.P[k].Z;
      Pts.P[k].Z := varaux;
    end;
  end;

  { Armazena Pontos Ordenados como Polyline }
  If Closed = False then
  begin
    Result.Npoly := Pts.N;
    Result.Closed := False;
    SetLength(Result.X,Result.Npoly+1);  SetLength(Result.Y,Result.Npoly+1);
    SetLength(Result.Z,Result.Npoly+1);
    for i := 1 to Pts.N do
    begin
      Result.X[i] := Pts.P[i].X;  Result.Y[i] := Pts.P[i].Y;  Result.Z[i] := Pts.P[i].Z;
    end;
  end
  Else If Closed then
  begin
    If not((Equal(Xi,Xf,RelPrecision)) and (Equal(Yi,Yf,RelPrecision)) and (Equal(Zi,Zf,RelPrecision))) then
    begin
      Result.Npoly := Pts.N+1;
      Result.Closed := True;
      SetLength(Result.X,Result.Npoly+1);  SetLength(Result.Y,Result.Npoly+1);
      SetLength(Result.Z,Result.Npoly+1);
      for i := 1 to Pts.N do
      begin
        Result.X[i] := Pts.P[i].X;  Result.Y[i] := Pts.P[i].Y;  Result.Z[i] := Pts.P[i].Z;
      end;
      Result.X[Pts.N+1] := Pts.P[1].X;  Result.Y[Pts.N+1] := Pts.P[1].Y;  Result.Z[Pts.N+1] := Pts.P[1].Z;
    end
    Else
    begin
      Result.Npoly := Pts.N;
      Result.Closed := True;
      SetLength(Result.X,Result.Npoly+1);  SetLength(Result.Y,Result.Npoly+1);
      SetLength(Result.Z,Result.Npoly+1);
      for i := 1 to Pts.N do
      begin
        Result.X[i] := Pts.P[i].X;  Result.Y[i] := Pts.P[i].Y;  Result.Z[i] := Pts.P[i].Z;
      end;
    end;
  end;
end;  { TPoly.SetofPointsToPoly }

class procedure TPoly.PolyToPoints(Poly : T3DPline; var X, Y, Z : TVetorN);
var
  i : integer;
begin
  SetLength(X,Poly.Npoly+1); SetLength(Y,Poly.Npoly+1); SetLength(Z,Poly.Npoly+1);
  for i := 1 to Poly.Npoly do
  begin
    X[i] := Poly.X[i];  Y[i] := Poly.Y[i];  Z[i] := Poly.Z[i];
  end;
end;  { TPoly.PolyToPoints }

class function TPoly.PointsToPoly(N : integer; X, Y, Z : TVetorN) : T3DPline;
var
  i : integer;
begin
  Result.Npoly := N;
  SetLength(Result.X,N+1); SetLength(Result.Y,N+1); SetLength(Result.Z,N+1);
  for i := 1 to N do
  begin
    Result.X[i] := X[i];  Result.Y[i] := Y[i];  Result.Z[i] := Z[i];
  end;
end;  { TPoly.PointsToPoly }

class function TPoly.VectorToPoly(N : integer; X, Y, Z : TVetorN; Closed : boolean) : T3DPline;
var
  i : integer;
begin
  { Armazena Pontos Ordenados como Polyline }
  If Closed = False then      { Poligonal Aberta }
  begin
    Result.Npoly := N;
    Result.Closed := False;
    SetLength(Result.X,N+1);  SetLength(Result.Y,N+1);  SetLength(Result.Z,N+1);
    for i := 1 to N do
    begin
      Result.X[i] := X[i];  Result.Y[i] := Y[i];  Result.Z[i] := Z[i];
    end;
  end
  Else If Closed then  { Poligonal Fechada }
  begin
    If EqualPoints(Point3D(X[1],Y[1],Z[1]),Point3D(X[N],Y[N],Z[N])) = False then
    begin
      Result.Npoly := N+1;
      SetLength(Result.X,N+2);  SetLength(Result.Y,N+2);  SetLength(Result.Z,N+2);
      Result.X[N+1] := X[1];  Result.Y[N+1] := Y[1];  Result.Z[N+1] := Z[1];
    end
    Else
    begin
      Result.Npoly := N;
      SetLength(Result.X,N+1);  SetLength(Result.Y,N+1);  SetLength(Result.Z,N+1);
    end;
    Result.Closed := True;
    for i := 1 to N do
    begin
      Result.X[i] := X[i];  Result.Y[i] := Y[i];  Result.Z[i] := Z[i];
    end;
  end;
end;  { TPoly.VectorToPoly }

class procedure TPoly.WireToPoints(Wire : TWire; var N : integer; var Npoly : TVetorIN; var X, Y, Z : TMatrizNxN);
var
  i , j : integer;
begin
  N := Wire.N;
  SetLength(Npoly,N+1);
  SetLength(X, N+1);  SetLength(Y, N+1);  SetLength(Z, N+1);
  for i := 1 to N do
  begin
    Npoly[i] := Wire.P[i].Npoly;
    SetLength(X[i],Npoly[i]+1);  SetLength(Y[i], Npoly[i]+1);  SetLength(Z[i], Npoly[i]+1);
    for j := 1 to NPoly[i] do
    begin
      X[i,j] := Wire.P[i].X[j];  Y[i,j] := Wire.P[i].Y[j];  Z[i,j] := Wire.P[i].Z[j];
    end;
  end;

end;  { TPoly.WireToPoints }

class function TPoly.Trim_Plan(Poly : T3DPline; X1,Y1,Z1,XN,YN,ZN : TFloatType) : TWire;
var                              { Corta Poly por um plano, mantendo os segmentos do mesmo }
  i, j, k, l, m : integer;       { lado para que o vetor normal do plano aponta }
  Intersect : boolean;           { Esse lado é chamado de Lado Positivo do Plano (L+ Plano) }
  X,Y,Z : TFloatType;
  Ns : TVetorIN;
  Xs,Ys,Zs : TVetorN;
  Id : TVetorIN;   strmsg, strmsg2 : string;
begin
  { Search for Intersections }
  i := 0;  j := 0;  Result.N := 0;  Intersect := False;

  repeat
  begin
    i := i + 1;
    { Detect Intersection }
    Line_Plan_Intersection(Poly.X[i],Poly.Y[i],Poly.Z[i],Poly.X[i+1],Poly.Y[i+1],Poly.Z[i+1],
                           X1,Y1,Z1,XN,YN,ZN,Intersect,X,Y,Z);

    If Intersect = True then  { Mark the limits of the polylines by the intersections }
    begin
      j := j + 1;
      SetLength(Ns,j+1);
      SetLength(Xs,j+1);  SetLength(Ys,j+1);  SetLength(Zs,j+1);
      Xs[j] := X;         Ys[j] := Y;         Zs[j] := Z;

      { Add Intersection Points to the Original Polyline }
      If Not((EqualPoints(Point3D(X,Y,Z),Point3D(Poly.X[i],Poly.Y[i],Poly.Z[i])))
         or  (EqualPoints(Point3D(X,Y,Z),Point3D(Poly.X[i+1],Poly.Y[i+1],Poly.Z[i+1])))) then
      begin
        Poly := AddNewPoint(Poly,X,Y,Z,i);  i := i + 1;
        Ns[j] := i;
      end
      Else If EqualPoints(Point3D(X,Y,Z),Point3D(Poly.X[i],Poly.Y[i],Poly.Z[i])) then
        Ns[j] := i
      Else If EqualPoints(Point3D(X,Y,Z),Point3D(Poly.X[i+1],Poly.Y[i+1],Poly.Z[i+1])) then
      begin
        Ns[j] := i+1;  i := i + 1;
      end;
    end;
  end;
  until(i >= Poly.Npoly-1);

  {strmsg := 'Total of Intersections '+IntToStr(j)+char(13);
  for i := 1 to j do
  begin
    strmsg := strmsg + 'Intersection '+IntToStr(i)+char(13);
    strmsg := strmsg + 'N' + char(9) + 'X' + char(9) + 'Y' + char(9) + 'Z' + char(13);
    strmsg := strmsg + IntToStr(Ns[i]) + char(9)+PointToStr(Xs[i],Ys[i],Zs[i],char(9),fffixed,7,3)+char(13);
  end;
  //ShowMessage(strmsg);

  strmsg := strmsg + 'N' + char(9) + 'X' + char(9) + 'Y' + char(9) + 'Z' + char(13);
  for i := 1 to Poly.Npoly do
    strmsg := strmsg + IntToStr(i) + char(9) + PointToStr(Poly.X[i],Poly.Y[i],Poly.Z[i],char(9),fffixed,18,7) + char(13);
  ShowMessage(strmsg);}


  If j > 0 then
  begin
    (*strmsg := 'N' + char(9) + 'X' + char(9) + 'Y' + char(9) + 'Z' + char(13);
    strmsg := strmsg + 'I1' + char(9)+PointToStr(Xs[1],Ys[1],Zs[1],fffixed,18,18)+char(13);
    strmsg := strmsg + 'P1' + char(9)+PointToStr(Poly.X[1],Poly.Y[1],Poly.Z[1],fffixed,18,18)+char(13);
    ShowMessage(strmsg);*)
    { First Polyline, before first intersection }
    If (Equal(Xs[1],Poly.X[1],RelPrecision)=False) or (Equal(Ys[1],Poly.Y[1],RelPrecision)=False) or
       (Equal(Zs[1],Poly.Z[1],RelPrecision)=False) then
    begin
      //ShowMessage('First Polyline');
      Result.N := Result.N + 1;  k := Result.N;  SetLength(Result.P,k+1);
      for i := 1 to Ns[1] do
      begin
        Result.P[k].Npoly := i;
        SetLength(Result.P[k].X,i+1); SetLength(Result.P[k].Y,i+1); SetLength(Result.P[k].Z,i+1);
        Result.P[k].X[i] := Poly.X[i]; Result.P[k].Y[i] := Poly.Y[i]; Result.P[k].Z[i] := Poly.Z[i];
      end;
    end;

    { Polylines between each pair of intersections }
    If j > 1 then
    begin
      //ShowMessage('Intermediate Polylines');
      for i := 1 to j-1 do
      begin
        If Ns[i+1]>Ns[i]+1 then   { If the intersection points are not consecutive }
        begin
          Result.N := Result.N + 1;  m := Result.N;  SetLength(Result.P,m+1);
          l := 0;
          for k := Ns[i] to Ns[i+1] do
          begin
            l := l + 1;  Result.P[m].Npoly := l;
            SetLength(Result.P[m].X,l+1); SetLength(Result.P[m].Y,l+1); SetLength(Result.P[m].Z,l+1);
            Result.P[m].X[l] := Poly.X[k]; Result.P[m].Y[l] := Poly.Y[k]; Result.P[m].Z[l] := Poly.Z[k];
          end;
        end;
      end;
    end;

    { Last Polyline, after the last intersection }
    m := Poly.Npoly;
    (*strmsg := 'N' + char(9) + 'X' + char(9) + 'Y' + char(9) + 'Z' + char(13);
    strmsg := strmsg + 'IN' + char(9)+PointToStr(Xs[j],Ys[j],Zs[j],fffixed,18,18)+char(13);
    strmsg := strmsg + 'PN' + char(9)+PointToStr(Poly.X[m],Poly.Y[m],Poly.Z[m],fffixed,18,18)+char(13);
    ShowMessage(strmsg);*)
    If (Equal(Xs[j],Poly.X[m],RelPrecision)=False) or (Equal(Ys[j],Poly.Y[m],RelPrecision)=False) or
       (Equal(Zs[j],Poly.Z[m],RelPrecision)=False) then
    begin
      //ShowMessage('Last Polyline');
      Result.N := Result.N + 1;  k := Result.N;  SetLength(Result.P,k+1);
      l := 0;
      for i := Ns[j] to m do
      begin
        l := l + 1;  Result.P[k].Npoly := l;
        SetLength(Result.P[k].X,l+1); SetLength(Result.P[k].Y,l+1); SetLength(Result.P[k].Z,l+1);
        Result.P[k].X[l] := Poly.X[i]; Result.P[k].Y[l] := Poly.Y[i]; Result.P[k].Z[l] := Poly.Z[i];
      end;
    end;

    {If Result.N > 0 then
      for i := 1 to Result.N do
      begin
        ShowMessage('Result Total '+PointToStr(X1,Y1,Z1,fffixed,7,3)+char(13)+'i '+IntToStr(i)+' of '+IntToStr(Result.N)+
        char(13)+'N'+char(9)+'X'+char(9)+'Y'+char(9)+'Z'+char(13)+PolyToStr(Result.P[i],fffixed,7,3));
      end
    Else If Result.N = 0 then
      ShowMessage('Result Total '+PointToStr(X1,Y1,Z1,fffixed,7,3)+char(13)+'i '+IntToStr(0)+' of '+IntToStr(Result.N));}

    (*{ Delete polylines outside plan positive side }
    j := 0;
    for i := 1 to Result.N do
    begin
      If InsidePlanBoundary(Result.P[i],X1,Y1,Z1,XN,YN,ZN) = False then
      begin
        j := j + 1;  SetLength(Id,j+1);
        Id[j] := i;
      end;
    end;
    If j > 0 then
      Result := TSetofPoly.DeleteListofPoly(j,Id,Result);*)

    { Delete polylines totally inside the plan }
    j := 0;
    for i := 1 to Result.N do
    begin
      If InsidePlan(Result.P[i],X1,Y1,Z1,XN,YN,ZN) then
      begin
        j := j + 1;  SetLength(Id,j+1);
        Id[j] := i;
      end;
    end;
    If j > 0 then
      Result := TSetofPoly.DeleteListofPoly(j,Id,Result);

    {If Result.N > 0 then
      for i := 1 to Result.N do
      begin
        ShowMessage('Result Slice '+PointToStr(X1,Y1,Z1,fffixed,7,3)+char(13)+'i '+IntToStr(i)+' of '+IntToStr(Result.N)+
        char(13)+'N'+char(9)+'X'+char(9)+'Y'+char(9)+'Z'+char(13)+PolyToStr(Result.P[i],fffixed,7,3));
      end
    Else If Result.N = 0 then
      ShowMessage('Result Slice '+PointToStr(X1,Y1,Z1,fffixed,7,3)+char(13)+'i '+IntToStr(0)+' of '+IntToStr(Result.N));}
  end
  Else If j = 0 then { None intersections }
  begin
    Result.N := 0;
    //If Greater(Dist_PointToPlan(Poly.X[1],Poly.Y[1],Poly.Z[1],X1,Y1,Z1,XN,YN,ZN),0,RelPrecision) then
    begin            { Polyline Must be at the same side of Normal Vector }
      Result.N := 1;  SetLength(Result.P,2);
      Result.P[1] := Poly;
    end;
  end;

end;  { TPoly.Trim_Plan }

class function TPoly.Trim_PlanTriangle(Poly : T3DPline; X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3 : TFloatType) : TWire;
var                               { Corta Poly por um plano, mantendo os segmentos do mesmo }
  XN, YN, ZN : TFloatType;              { lado para que o vetor normal do plano aponta }
begin                             { Esse lado é chamado de Lado Positivo do Plano (L+ Plano) }
  { Vetor Normal do Plano }
  ProdutoVetorial(X3-X1,Y3-Y1,Z3-Z1,X2-X1,Y2-Y1,Z2-Z1,XN,YN,ZN);
  { Trim da Polyline }
  Result := Trim_Plan(Poly,X1,Y1,Z1,XN,YN,ZN);
end;  { TPoly.Trim_PlanTriangle }

class procedure TPoly.Uniform_Poly3D(NpontosE : integer; NpontosS : integer;
                                     Xpol : TVetorN; Ypol : TVetorN; Zpol : TVetorN;
                                     var NpontosF : integer;
                                     var XpolF : TVetorN; var YpolF : TVetorN; var ZpolF : TVetorN);
var                                   { Aumenta número de pontos de uma Polyline 3D de NpontosE para NpontosS }
  i,j,k,ic : integer;
  PerimetroAc,PassosAc : TVetorN;     { NpontosE : número de pontos de entrada }
  XpolAux,YpolAux,ZpolAux : TVetorN;          { NpontosS : número de pontos de saída }
  XpolAux2,YpolAux2,ZpolAux2 : TFloatType;
  Perimetro,CPassos : TFloatType;
  passoD : TFloatType;
  PontosAdicionais: integer;
  V : T3DPoint;
begin
                                      { PerimetroAc,PassosAc : TVetorN; XpolAux,YpolAux : TVetorN; }
  Perimetro := 0;
  SetLength(PerimetroAc,NpontosE+1);
  for i := 1 to NpontosE do
  begin
    if i = 1 then
    begin
      Perimetro := 0;
      PerimetroAc[i] := Perimetro;
    end
    else
    begin
      Perimetro := Perimetro + sqrt(sqr(Xpol[i]-Xpol[i-1])+sqr(Ypol[i]-Ypol[i-1])+sqr(Zpol[i]-Zpol[i-1]));
      PerimetroAc[i] := Perimetro;
    end;
  end;

  passoD := Perimetro/(NpontosS-NpontosE+1);
  CPassos := 0;
  SetLength(PassosAc,NpontosS-NpontosE+1);
  for i := 1 to NpontosS-NpontosE do
  begin
    CPassos := CPassos + passoD;
    PassosAc[i] := CPassos;
  end;
   SetLength(XpolAux,NpontosE+1);
   SetLength(YpolAux,NpontosE+1);
   SetLength(ZpolAux,NpontosE+1);
   for i := 1 to NpontosE do
   begin
     XpolAux[i] := Xpol[i];
     YpolAux[i] := Ypol[i];
     ZpolAux[i] := Zpol[i];
   end;
   PontosAdicionais := NpontosS-NpontosE;

   if NpontosS > NpontosE then
   begin
   for j := 1 to PontosAdicionais do
   begin
     ic := 0;
     for i := 2 to NpontosE do
     begin
       if (BetweenEq(PassosAc[j],PerimetroAc[i-1],PerimetroAc[i],RelPrecision)) and (ic = 0) then
       begin
         XpolAux2 := XpolAux[i-1] + ((XpolAux[i]-XpolAux[i-1])/sqrt(sqr(XpolAux[i]-XpolAux[i-1])+
                                     sqr(YpolAux[i]-YpolAux[i-1])+sqr(ZpolAux[i]-ZpolAux[i-1])))*(PassosAc[j]-PerimetroAc[i-1]);
         YpolAux2 := YpolAux[i-1] + ((YpolAux[i]-YpolAux[i-1])/sqrt(sqr(XpolAux[i]-XpolAux[i-1])+
                                     sqr(YpolAux[i]-YpolAux[i-1])+sqr(ZpolAux[i]-ZpolAux[i-1])))*(PassosAc[j]-PerimetroAc[i-1]);
         ZpolAux2 := ZpolAux[i-1] + ((ZpolAux[i]-ZpolAux[i-1])/sqrt(sqr(XpolAux[i]-XpolAux[i-1])+
                                     sqr(YpolAux[i]-YpolAux[i-1])+sqr(ZpolAux[i]-ZpolAux[i-1])))*(PassosAc[j]-PerimetroAc[i-1]);

         SetLength(XpolAux,NpontosE+2);
         SetLength(YpolAux,NpontosE+2);
         SetLength(ZpolAux,NpontosE+2);
         SetLength(PerimetroAc,NpontosE+2);
         for k := NpontosE downto i do
         begin
           XpolAux[k+1] := XpolAux[k];
           YpolAux[k+1] := YpolAux[k];
           ZpolAux[k+1] := ZpolAux[k];
           PerimetroAc[k+1] := PerimetroAc[k];
         end;
         XpolAux[i] := XpolAux2;
         YpolAux[i] := YpolAux2;
         ZpolAux[i] := ZpolAux2;
         PerimetroAc[i] := PassosAc[j];
         NpontosE := NpontosE + 1;
         ic := 1;
       end;
     end;
  end;
  end;
  SetLength(XpolF,NpontosE+1);  SetLength(YpolF,NpontosE+1);  SetLength(ZpolF,NpontosE+1);
  for i := 1 to NpontosE do
  begin
    XpolF[i] := XpolAux[i]; YpolF[i] := YpolAux[i];  ZpolF[i] := ZpolAux[i];
  end;
  NpontosF := NpontosE;

end;  { TPoly.Uniform_Poly3D }

class function TPoly.IncreasePoints(N, First, Last : integer; P : T3DPline) : T3DPline;
var                                   { Increase N points on a Polyline 3D following }
  i,j,k,l,ic : integer;                 { the linear perimeter from First to Last }
  NpointsE, NpointsO : integer;       { NpointsE, NpointsO : entrance and output number of points }
  Perimeter : TFloatType;
  AcPerimeter,StepMultiple : TVetorN;
  step : TFloatType;
  PR : T3DPline;
  V : T3DPoint;
  XR,YR,ZR : TFloatType;
begin
  i := First;  First := Min(i,Last);  Last := Max(i,Last);
  NpointsE := Last-First+1;
  Result := P;  PR := P;
  If (NpointsE > 1) and (N > 0) then
  begin
    SetLength(AcPerimeter,NpointsE+1);
    Perimeter := 0;  AcPerimeter[1] := 0;
    for i := First to Last-1 do
    begin
      Perimeter := Perimeter + Dist_Points(P.X[i+1],P.Y[i+1],P.Z[i+1],P.X[i],P.Y[i],P.Z[i]);
      AcPerimeter[i-First+2] := Perimeter;
    end;

    NpointsO := NpointsE+N;

    step := Perimeter/(N+1);
    SetLength(StepMultiple,N+1);
    for i := 1 to N do
      StepMultiple[i] := i*step;

    for j := 1 to N do
    begin
      ic := 0;
      for i := 2 to NpointsE do
      begin
        if (BetweenEq(StepMultiple[j],AcPerimeter[i-1],AcPerimeter[i],RelPrecision)) and (ic = 0) then
        begin
          l := i+First-1;
          If EqualPoints(PR.X[l-1],PR.Y[l-1],PR.Z[l-1],PR.X[l],PR.Y[l],PR.Z[l]) = False then
          begin
            V := VetorUnitario(Point3D(PR.X[l]-PR.X[l-1],PR.Y[l]-PR.Y[l-1],PR.Z[l]-PR.Z[l-1]));
            XR := PR.X[l-1] + (V.X*(StepMultiple[j]-AcPerimeter[i-1]));
            YR := PR.Y[l-1] + (V.Y*(StepMultiple[j]-AcPerimeter[i-1]));
            ZR := PR.Z[l-1] + (V.Z*(StepMultiple[j]-AcPerimeter[i-1]));

            SetLength(PR.X,PR.Npoly+2);  SetLength(PR.Y,PR.Npoly+2);  SetLength(PR.Z,PR.Npoly+2);
            for k := PR.Npoly downto l do
            begin
              PR.X[k+1] := PR.X[k];  PR.Y[k+1] := PR.Y[k];  PR.Z[k+1] := PR.Z[k];
            end;
            PR.X[l] := XR;  PR.Y[l] := YR;  PR.Z[l] := ZR;
            Inc(PR.Npoly);

            SetLength(AcPerimeter,NpointsE+2);
            for k := NpointsE downto i do
              AcPerimeter[k+1] := AcPerimeter[k];
            AcPerimeter[i] := StepMultiple[j];
            Inc(NpointsE);
            ic := 1;
          end;
        end;
      end;
    end;
  end;
  Result := PR;
  Result.Closed := not Gap(Result);
end;  { TPoly.IncreasePoints }

class procedure TPoly.Uniform_SetofPoly3D_Max(N : integer; Npoly : TVetorIN; X, Y , Z : TMatrizNxN;
                                  Sym : boolean; X1,Y1,Z1,XN,YN,ZN : TFloatType;
                                  var NpolyResult : TVetorIN; var XResult, YResult, ZResult : TMatrizNxN);
var
  i, j, k :integer;
  nnMax : integer;
begin
   { Maior número de pontos das Poligonais }
    nnMax := Npoly[1];
    for i := 1 to N do
    begin
      If Npoly[i]>nnMax then
        nnMax := Npoly[i];
    end;
    { Uniformização do Número de Pontos em cada Poligonal }

    SetLength(XResult,N+1);  SetLength(YResult,N+1);  SetLength(ZResult,N+1);
    for i := 1 to N do
    begin
      Uniform_Poly3D(Npoly[i],nnMax,X[i],Y[i],Z[i],NpolyResult[i],XResult[i],YResult[i],ZResult[i]);

      If Sym then
      begin
        k := 2*NPolyResult[i];
        SetLength(XResult[i],k+1);
        SetLength(YResult[i],k+1);
        SetLength(ZResult[i],k+1);
        { Pontos - SIMÉTRICOS }
        for j := (NPolyResult[i]+1) to k do
          MirrorToPlan(X1,Y1,Z1,XN,YN,ZN,XResult[i,k-j+1],YResult[i,k-j+1],ZResult[i,k-j+1],
                         XResult[i,j],YResult[i,j],ZResult[i,j]);
        NPolyResult[i] := 2*NPolyResult[i];
      end;
    end;
end;  { TPoly.Uniform_SetofPoly3D_Max }

{---------------------------------------------------------------------------------------------------}
{                                           TSetofPoints                                            }
{                                                                                                   }
{ TSetofPoints class gather all algorithms related to the construction of Sets of 3D Points         }
{---------------------------------------------------------------------------------------------------}

class function TSetofPoints.Reset(Pts : TSetofPoints3D) : TSetofPoints3D;
begin
  with Result do
  begin
    N := 0;  SetLength(P,1);
  end;
end;  { TSetofPoints.ResetofPoints }

class function TSetofPoints.AddPoint(Pts : TSetofPoints3D; X, Y, Z : TFloatType; N : integer) : TSetofPoints3D;
  var                    { Acrescenta novo ponto (X,Y,Z) ao conjunto de pontos Pts }
  i : integer;           { a frente da posição N dos pontos }
  repeated : boolean;
begin
  repeated := False;
  { Verifica se o ponto (X,Y,Z) é repetido }
  for i := 1 to Pts.N do
    If (Equal(X,Pts.P[i].X,RelPrecision)) and
       (Equal(Y,Pts.P[i].Y,RelPrecision)) and
       (Equal(Z,Pts.P[i].Z,RelPrecision)) then
      repeated := True;
  { Se for repetido, o resultado são os pontos originais }
  If repeated then
  begin
    Result := Pts;
  end
  { Se não for repetido, acrescenta o ponto a frente da posição N }
  Else If repeated = False then
  begin
    Result.N := Pts.N+1;  SetLength(Result.P,Result.N+1);
    If (1<=N) and (N<=Pts.N-1) then    { N E [1,Pts.N-1] }
    begin
      for i := 1 to N do
      begin
        Result.P[i].X := Pts.P[i].X;  Result.P[i].Y := Pts.P[i].Y;  Result.P[i].Z := Pts.P[i].Z;
      end;
      Result.P[N+1].X := X;  Result.P[N+1].Y := Y;  Result.P[N+1].Z := Z;
      for i := N+2 to Result.N do
      begin
        Result.P[i].X := Pts.P[i-1].X;  Result.P[i].Y := Pts.P[i-1].Y;  Result.P[i].Z := Pts.P[i-1].Z;
      end;
    end
    Else If N = 0 then                      { N = 0 }
    begin
      for i := 1 to Pts.N do
      begin
        Result.P[i+1].X := Pts.P[i].X;  Result.P[i+1].Y := Pts.P[i].Y;  Result.P[i+1].Z := Pts.P[i].Z;
      end;
      Result.P[1].X := X;  Result.P[1].Y := Y;  Result.P[1].Z := Z;
    end
    Else If N = Pts.N then             { N = Pts.N }
    begin
      for i := 1 to Pts.N do
      begin
        Result.P[i].X := Pts.P[i].X;  Result.P[i].Y := Pts.P[i].Y;  Result.P[i].Z := Pts.P[i].Z;
      end;
      Result.P[Pts.N+1].X := X;  Result.P[Pts.N+1].Y := Y;  Result.P[Pts.N+1].Z := Z;
    end;
  end;
end;  { TSetofPoints.AddPoint }

class function TSetofPoints.Join(Pts1, Pts2 : TSetofPoints3D) : TSetofPoints3D;
var                { Une os conjuntos de pontos Pts1 e Pts2 em uma Result, }
  i : integer;     { adicionando os pontos de Pts2 a Pts1 a partir }
begin              { da extremidade final de Pts1 }
  If (Pts1.N > 0) and (Pts2.N > 0) then
  begin
    Result := Pts1;

    If (Equal(Pts1.P[Pts1.N].X,Pts2.P[1].X,RelPrecision)) and
       (Equal(Pts1.P[Pts1.N].Y,Pts2.P[1].Y,RelPrecision)) and
       (Equal(Pts1.P[Pts1.N].Z,Pts2.P[1].Z,RelPrecision)) then
      Result.N := Pts1.N + Pts2.N - 1
    Else
     Result.N := Pts1.N + Pts2.N;

    SetLength(Result.P,Result.N+1);
    for i := Pts1.N+1 to Result.N do
    begin
      Result.P[i].X := Pts2.P[i-Result.N+Pts2.N].X;
      Result.P[i].Y := Pts2.P[i-Result.N+Pts2.N].Y;
      Result.P[i].Z := Pts2.P[i-Result.N+Pts2.N].Z;
    end;
  end
  Else If (Pts1.N > 0) and (Pts2.N = 0) then
    Result := Pts1
  Else If (Pts1.N = 0) and (Pts2.N > 0) then
    Result := Pts2
  Else If (Pts1.N = 0) and (Pts2.N = 0) then
    Result := Reset(Result);
end;  { TSetofPoints.Join }

class procedure TSetofPoints.MinXPoint(Pt : TSetofPoints3D; var X, Y, Z : TFloatType);
var
  i : integer;
begin
  X := Pt.P[1].X;  Y := Pt.P[1].Y;  Z := Pt.P[1].Z;
  for i := 1 to Pt.N do
    If Lower(Pt.P[i].X,X,RelPrecision) then
    begin
      X := Pt.P[i].X;  Y := Pt.P[i].Y;  Z := Pt.P[i].Z;
    end;
end;  { TSetofPoints.MinXPoint }

class procedure TSetofPoints.MaxXPoint(Pt : TSetofPoints3D; var X, Y, Z : TFloatType);
var
  i : integer;
begin
  X := Pt.P[1].X;  Y := Pt.P[1].Y;  Z := Pt.P[1].Z;
  for i := 1 to Pt.N do
    If Greater(Pt.P[i].X,X,RelPrecision) then
    begin
      X := Pt.P[i].X;  Y := Pt.P[i].Y;  Z := Pt.P[i].Z;
    end;
end;  { TSetofPoints.MaxXPoint }

class procedure TSetofPoints.MinYPoint(Pt : TSetofPoints3D; var X, Y, Z : TFloatType);
var
  i : integer;
begin
  X := Pt.P[1].X;  Y := Pt.P[1].Y;  Z := Pt.P[1].Z;
  for i := 1 to Pt.N do
    If Lower(Pt.P[i].Y,Y,RelPrecision) then
    begin
      X := Pt.P[i].X;  Y := Pt.P[i].Y;  Z := Pt.P[i].Z;
    end;
end;  { TSetofPoints.MinYPoint }

class procedure TSetofPoints.MaxYPoint(Pt : TSetofPoints3D; var X, Y, Z : TFloatType);
var
  i : integer;
begin
  X := Pt.P[1].X;  Y := Pt.P[1].Y;  Z := Pt.P[1].Z;
  for i := 1 to Pt.N do
    If Greater(Pt.P[i].Y,Y,RelPrecision) then
    begin
      X := Pt.P[i].X;  Y := Pt.P[i].Y;  Z := Pt.P[i].Z;
    end;
end;  { TSetofPoints.MaxYPoint }

class procedure TSetofPoints.MinZPoint(Pt : TSetofPoints3D; var X, Y, Z : TFloatType);
var
  i : integer;
begin
  X := Pt.P[1].X;  Y := Pt.P[1].Y;  Z := Pt.P[1].Z;
  for i := 1 to Pt.N do
    If Lower(Pt.P[i].Z,Z,RelPrecision) then
    begin
      X := Pt.P[i].X;  Y := Pt.P[i].Y;  Z := Pt.P[i].Z;
    end;
end;  { TSetofPoints.MinZPoint }

class procedure TSetofPoints.MaxZPoint(Pt : TSetofPoints3D; var X, Y, Z : TFloatType);
var
  i : integer;
begin
  X := Pt.P[1].X;  Y := Pt.P[1].Y;  Z := Pt.P[1].Z;
  for i := 1 to Pt.N do
    If Greater(Pt.P[i].Z,Z,RelPrecision) then
    begin
      X := Pt.P[i].X;  Y := Pt.P[i].Y;  Z := Pt.P[i].Z;
    end;
end;  { TSetofPoints.MaxZPoint }


{---------------------------------------------------------------------------------------------------}
{                                           TSetofPoly                                              }
{                                                                                                   }
{ TSetofPoly class gather all algorithms related to the construction of Sets of Polylines           }
{---------------------------------------------------------------------------------------------------}

class function TSetofPoly.InsideXBoundary(PolySet : TWire; X1, X2 : TFloatType; var N : integer) : TVetorIN;
var                 { Identifica as polylines de PolySet que verificam X E [X1,X2] }
  i : integer;
begin
  N := 0;
  for i := 1 to PolySet.N do
  begin
    If TPoly.InsideXBoundary(PolySet.P[i],X1,X2) then
    begin
      N := N + 1;  SetLength(Result,N+1);  Result[N] := i;
    end;
  end;
end;  { TSetofPoly.InsideXBoundary }

class function TSetofPoly.InXCoordinate(PolySet : TWire; X : TFloatType; var N : integer) : TVetorIN;
var              { Identifica as polylines i de PolySet que verificam PolySet.P[i].X E X }
  i : integer;
begin
  N := 0;
  for i := 1 to PolySet.N do
  begin
    If TPoly.InXCoordinate(PolySet.P[i],X) then
    begin
      N := N + 1;  SetLength(Result,N+1);  Result[N] := i;
    end;
  end;
end;  { TSetofPoly.InXCoordinate }

class function TSetofPoly.Subset(N : integer; ID : TVetorIN; PolySet : TWire) : TWire;
var                       { Cria um subconjunto de PolySet apenas com as N polylines }
  i : integer;            { listadas em ID }
begin
  Result := Reset(Result);
  SetLength(Result.P,N+1);
  Result.N := N;
  for i := 1 to N do
  begin
    Result.P[i] := PolySet.P[ID[i]];
  end;
end;  { TSetofPoly.Subset }

class function TSetofPoly.AddPoly(PolySet : TWire; Poly : T3DPline; N : integer) : TWire;
var                    { Acrescenta a polyline Poly à PolySet a frente da }
  i : integer;         { posição N de PolySet }
begin
  { Acrescenta Poly a frente da posição N }
  Result.N := PolySet.N+1;
  SetLength(Result.P,Result.N+1);
  If (1<=N) and (N<=PolySet.N-1) then    { Se N E [1,PolySet.N-1] }
  begin
    for i := 1 to N do
      Result.P[i] := PolySet.P[i];
    Result.P[N+1] := Poly;
    for i := N+2 to Result.N do
      Result.P[i] := PolySet.P[i-1];
  end
  Else If N = 0 then                      { Se N = 0 }
  begin
    for i := 1 to PolySet.N do
      Result.P[i+1] := PolySet.P[i];
    Result.P[1] := Poly;
  end
  Else If N = PolySet.N then             { Se N = PolySet.N }
  begin
    for i := 1 to PolySet.N do
      Result.P[i] := PolySet.P[i];
    Result.P[PolySet.N+1] := Poly;
  end;
end;  { TSetofPoly.AddPoly }

class procedure TSetofPoly.AddPoly(Poly : T3DPline; Index : integer; var P : TWire);
var                    { Acrescenta a polyline Poly à PolySet a frente da }
  i, N : integer;      { posição Index de PolySet }
begin
  N := High(P.P);
  SetLength(P.P,High(P.P)+2);
  If (0<=Index) and (Index<=N-1) then    { Index E [1,N-1] }
  begin
    for i := N downto Index+1 do
      P.P[i+1] := P.P[i];
    P.P[Index+1] := Poly;
  end
  Else If Index = N then           { Index = N }
    P.P[Index+1] := Poly;
  P.N := High(P.P);
end;  { TSetofPoly.AddPoly }

class function TSetofPoly.Delete(N : integer; PolySet : TWire) : TWire;
var                       { Deleta a N-ésima polyline de PolySet }
  i : integer;
begin
  Result.N := PolySet.N-1;
  SetLength(Result.P,Result.N+1);
  If (1<=N) and (N<PolySet.N) then
  begin
    for i := 1 to N do
      Result.P[i] := PolySet.P[i];

    for i := N to PolySet.N-1 do
      Result.P[i] := PolySet.P[i+1];
  end
  Else If N = PolySet.N then
  begin
    for i := 1 to PolySet.N-1 do
      Result.P[i] := PolySet.P[i];
  end;
end;  { TSetofPoly.Delete }

class function TSetofPoly.DeleteListofPoly(N : integer; ID : TVetorIN; PolySet : TWire) : TWire;
var                       { Deleta de PolySet as N polylines listadas em ID }
  i, j : integer;
  listed : boolean;
begin
  { Inicializa Result }
  Result := Reset(Result);
  { Passa por cada polyline de PolySet }
  for i := 1 to PolySet.N do
  begin
    listed := False;
    j := 0;
    { Verifica se a polyline está na lista de exclusão }
    repeat
    begin
      j := j + 1;
      If i = ID[j] then
        listed := True;
    end;
    until((j = N) or (listed));

    If listed = False then
    begin
      Result.N := Result.N + 1;  SetLength(Result.P,Result.N+1);
      Result.P[Result.N] := PolySet.P[i];
    end;
  end;
end;  { TSetofPoly.DeleteListofPoly }

class function TSetofPoly.PolyWithPtInCommon(Poly : T3DPline; PolySet : TWire; var N : integer) : TVetorIN;
var                      { Result revela a ordem das N polylines de PolySet com ponto em comum com Poly }
  i, l, m : integer;
begin
  N := 0;
  for i := 1 to PolySet.N do
  begin
    If TPoly.PtInCommon(Poly,PolySet.P[i],l,m) then
    begin
      N := N + 1;  SetLength(Result,N+1);  Result[N] := i;
    end;
  end;
end;  { TSetofPoly.PtInCommon }

class function TSetofPoly.Reset(PolySet : TWire) : TWire;
begin
  PolySet.N := 0;
  SetLength(PolySet.P,1);
  PolySet.P[0] := TPoly.Reset(PolySet.P[0]);
  Result := PolySet;
end;  { TSetofPoly.Reset }

class function TSetofPoly.Trim_Plan(PolySet : TWire; X1,Y1,Z1,XN,YN,ZN : TFloatType) : TWire;
var                       { Corta o conjunto de polígonos PolySet por um plano, mantendo os }
  i : integer;            { segmentos do mesmo lado para que o vetor normal do plano aponta }
  PolySetNew : TWire;     { Esse lado é chamado de Lado Positivo do Plano (L+ Plano) }
begin
  Result := Reset(Result);
  for i := 1 to PolySet.N do
  begin
    PolySetNew := Reset(PolySetNew);
    PolySetNew := TPoly.Trim_Plan(PolySet.P[i],X1,Y1,Z1,XN,YN,ZN);

    If PolySetNew.N > 0 then   { Se existir interseção, acrescenta ao conjunto }
      Result := Join(Result,PolySetNew);
  end;

  (*PolySetNew.N := 0;
  j := 1;
  { Determina a primeira Polyline de PolySet em (L+ Plano) }
  { gerando o primeiro conjunto de Polylines em (L+ Plano) }
  repeat
  begin
    PolySetNew := TPoly.Trim_Plan(PolySet.P[j],X1,Y1,Z1,XN,YN,ZN);
    j := j + 1;
  end;
  until((PolySetNew.N <> 0) or (j = PolySet.N+1));

  If PolySetNew.N <> 0 then  { Se existe algum conjunto em (L+ Plano) }
  begin
    Result := PolySetNew;
    { Determina os demais conjuntos em (L+ Plano) }
    for i := j to PolySet.N do
    begin
      PolySetNew := TPoly.Trim_Plan(PolySet.P[i],X1,Y1,Z1,XN,YN,ZN);

      If PolySetNew.N <> 0 then   { Se existir interseção, acrescenta ao conjunto }
        Result := Join(Result,PolySetNew);
    end;
  end
  Else If PolySetNew.N = 0 then
  begin
    Result.N := 0;
  end;*)
end;  { TSetofPoly.Trim_Plan }

class function TSetofPoly.Slice_Plan(PolySet : TWire; X1,Y1,Z1,XN,YN,ZN : TFloatType) : TWire;
var                               { Divide conjuntos de poligonais por um plano }
  PolySetLP, PolySetLN : TWire;  i : integer;
begin
  { Corte de PolySet do Lado Positivo do Plano - PolySetLP }
  PolySetLP := Trim_Plan(PolySet,X1,Y1,Z1,XN,YN,ZN);

  { Corte de PolySet do Lado Negativo do Plano - PolySetLN }
  PolySetLN := Trim_Plan(PolySet,X1,Y1,Z1,-XN,-YN,-ZN);
  { Une os dois cortes em um único conjunto }
  Result := Join(PolySetLP,PolySetLN);

  {If PolySetLP.N > 0 then
    for i := 1 to PolySetLP.N do
    begin
      ShowMessage('PolySetLP Slice '+PointToStr(X1,Y1,Z1,char(9),fffixed,7,3)+char(13)+'i '+IntToStr(i)+' of '+IntToStr(PolySetLP.N)+
      char(13)+'N'+char(9)+'X'+char(9)+'Y'+char(9)+'Z'+char(13)+PolyToStr(PolySetLP.P[i],char(9),fffixed,7,3));
    end
  Else ShowMessage('PolSetLP Slice '+PointToStr(X1,Y1,Z1,char(9),fffixed,7,3)+char(13)+'i '+IntToStr(0)+' of '+IntToStr(PolySetLP.N));

  If PolySetLN.N > 0 then
    for i := 1 to PolySetLN.N do
    begin
      ShowMessage('PolySetLN Slice '+PointToStr(X1,Y1,Z1,char(9),fffixed,7,3)+char(13)+'i '+IntToStr(i)+' of '+IntToStr(PolySetLN.N)+
      char(13)+'N'+char(9)+'X'+char(9)+'Y'+char(9)+'Z'+char(13)+PolyToStr(PolySetLN.P[i],char(9),fffixed,7,3));
    end
  Else ShowMessage('PolSetLN Slice '+PointToStr(X1,Y1,Z1,char(9),fffixed,7,3)+char(13)+'i '+IntToStr(0)+' of '+IntToStr(PolySetLN.N));}

end;  { TSetofPoly.Slice_Plan }

class function TSetofPoly.Join(PolySet1,PolySet2 : TWire) : TWire;
var                  { Acrescenta Polylines de PolySet2 a Result }
  i, j : integer;
  repeated : boolean;
begin
  Result := PolySet1;

  If PolySet2.N > 0 then  { Se existir PolySet2 a acrescentar }
  begin
    If PolySet1.N <> 0 then { Se PolySet1 não for nula }
    begin
      for i := 1 to PolySet2.N do
      begin
        j := 0;
        repeat
        begin
          Inc(j);
          repeated := TPoly.EqualTest(PolySet1.P[j],PolySet2.P[i]);
        end;
        until((j = PolySet1.N) or (repeated));
        If repeated = False then
        begin
          Result.N := Result.N + 1;
          SetLength(Result.P,Result.N+1);
          Result.P[Result.N] := PolySet2.P[i];
        end;
      end;
    end
    Else If PolySet1.N = 0 then  { Se PolySet1 for nula }
    begin
      for i := 1 to PolySet2.N do
      begin
        Result.N := Result.N + 1;
        SetLength(Result.P,Result.N+1);
        Result.P[Result.N] := PolySet2.P[i];
      end;
    end;
  end;
end;  { TSetofPoly.Join }

class function TSetofPoly.Setof3DPlineToWire(N : integer; PolySet : array of T3DPline) : TWire;
var
  i : integer;
begin
  Result.N := N;
  SetLength(Result.P,N+1);
  for i := 1 to N do
  begin
    Result.P[i] := PolySet[i];
  end;
end;  { TSetofPoly.Setof3DPlineToWire }

{---------------------------------------------------------------------------------------------------}
{                                           TSurf                                                   }
{                                                                                                   }
{ TSurf class gather all algorithms related to the construction of Surfaces                         }
{---------------------------------------------------------------------------------------------------}

class function TSurf.AddFace(F : TTriangle; Faces : TMesh; N : integer) : TMesh;
var                   { Acrescenta a face F ao conjunto Faces a frente da posição N }
  i : integer;
  repeated : boolean;
begin
  If Equal(TriangleArea(F),0,RelPrecision) = False then
  begin
    { Acrescenta F a frente da posição N }
    Result.N := Faces.N+1;
    SetLength(Result.F,Result.N+1);
    If (1<=N) and (N<=Faces.N-1) then    { Se N E [1,Faces.N-1] }
    begin
      for i := 1 to N do
        Result.F[i] := Faces.F[i];
      Result.F[N+1] := F;
      for i := N+2 to Result.N do
        Result.F[i] := Faces.F[i-1];
    end
    Else If N = 0 then                    { Se N = 0 }
    begin
      If Faces.N > 0 then
        for i := 1 to Faces.N do
          Result.F[i+1] := Faces.F[i];
      Result.F[1] := F;
    end
    Else If N >= Faces.N then             { Se N = Faces.N }
    begin
      If Faces.N > 0 then
        for i := 1 to Faces.N do
          Result.F[i] := Faces.F[i];
      Result.F[Faces.N+1] := F;
    end;
  end
  Else Result := Faces;
end;  { TSurf.AddFace }

class function TSurf.AddNewFace(F : TTriangle; Faces : TMesh; N : integer) : TMesh;
var                   { Acrescenta a face F ao conjunto Faces a frente da posição N }
  i : integer;
  repeated : boolean;
begin
  If Equal(TriangleArea(F),0,RelPrecision) = False then
  begin
  repeated := False;
  for i := 1 to Faces.N do
    If EqualTriangle(F,Faces.F[i]) then
      repeated := True;

  If repeated = False then
  begin
    { Acrescenta F a frente da posição N }
    Result.N := Faces.N+1;
    SetLength(Result.F,Result.N+1);
    If (1<=N) and (N<=Faces.N-1) then    { Se N E [1,Faces.N-1] }
    begin
      for i := 1 to N do
        Result.F[i] := Faces.F[i];
      Result.F[N+1] := F;
      for i := N+2 to Result.N do
        Result.F[i] := Faces.F[i-1];
    end
    Else If N = 0 then                    { Se N = 0 }
    begin
      If Faces.N > 0 then
        for i := 1 to Faces.N do
          Result.F[i+1] := Faces.F[i];
      Result.F[1] := F;
    end
    Else If N >= Faces.N then             { Se N = Faces.N }
    begin
      If Faces.N > 0 then
        for i := 1 to Faces.N do
          Result.F[i] := Faces.F[i];
      Result.F[Faces.N+1] := F;
    end;
  end
  Else If repeated then
  begin
    ShowMessage(TriangleToStr(F,', ',fffixed,7,3));
    Result := Faces;
  end;
  end
  Else Result := Faces;
end;  { TSurf.AddNewFace }

class procedure TSurf.RemoveFace(Index : integer; var X : TMesh);
var                          { Remove o valor Index do vetor X }
  i : integer;
begin
  If (Low(X.F)<=Index) and (Index<High(X.F)) then
  begin
    for i := Index to High(X.F)-1 do
      X.F[i] := X.F[i+1];
  end;
  SetLength(X.F,High(X.F)+1);
  X.N := High(X.F);
end;  { TSurf.RemoveFace }

class function TSurf.AddMesh(F : TMesh; Faces : TMesh; N : integer) : TMesh;
var                 { Acrescenta o conjunto F ao conjunto Faces a frente da posição N }
  i, j : integer;
begin
  { Acrescenta F a frente da posição N }
  Result := Faces;
  for i := 1 to F.N do
  begin
    j := Result.N;
    Result := AddFace(F.F[i],Result,N);
    If Result.N > j then
      Inc(N);
  end;
end;  { TSurf.AddMesh }

class function TSurf.FlipDirection(Poly1, Poly2 : T3DPline) : T3DPline;
var                 { Flips direction of Poly2, if necessary, to guarantee }
  i : integer;      { better triangle formation between Poly1 and Poly2  }
  D1, D2 : TFloatType;
begin
  { Distância Acumulada entre pontos - Sem Inversão de Poly2 }
  D1 := 0;
  for i := 1 to Poly1.Npoly do
    D1 := D1 + Dist_Points(Poly1.X[i],Poly1.Y[i],Poly1.Z[i],Poly2.X[i],Poly2.Y[i],Poly2.Z[i]);
  for i := 2 to Poly1.Npoly do
    D1 := D1 + Dist_Points(Poly1.X[i],Poly1.Y[i],Poly1.Z[i],Poly2.X[i-1],Poly2.Y[i-1],Poly2.Z[i-1]);
  { Distância Acumulada entre pontos - Com Inversão de Poly2 }
  Poly2 := TPoly.Reverse(Poly2);
  D2 := 0;
  for i := 1 to Poly1.Npoly do
    D2 := D2 + Dist_Points(Poly1.X[i],Poly1.Y[i],Poly1.Z[i],Poly2.X[i],Poly2.Y[i],Poly2.Z[i]);
  for i := 2 to Poly1.Npoly do
    D2 := D2 + Dist_Points(Poly1.X[i],Poly1.Y[i],Poly1.Z[i],Poly2.X[i-1],Poly2.Y[i-1],Poly2.Z[i-1]);

  { Mantém Poly2 invertida caso D2 < D1 }
  If D2 < D1 then
    Result := Poly2
  Else Result := TPoly.Reverse(Poly2);
end;  { TSurf.FlipDirection }

class procedure TSurf.InitializeMeshes(NMeshes : integer; NFaces : array of integer;
                                       var M : TMeshes);
var
  i : integer;
begin
  SetLength(M,NMeshes+1);
  for i := 1 to NMeshes do
  begin
    M[i].N := NFaces[i];  SetLength(M[i].F,M[i].N+1);
  end;
end;  { TSurf.InitializeMeshes }

class function TSurf.MeshesToVetorIN(M : TMeshes) : TVetorIN;
var
  i : integer;
begin
  SetLength(Result,High(M)+1);
  for i := 1 to High(M) do
    Result[i] := M[i].N;
end;  { TSurf.MeshesToVetorIN }

class function TSurf.PyramidFaceSurf(X,Y,Z : TFloatType; P : T3DPline) : TMesh;
var
  i : integer;
begin
  Result.N := 0;
  SetLength(Result.F,P.Npoly);
  for i := 1 to P.Npoly-1 do
  begin
    Inc(Result.N);
    Result.F[i] := Triangle(X,Y,Z,
                            P.X[i],P.Y[i],P.Z[i],
                            P.X[i+1],P.Y[i+1],P.Z[i+1]);
  end;
end;  { TSurf.PyramidFaceSurf }

class function TSurf.SingleRowPolySurf(Poly_1 : T3DPline; Poly_2 : T3DPline) : TMesh;
var                 { ATENÇÃO! Eliminar pontos repetidos de cada polyline para formar triângulos }
  i : integer;
begin
  with Result do
  begin
    N := 0;
    //TPoly.RemoveRepeatedPts(Poly_1.Npoly,Poly_1.X,Poly_1.Y,Poly_1.Z,Poly_1.Npoly,Poly_1.X,Poly_1.Y,Poly_1.Z);
    //TPoly.RemoveRepeatedPts(Poly_2.Npoly,Poly_2.X,Poly_2.Y,Poly_2.Z,Poly_2.Npoly,Poly_2.X,Poly_2.Y,Poly_2.Z);
    If Poly_1.Npoly <> Poly_2.Npoly then
    begin    { Uniformização do Número de pontos das Poligonais }
      If Poly_1.Npoly > Poly_2.Npoly then
        TPoly.Uniform_Poly3D(Poly_2.Npoly,Poly_1.Npoly,Poly_2.X,Poly_2.Y,Poly_2.Z,
                                          Poly_2.Npoly,Poly_2.X,Poly_2.Y,Poly_2.Z)
      Else If Poly_1.Npoly < Poly_2.Npoly then
        TPoly.Uniform_Poly3D(Poly_1.Npoly,Poly_2.Npoly,Poly_1.X,Poly_1.Y,Poly_1.Z,
                                          Poly_1.Npoly,Poly_1.X,Poly_1.Y,Poly_1.Z);
    end;
    { Muda direção de Poly_2 caso necessário }
    //Poly_2 := FlipDirection(Poly_1,Poly_2);

    { Dois triâgulos entre cada par de pontos }
    SetLength(F,(2*Poly_1.Npoly-1)+1);
    for i := 1 to Poly_1.Npoly-1 do
    begin
      N := N + 2;
      F[N-1] := Triangle(Poly_1.X[i],Poly_1.Y[i],Poly_1.Z[i],
                         Poly_1.X[i+1],Poly_1.Y[i+1],Poly_1.Z[i+1],
                         Poly_2.X[i],Poly_2.Y[i],Poly_2.Z[i]);

      F[N] := Triangle(Poly_1.X[i+1],Poly_1.Y[i+1],Poly_1.Z[i+1],
                       Poly_2.X[i+1],Poly_2.Y[i+1],Poly_2.Z[i+1],
                       Poly_2.X[i],Poly_2.Y[i],Poly_2.Z[i]);
    end;
  end;
end;  { TSurf.SingleRowPolySurf }

class function TSurf.Pol_Pol_Surf(Poly_1 : T3DPline; Poly_2 : T3DPline) :  TMesh;
var
  i : integer;
  Faces : TMesh;
  N1, N2 : integer;
  P1,P2 : T3DPline;
begin
  with Result do
  begin                                                               { Polígonos }
    N := 0;                                                           
    If (Poly_1.Npoly = 1) and (Poly_2.Npoly > 1) then
    begin                                             { Piramidal }
      Faces := PyramidFaceSurf(Poly_1.X[1],Poly_1.Y[1],Poly_1.Z[1],Poly_2);
      Result := AddMesh(Faces,Result,Result.N);
    end
    Else If (Poly_1.Npoly > 1) and (Poly_2.Npoly = 1) then
    begin
      Faces := PyramidFaceSurf(Poly_2.X[1],Poly_2.Y[1],Poly_2.Z[1],Poly_1);
      Result := AddMesh(Faces,Result,Result.N);
    end
    Else If (Poly_1.Npoly > 1) and (Poly_2.Npoly > 1) then
    begin
      If ((Poly_1.Closed = False) and (Poly_2.Closed = False)) or       { Aberto-Aberto }
       ((Poly_1.Closed) and (Poly_2.Closed)) then       { Fechado-Fechado }
      Begin
        Faces := SingleRowPolySurf(Poly_1,Poly_2);
        Result := AddMesh(Faces,Result,Result.N);
      End
      Else If (Poly_1.Closed = False) and (Poly_2.Closed) then   { Aberto-Fechado }
      Begin
        with TPoly do
        begin
          N1 := FindClosestPoint(Poly_1.X[1],Poly_1.Y[1],Poly_1.Z[1],Poly_2);
          N2 := FindClosestPoint(Poly_1.X[Poly_1.Npoly],Poly_1.Y[Poly_1.Npoly],Poly_1.Z[Poly_1.Npoly],Poly_2);
          TPoly.Split(Poly_2,N1,N2,P1,P2);
        end;
        Faces := SingleRowPolySurf(Poly_1,P1);
        Result := AddMesh(Faces,Result,Result.N);

        Faces := SingleRowPolySurf(Poly_1,P2);
        Result := AddMesh(Faces,Result,Result.N);
      End
      Else If (Poly_1.Closed) and (Poly_2.Closed = False) then     { Fechado-Aberto }
      Begin
        with TPoly do
        begin
          N1 := FindClosestPoint(Poly_2.X[1],Poly_2.Y[1],Poly_2.Z[1],Poly_1);
          N2 := FindClosestPoint(Poly_2.X[Poly_2.Npoly],Poly_2.Y[Poly_2.Npoly],Poly_2.Z[Poly_2.Npoly],Poly_1);
          TPoly.Split(Poly_1,N1,N2,P1,P2);
        end;
        Faces := SingleRowPolySurf(Poly_2,P1);
        Result := AddMesh(Faces,Result,Result.N);

        Faces := SingleRowPolySurf(Poly_2,P2);
        Result := AddMesh(Faces,Result,Result.N);
      End;
    end;
  end;
end;  { TSurf.Pol_Pol_Surf }

class function TSurf.TrimMesh(F : TMesh; Plan : TPlan) : TMesh;
var                       { Cuts up the F mesh, excluding triangles outside the }
  i, j, k, l : integer;   { half space where the Normal vector is pointing }
  T : TTriangles;
begin
  l := 0;
  for i := 1 to F.N do
  begin
    T := TriangleTrim(F.F[i],Plan);
    j := High(T);
    If j > 0 then   { Add triangles to a separated TMesh }
    begin
      SetLength(Result.F,l+j+1);
      for k := l+1 to l+j do
        Result.F[k] := T[k-l];
      Inc(l,j);
    end;
  end;
  Result.N := l;
end;  { TSurf.TrimMesh }

class function TSurf.TrimTwiceMesh(F : TMesh; Plan1, Plan2 : TPlan) : TMesh;
begin
  Result := TrimMesh(F,Plan1);
  Result := TrimMesh(Result,Plan2);
end;  { TSurf.TrimTwiceMesh }

{---------------------------------------------------------------------------------------------------}
{                                           TCGraphic                                               }
{                                                                                                   }
{ TCGraphic class gather all algorithms related to computer graphics calculations                   }
{---------------------------------------------------------------------------------------------------}

class procedure TCGraphic.ClearBitmap(Bmp : TBitmap; PenColor : TColor);
var
  i : integer;
begin
  with Bmp.Canvas.Pen do
  begin
    Color := PenColor; Style:= psSolid; Width := 1;
  end;
  for i := 0 to Bmp.Height-1 do
  begin
    Bmp.Canvas.MoveTo(0,i);
    Bmp.Canvas.LineTo(Bmp.Width,i);
  end;
end;  { TCGraphic.ClearBitmap }

class procedure TCGraphic.TextDisplay(Bmp : TBitmap; X, Y : integer;
                                      TextFont, Color : integer; TextStyle : TFontStyles; Text : WideString);
begin
  with Bmp.Canvas do
  begin
    Font.Color := Color;
    Font.Height := TextFont;
    Font.Style := TextStyle;
    TextOut(X,Y-TextHeight(Text),Text);
  end;
end;  { TCGraphic.TextDisplay }

class procedure TCGraphic.Draw_Poly2D_Points(Poly : TPline; Bmp : TBitmap; N1, N2 : integer;
                                             PenBorderColor, PenBrushColor : TColor; PenWidth : integer;
                                             T : integer; SizeRatio : TFloatType; XPan, YPan : integer);
var
  i : integer;
begin
  with Bmp.Canvas do
  begin
    Pen.Color := PenBorderColor;
    Brush.Color := PenBrushColor;
    Brush.Style := bsSolid;
    if Poly.Npoly > 1 then
    begin
      for i := N1 to N2 do
        Mark_2DPoint(Poly.X[i],Poly.Y[i],Bmp,PenBorderColor,PenBrushColor,
                     PenWidth,T,SizeRatio,XPan,YPan);
    end
    else if Poly.Npoly = 1 then
      Mark_2DPoint(Poly.X[1],Poly.Y[1],Bmp,PenBorderColor,PenBrushColor,
                   PenWidth,T,SizeRatio,XPan,YPan);
  end;
end;  { TCGraphic.Draw_Poly2D_Points }

class procedure TCGraphic.Draw_Poly2D_Points(Poly : TPlineIN; Bmp : TBitmap; N1, N2 : integer;
                                             PenBorderColor, PenBrushColor : TColor; PenWidth : integer;
                                             T : integer; XPan, YPan : integer);
var
  i : integer;
begin
  with Bmp.Canvas do
  begin
    Pen.Color := PenBorderColor;
    Brush.Color := PenBrushColor;
    Brush.Style := bsSolid;
    if Poly.Npoly > 1 then
    begin
      for i := N1 to N2 do
        Mark_2DPoint(Poly.X[i],Poly.Y[i],Bmp,PenBorderColor,PenBrushColor,
                     PenWidth,T,XPan,YPan);
    end
    else if Poly.Npoly = 1 then
      Mark_2DPoint(Poly.X[1],Poly.Y[1],Bmp,PenBorderColor,PenBrushColor,
                   PenWidth,T,XPan,YPan);
  end;
end;  { TCGraphic.Draw_Poly2D_Points }

class procedure TCGraphic.Draw_Poly2D(Poly : TPlineIN; Bmp : TBitmap; N1, N2 : integer;
                                      PenColor : TColor; PenWidth : integer; PenStyle : TPenStyle;
                                      XPan, YPan : integer);
var                               { Draws a 2D integer polyline on a bitmap from point N1 to N2 }
  i : integer;                    { N1 and N2 must be between 1 and the last point of }
begin                             { the polyline. Besides, N1 <= N2 }
    with Bmp.Canvas do
    begin
      Pen.Color := PenColor;
      Pen.Width := PenWidth;
      Pen.Style := PenStyle;
      if Poly.Npoly > 1 then
      begin
        for i := N1 to N2-1 do
        begin
          MoveTo(Poly.X[i]+XPan,Poly.Y[i]+YPan);
          LineTo(Poly.X[i+1]+XPan,Poly.Y[i+1]+YPan);
        end;
      end;
    end;
end;  { TCGraphic.Draw_Poly2D }

class procedure TCGraphic.Draw_Poly2D(Poly : TPline; Bmp : TBitmap; N1, N2 : integer;  PenColor : TColor;
                                      PenWidth : integer; PenStyle : TPenStyle; SizeRatio : TFloatType;
                                      XPan, YPan : integer);
var                               { Draws a 2D float polyline on a bitmap from point N1 to N2 }
  i : integer;                    { N1 and N2 must be between 1 and the last point of }
begin                             { the polyline. Besides, N1 <= N2 }
    with Bmp.Canvas do
    begin
      Pen.Color := PenColor;
      Pen.Width := PenWidth;
      Pen.Style := PenStyle;
      if Poly.Npoly > 1 then
      begin
        for i := N1 to N2-1 do
        begin
          MoveTo(Round(Poly.X[i]*SizeRatio) + XPan,Bmp.Height-(Round(Poly.Y[i]*SizeRatio) + YPan));
          LineTo(Round(Poly.X[i+1]*SizeRatio) + XPan,Bmp.Height-(Round(Poly.Y[i+1]*SizeRatio) + YPan));
        end;
      end;
    end;
end;  { TCGraphic.Draw_Poly2D }

class function TCGraphic.Draw_CustomPoly2D(Poly : TPline; Bmp : TBitmap;
                                           SpLnSettings : TSplineSettings;
                                           PLnSettings : TPlineSettings;
                                           SizeRatio : TFloatType;
                                           Xpan, YPan : integer) : TPline;
begin                               { Draws a 2D float polyline with special settings applied }
  If Poly.Npoly > 1 then            { Spline ON }
  begin
    with SpLnSettings do
      Result := CatMullRomSpline(Poly,Tm,Ti,Tf,N);
    Draw_Poly2D(Result,Bmp,1,Result.Npoly,PLnSettings.LineColor,1,psSolid,SizeRatio,XPan,YPan);
  end
  Else If Poly.Npoly = 1 then
  begin
    Result := Poly;
  end;
  { Highlights points from the polyline before Spline }
  If PLnSettings.ShowPoints then
    with PLnSettings do
      Draw_Poly2D_Points(Poly,Bmp,1,Poly.Npoly,DotBorderColor,DotColor,1,DotRadius,SizeRatio,XPan,YPan);
end;  { TCGraphic.Draw_CustomPoly2D }

class procedure TCGraphic.Draw_CustomPoly2D(Poly : TPline; Bmp : TBitmap;
                                            PLnSettings : TPlineSettings;
                                            SizeRatio : TFloatType;
                                            Xpan, YPan : integer);
begin                                       { Draws Poly2D with special settings applied }
  If Poly.Npoly > 1 then                    { Spline OFF }
    Draw_Poly2D(Poly,Bmp,1,Poly.Npoly,PLnSettings.LineColor,1,psSolid,SizeRatio,XPan,YPan);

  { Highlights points from the polyline before Spline }
  If PLnSettings.ShowPoints then
    with PLnSettings do
      Draw_Poly2D_Points(Poly,Bmp,1,Poly.Npoly,DotBorderColor,DotColor,1,DotRadius,SizeRatio,XPan,YPan);

end;  { TCGraphic.Draw_CustomPoly2D }

class function TCGraphic.Draw_CustomPoly2D(Poly : TPlineIN; Bmp : TBitmap; SpLnSettings : TSplineSettings;
                                           PLnSettings : TPlineSettings; Xpan, YPan : integer) : TPlineIN;
begin                                      { Draws Poly2D with special settings applied }
  If Poly.Npoly > 1 then                   { Spline ON }
  begin
    with SpLnSettings do
      Result := CatMullRomSpline(Poly,Tm,Ti,Tf,N);
    Draw_Poly2D(Result,Bmp,1,Result.Npoly,PLnSettings.LineColor,1,psSolid,XPan,YPan);
  end
  Else If Poly.Npoly = 1 then
  begin
    Result := Poly;
  end;
  { Highlights points from the polyline before Spline }
  If PLnSettings.ShowPoints then
    with PLnSettings do
      Draw_Poly2D_Points(Poly,Bmp,1,Poly.Npoly,DotBorderColor,DotColor,1,DotRadius,XPan,YPan);
end;  { TCGraphic.Draw_CustomPoly2D }

class procedure TCGraphic.Draw_CustomPoly2D(Poly : TPlineIN; Bmp : TBitmap; PLnSettings : TPlineSettings;
                                            Xpan, YPan : integer);
begin                                       { Draws Poly2D with special settings applied }
  If Poly.Npoly > 1 then                    { Spline OFF }
    Draw_Poly2D(Poly,Bmp,1,Poly.Npoly,PLnSettings.LineColor,1,psSolid,XPan,YPan);

  { Highlights points from the polyline before Spline }
  If PLnSettings.ShowPoints then
    with PLnSettings do
      Draw_Poly2D_Points(Poly,Bmp,1,Poly.Npoly,DotBorderColor,DotColor,1,DotRadius,XPan,YPan);

end;  { TCGraphic.Draw_CustomPoly2D }

class procedure TCGraphic.Draw_Line3D(X1,Y1,Z1,X2,Y2,Z2 : TFloatType; Bmp : TBitmap; PenColor : TColor;
                                      PenWidth : integer; SizeRatio : TFloatType;
                                      C : TCamera; XPan, YPan : integer);
var
  i : integer;
  XDes, YDes, ZDes : TFloatType;
  XDes0, YDes0, ZDes0 : TFloatType;
  XDes1, YDes1, ZDes1 : TFloatType;
  XDes2, YDes2, ZDes2 : TFloatType;
  Visible : boolean;
begin
  Bmp.Canvas.Pen.Color := PenColor;
  Bmp.Canvas.Pen.Width := PenWidth;
  with Bmp do
  begin
    ApplyViewPointBasis(X1,Y1,Z1,C,XDes,YDes,ZDes);
    ApplyViewPointBasis(X2,Y2,Z2,C,XDes0,YDes0,ZDes0);

    ViewLine(XDes,YDes,ZDes,XDes0,YDes0,ZDes0,
    C.xlens,C.Perspective,Visible,XDes1,YDes1,ZDes1,
    XDes2, YDes2, ZDes2);
    If Visible then
    begin
      Canvas.Moveto(Round(YDes1*SizeRatio) + XPan,Bmp.Height-(Round(ZDes1*SizeRatio) + YPan));
      Canvas.Lineto(Round(YDes2*SizeRatio) + XPan,Bmp.Height-(Round(ZDes2*SizeRatio) + YPan));
    end;
  end;
end;  { TCGraphic.Draw_Line3D }

class procedure TCGraphic.Draw_Poly3D(Poly : T3DPline; N1, N2 : integer; Bmp : TBitmap;
                                      PenColor : TColor; PenWidth : integer; SizeRatio : TFloatType;
                                      C : TCamera; XPan, YPan : integer);
var                               { Draws a 3D polyline on a bitmap from point N1 to N2 }
  i : integer;                    { N1 and N2 must be between 1 and the last point of }
  X, Y, Z : TFloatType;           { the polyline. Besides, N1 <= N2 }
  XDes, YDes, ZDes : TFloatType;
  Visible : boolean;
  XDes0, YDes0, ZDes0 : TFloatType;
  XDes1, YDes1, ZDes1 : TFloatType;
  XDes2, YDes2, ZDes2 : TFloatType;
begin
  Bmp.Canvas.Pen.Color := PenColor;
  Bmp.Canvas.Pen.Width := PenWidth;
  for i := N1 to N2-1 do
  begin
    with Bmp do
    begin
      X := Poly.X[i];  Y := Poly.Y[i];  Z := Poly.Z[i];
      ApplyViewPointBasis(X,Y,Z,C,XDes,YDes,ZDes);

      X := Poly.X[i+1];  Y := Poly.Y[i+1];  Z := Poly.Z[i+1];
      ApplyViewPointBasis(X,Y,Z,C,XDes0,YDes0,ZDes0);

      ViewLine(XDes,YDes,ZDes,XDes0,YDes0,ZDes0,
      C.xlens,C.Perspective,Visible,XDes1,YDes1,ZDes1,
      XDes2, YDes2, ZDes2);
      If Visible then
      begin
        Canvas.Moveto(Round(YDes1*SizeRatio) + XPan,Bmp.Height-(Round(ZDes1*SizeRatio) + YPan));
        Canvas.Lineto(Round(YDes2*SizeRatio) + XPan,Bmp.Height-(Round(ZDes2*SizeRatio) + YPan));
      end;
    end;
  end;
end;  { TCGraphic.Draw_Poly3D }

class procedure TCGraphic.Mark_2DPoint(X, Y : integer; Bmp : TBitmap; PenBorderColor, PenBrushColor : TColor;
                                       PenWidth : integer; T : integer; XPan, YPan : integer);
begin
  with Bmp.Canvas do
  begin
    Pen.Color := PenBorderColor;
    Pen.Width := PenWidth;
    Brush.Color := PenBrushColor;
  end;
  Bmp.Canvas.Rectangle(X-T+XPan,Y-T+YPan,X+T+XPan,Y+T+YPan);
end;  { TCGraphic.Mark_2DPoint }

class procedure TCGraphic.Mark_2DPoint(X, Y : TFloatType; Bmp : TBitmap; PenBorderColor, PenBrushColor : TColor;
                                       PenWidth : integer; T : integer; SizeRatio : TFloatType; XPan, YPan : integer);
begin
  with Bmp.Canvas do
  begin
    Pen.Color := PenBorderColor;
    Pen.Width := PenWidth;
    Brush.Color := PenBrushColor;
  end;
  Bmp.Canvas.Rectangle(Round(SizeRatio*X)-T+XPan,Bmp.Height-(Round(SizeRatio*Y)+YPan)-T,
                       Round(SizeRatio*X)+T+XPan,Bmp.Height-(Round(SizeRatio*Y)+YPan)+T);
end;  { TCGraphic.Mark_2DPoint }

class procedure TCGraphic.Mark_3DPoint(X,Y,Z : TFloatType; Bmp : TBitmap; PenColor : TColor; PenWidth : integer;
                                       Dcirc : integer; SizeRatio : TFloatType; C : TCamera; XPan, YPan : integer);
var
  XDes, YDes, ZDes : TFloatType;
begin
  with Bmp.Canvas do
  begin
    Pen.Color := PenColor;
    Pen.Width := PenWidth;
    Brush.Color := PenColor;
  end;

  ApplyViewPointBasis(X,Y,Z,C,XDes,YDes,ZDes);

  If (XDes <= C.xlens)  then
    Bmp.Canvas.Ellipse(Round(YDes*SizeRatio) + XPan -Dcirc,
    Bmp.Height-(Round(ZDes*SizeRatio) + YPan)-Dcirc,
    Round(YDes*SizeRatio) + XPan +Dcirc,
    Bmp.Height-(Round(ZDes*SizeRatio) + YPan)+Dcirc);

end;  { TCGraphic.Mark_3DPoint }

class procedure TCGraphic.Mark_3DPoint(P : T3DPoint; Bmp : TBitmap; PenColor : TColor; PenWidth : integer; Dcirc : integer;
                                       SizeRatio : TFloatType; C : TCamera; XPan, YPan : integer);
var
  XDes, YDes, ZDes : TFloatType;
begin
  with Bmp.Canvas do
  begin
    Pen.Color := PenColor;
    Pen.Width := PenWidth;
    Brush.Color := PenColor;
  end;

  ApplyViewPointBasis(P.X,P.Y,P.Z,C,XDes,YDes,ZDes);

  If LowerEq(XDes,C.xlens,RelPrecision)  then
    Bmp.Canvas.Ellipse(Round(YDes*SizeRatio) + XPan - Dcirc,
                       Bmp.Height-(Round(ZDes*SizeRatio) + YPan)-Dcirc,
                       Round(YDes*SizeRatio) + XPan + Dcirc,
                       Bmp.Height-(Round(ZDes*SizeRatio) + YPan)+Dcirc);

end;  { TCGraphic.Mark_3DPoint }

class procedure TCGraphic.Draw_Aim(P : T3DPoint; C : TCamera; Bmp : TBitmap; RatioRadiusWidth : TFloatType;
                                   PenColor : TColor; PenWidth : integer; SizeRatio : TFloatType;  XPan, YPan : integer);
var
  Radius : integer;
begin
  with Bmp.Canvas do
  begin
    Pen.Color := PenColor;
    Pen.Width := PenWidth;
    Brush.Style := bsClear;
  end;
  Radius := Round(RatioRadiusWidth*Bmp.Width);

  P := ApplyViewPointBasis(P,C);
  EllipseDisplay(Bmp,P.Y,P.Z,Radius,SizeRatio,XPan,YPan);
  CrossDisplay(Bmp,P.Y,P.Z,Radius,SizeRatio,XPan,YPan);

end;  { TCGraphic.Draw_Aim }

class function TCGraphic.Sight3DPoint(P : T3DPoint; Bmp : TBitmap; SizeRatio : TFloatType;
                                      C : TCamera; XPan, YPan : integer) : T3DPoint;
begin
  P := ApplyViewPointBasis(P,C);
  Result.X := P.X*SizeRatio;
  Result.Y := Round(P.Y*SizeRatio) + XPan;
  Result.Z := Bmp.Height-(Round(P.Z*SizeRatio) + YPan);
end;  { TCGraphic.Mark_3DPoint }



class procedure TCGraphic.Scale(x1 : TFloatType; y1 : TFloatType; z1 : TFloatType; Ratio : TFloatType;
                                var x2 : TFloatType; var y2 : TFloatType; var z2 : TFloatType);
begin
  x2 := Ratio*x1;
  y2 := Ratio*y1;
  z2 := Ratio*z1;
end; { TCGraphic.Scale }

class function TCGraphic.Scale(P : T3DPoint; Ratio : TFloatType) : T3DPoint;
begin
  Result.X := Ratio*P.X;
  Result.Y := Ratio*P.Y;
  Result.Z := Ratio*P.Z;
end; { TCGraphic.Scale }

class function TCGraphic.ScalePanFloat(P : T3DPoint; Height, SizeRatio,
                                       XPan, YPan : TFloatType) : T3DPoint;
begin
  Result.X := SizeRatio*P.X;
  Result.Y := (SizeRatio*P.Y) + XPan;
  Result.Z := Height-((SizeRatio*P.Z) + YPan);
end;  { TCGraphic.ScalePanFloat }

class procedure TCGraphic.ScalePanFloat(X, Y : TFloatType; Height, SizeRatio,
                                        XPan, YPan : TFloatType; var XR, YR: TFloatType);
begin
  XR := (SizeRatio*X) + XPan;
  YR := Height-((SizeRatio*Y) + YPan);
end;  { TCGraphic.ScalePanFloat }

class procedure TCGraphic.ScalePanInt(X, Y : TFloatType; SizeRatio : TFloatType;
                                      Height, XPan, YPan : integer; var XR, YR: integer);
begin
  XR := Round(SizeRatio*X) + XPan;
  YR := Height-(Round(SizeRatio*Y) + YPan);
end;  { TCGraphic.ScalePanFloat }

class function TCGraphic.ScreenScale(Measure : TFloatType; Ratio : TFloatType; DotsPI : Integer) : TFloatType;
begin            { Calculates the scale on the screen given a measure in meters and the screen ratio }
  Result := 1;
  If (DotsPI <> 0) and (Measure<>0) then
    Result := Measure*DotsPI/(Round(Measure*Ratio)*0.0254);
end;  { TCGraphic.ScreenScale }

class function TCGraphic.ReverseScalePanFloat(P : T3DPoint; Height, SizeRatio,
                                              XPan, YPan : TFloatType) : T3DPoint;
begin
  Result.X := P.X/SizeRatio;
  Result.Y := (P.Y-XPan)/SizeRatio;
  Result.Z := (Height-(P.Z+YPan))/SizeRatio;
end;  { TCGraphic.ReverseScalePanFloat }

class procedure TCGraphic.ReverseScalePanFloat(X, Y : TFloatType; Height, SizeRatio,
                                               XPan, YPan : TFloatType; var XR, YR: TFloatType);
begin
  XR := (X-XPan)/SizeRatio;
  YR := (Height-(Y-YPan))/SizeRatio;
end;  { TCGraphic.ReverseScalePanFloat }

class function TCGraphic.ReverseScalePanPoly(Poly : TPlineIN; SizeRatio : TFloatType;
                                             Height, XPan, YPan : integer) : TPline;
var
  i : integer;
begin
  Result.Npoly := Poly.Npoly;
  SetLength(Result.X, Poly.Npoly+1);  SetLength(Result.Y, Poly.Npoly+1);
  Result.Closed := Poly.Closed;
  for i := 1 to Poly.Npoly do
  begin
    Result.X[i] := (Poly.X[i]-XPan)/SizeRatio;
    Result.Y[i] := (Height-(Poly.Y[i]-YPan))/SizeRatio;
  end;
end;  { TCGraphic.ReverseScalePanPoly }

class procedure TCGraphic.RotationXAxis(R : TFloatType; var T : TMatriz3x3);
begin
  R := R*pi/180;
  T[1,1] := 1;        T[1,2] := 0;        T[1,3] := 0;
  T[2,1] := 0;        T[2,2] := cos(R);   T[2,3] := sin(R);
  T[3,1] := 0;        T[3,2] := -sin(R);  T[3,3] := cos(R);
end;  { TCGraphic.RotationXAxis }

class procedure TCGraphic.RotationYAxis(R : TFloatType; var T : TMatriz3x3);
begin
  R := R*pi/180;
  T[1,1] := cos(R);   T[1,2] := 0;        T[1,3] := sin(R);
  T[2,1] := 0;        T[2,2] := 1;        T[2,3] := 0;
  T[3,1] := -sin(R);  T[3,2] := 0;        T[3,3] := cos(R);
end;  { TCGraphic.RotationYAxis }

class procedure TCGraphic.RotationZAxis(R : TFloatType; var T : TMatriz3x3);
begin
  R := R*pi/180;
  T[1,1] := cos(R);   T[1,2] := sin(R);   T[1,3] := 0;
  T[2,1] := -sin(R);  T[2,2] := cos(R);   T[2,3] := 0;
  T[3,1] := 0;        T[3,2] := 0;        T[3,3] := 1;
end;  { TCGraphic.RotationZAxis }

class procedure TCGraphic.Rotation3DAxis(R : TFloatType; AX, AY, AZ : TFloatType; var T : TMatriz3x3);
var
  C, S : TFloatType;              { C : cossine, S : sine }
  Hyp : TFloatType;               { AX, AY, AZ : vector in the direction of the 3D axis }
begin
  C := cos(R*pi/180);   S := sin(R*pi/180);
  Hyp := sqrt(sqr(AX)+sqr(AY)+sqr(AZ));
  If Hyp <> 0 then
  begin
    AX := AX/Hyp;  AY := AY/Hyp;  AZ := AZ/Hyp;
  end
  Else If Hyp = 0 then
  begin
    AX := 0;       AY := 0;       AZ := 0;
    C := 1;        S := 0;
  end;

  T[1,1] := C+(sqr(AX)*(1-C));       T[1,2] := (AX*AY*(1-C))-(AZ*S);   T[1,3] := (AX*AZ*(1-C))+(AY*S);
  T[2,1] := (AX*AY*(1-C))+(AZ*S);    T[2,2] := C+(sqr(AY)*(1-C));      T[2,3] := (AY*AZ*(1-C))-(AX*S);
  T[3,1] := (AX*AZ*(1-C))-(AY*S);    T[3,2] := (AY*AZ*(1-C))+(AX*S);   T[3,3] := C+(sqr(AZ)*(1-C));
end;  { TCGraphic.Rotation3DAxis }

class procedure TCGraphic.Rotation3DAxis(R : TFloatType; AX, AY, AZ : TFloatType; var TAcm, T : TMatriz3x3);
var
  C, S : TFloatType;              { C : cossine, S : sine }
  Hyp : TFloatType;               { AX, AY, AZ : vector in the direction of the 3D axis }

begin
  C := cos(R*pi/180);   S := sin(R*pi/180);
  Hyp := sqrt(sqr(AX)+sqr(AY)+sqr(AZ));
  If Hyp <> 0 then
  begin
    AX := AX/Hyp;  AY := AY/Hyp;  AZ := AZ/Hyp;
  end
  Else If Hyp = 0 then
  begin
    AX := 0;       AY := 0;       AZ := 0;
    C := 1;        S := 0;
  end;

  T[1,1] := C+(sqr(AX)*(1-C));       T[1,2] := (AX*AY*(1-C))-(AZ*S);   T[1,3] := (AX*AZ*(1-C))+(AY*S);
  T[2,1] := (AX*AY*(1-C))+(AZ*S);    T[2,2] := C+(sqr(AY)*(1-C));      T[2,3] := (AY*AZ*(1-C))-(AX*S);
  T[3,1] := (AX*AZ*(1-C))-(AY*S);    T[3,2] := (AY*AZ*(1-C))+(AX*S);   T[3,3] := C+(sqr(AZ)*(1-C));

  { Update the Current State by the last rotation T }
  TAcm := ProdutoMatrizes(T,TAcm);

end;  { TCGraphic.Rotation3DAxis }

class procedure TCGraphic.PerspectiveProjection(P : TVetor3x1; O : TVetor3x1; xV : TFloatType;
                                                var PR : TVetor3x1);
begin               { Computes the intersection PR between the straight line OP and  }
                    { the normal plan xV. O is the observer and P is a point }
                    { Plan xV must be normal to axis X of O basis system }
  PR[1] := P[1];    { PR[1] holds the X buffer }
  If (P[1] <> O[1]) then
  begin
    PR[2] := ((P[2] - O[2])*(xV - O[1])/(P[1] - O[1])) + O[2];
    PR[3] := ((P[3] - O[3])*(xV - O[1])/(P[1] - O[1])) + O[3];
  end
  Else begin
    PR[2] := P[2];  PR[3] := P[3];
  end;
end;  { TCGraphic.PerspectiveProjection }

class function TCGraphic.PerspectiveProjection(P : T3DPoint; O : T3DPoint; xV : TFloatType) : T3DPoint;
begin               { PerspectiveProjection as function }
  Result.X := P.X;    { Result.X holds the X buffer }
  If (P.X <> O.X) then
  begin
    Result.Y := ((P.Y - O.Y)*(xV - O.X)/(P.X - O.X)) + O.Y;
    Result.Z := ((P.Z - O.Z)*(xV - O.X)/(P.X - O.X)) + O.Z;
  end
  Else begin
    Result.Y := P.Y;  Result.Z := P.Z;
  end;
end;  { TCGraphic.PerspectiveProjection }

class procedure TCGraphic.PerspectiveProjection(X, Y, Z : TFloatType; CXObs, CYObs, CZObs : TFloatType; xV : TFloatType;
                                                var XR, YR, ZR : TFloatType);
begin               { PerspectiveProjection as function }
  XR := X;    { XR holds the X buffer }
  If (X <> CXObs) then
  begin
    YR := ((Y - CYObs)*(xV - CXObs)/(X - CXObs)) + CYObs;
    ZR := ((Z - CZObs)*(xV - CXObs)/(X - CXObs)) + CZObs;
  end
  Else begin
    YR := Y;  ZR := Z;
  end;
end;  { TCGraphic.PerspectiveProjection }

class procedure TCGraphic.ReversePerspectiveProjection(P : TVetor3x1; O : TVetor3x1; xV : TFloatType;
                                                       var PR : TVetor3x1);
begin               { Performs the inverse calculation of PerspectiveProjection }
  PR[1] := P[1];    { PR[1] holds the X buffer }
  If xV <> O[1] then
  begin
    PR[2] := ((P[2]-O[2])*(P[1] - O[1])/(xV - O[1])) + O[2];
    PR[3] := ((P[3]-O[3])*(P[1] - O[1])/(xV - O[1])) + O[3];
  end
  Else begin
    PR[2] := P[2];  PR[3] := P[3];
  end;
end;  { TCGraphic.ReversePerspectiveProjection }

class function TCGraphic.ReversePerspectiveProjection(P : T3DPoint; O : T3DPoint; xV : TFloatType) : T3DPoint;
begin                   { Performs the inverse calculation of PerspectiveProjection }
  Result.X := P.X;      { Result.X holds the X buffer }
  If xV <> O.X then
  begin
    with Result do
    begin
      Y := ((P.Y-O.Y)*(P.X - O.X)/(xV - O.X)) + O.Y;
      Z := ((P.Z-O.Z)*(P.X - O.X)/(xV - O.X)) + O.Z;
    end;
  end
  Else begin
    Result.Y := P.Y;  Result.Z := P.Z;
  end;
end;  { TCGraphic.ReversePerspectiveProjection }

class procedure TCGraphic.ReversePerspectiveProjection(X, Y, Z : TFloatType; CXObs, CYObs, CZObs : TFloatType; xV : TFloatType;
                                                       var XR, YR, ZR : TFloatType);
begin               { Performs the inverse calculation of PerspectiveProjection }
  XR := X;          { XR holds the X buffer }
  If xV <> CXObs then
  begin
    YR := ((Y-CYObs)*(X - CXObs)/(xV - CXObs)) + CYObs ;
    ZR := ((Z-CZObs)*(X - CXObs)/(xV - CXObs)) + CZObs ;
  end
  Else begin
    YR := Y;  ZR := Z;
  end;
end;  { TCGraphic.ReversePerspectiveProjection }

class procedure TCGraphic.ApplyRotation(X, Y, Z  : TFloatType; A : T3DPoint; T : TMatriz3x3; var XR, YR, ZR : TFloatType);
var                           { Performs the rotation of X,Y,Z around A by the rotation matrix T }
  C : TVetor3x1;
begin
  { Changes the origin of (X, Y, Z) from (0,0,0) to point A }
  C[1] := X - A.X;  C[2] := Y - A.Y;  C[3] := Z - A.Z;
  { Rotates (X - A.X , Y - A.Y , Z - A.Z) by T }
  C := ProdutoMatrizVetor(T,C);
  { Returns the origin to (0,0,0) }
  XR := C[1] + A.X;  YR := C[2] + A.Y;  ZR := C[3] + A.Z;
end;  { TCGraphic.ApplyRotation }

class procedure TCGraphic.ApplyRotation(P, A : T3DPoint; T : TMatriz3x3; var PR : T3DPoint);
var                           { Performs the rotation of P around A by the rotation matrix T }
  C : TVetor3x1;
begin
  { Changes the origin of P from (0,0,0) to point A }
  C[1] := P.X - A.X;  C[2] := P.Y - A.Y;  C[3] := P.Z - A.Z;
  { Rotates P-A by T }
  C := ProdutoMatrizVetor(T,C);
  { Returns the origin to (0,0,0) }
  PR.X := C[1] + A.X;  PR.Y := C[2] + A.Y;  PR.Z := C[3] + A.Z;
end;  { TCGraphic.ApplyRotation }

class procedure TCGraphic.ApplyViewPointBasis(X, Y, Z : TFloatType; C : TCamera; var XR, YR, ZR : TFloatType);
var                   { Finds the coordinates of Point in the Camera Base System }
  P : TVetor3x1;      { considering perspective deformation }
begin
  { Changes origin to C.Obs }
  P[1] := X-C.Obs.X;  P[2] := Y-C.Obs.Y;  P[3] := Z-C.Obs.Z;
  { Calculate P on ViewPoint Basis }
  P := ProdutoMatrizVetor(C.Basis,P);

  If C.Perspective then        { Perspective Projection }
  Begin
    PerspectiveProjection(P,Vetor3x1(0,0,0),C.xlens,P);
    XR := P[1]; YR := P[2]; ZR := P[3];
  End
  Else If C.Perspective = False then  { Isometric Projection }
  Begin
    XR := P[1]; YR := P[2]; ZR := P[3];
  End;
end;  { TCGraphic.ApplyViewPointBasis }

class function TCGraphic.ApplyViewPointBasis(Point : T3DPoint; C : TCamera) : T3DPoint;
var                   { Finds the coordinates of Point in the Camera Base System }
  P : TVetor3x1;      { considering perspective deformation }
begin
  { Changes origin to C.Obs }
  P[1] := Point.X-C.Obs.X;  P[2] := Point.Y-C.Obs.Y;  P[3] := Point.Z-C.Obs.Z;
  { Calculate P on ViewPoint Basis }
  P := ProdutoMatrizVetor(C.Basis,P);

  If C.Perspective then        { Perspective Projection }
  Begin
    PerspectiveProjection(P,Vetor3x1(0,0,0),C.xlens,P);
    Result.X := P[1]; Result.Y := P[2]; Result.Z := P[3];
  End
  Else If C.Perspective = False then  { Isometric Projection }
  Begin
    Result.X := P[1]; Result.Y := P[2]; Result.Z := P[3];
  End;
end;  { TCGraphic.ApplyViewPointBasis }

class function TCGraphic.ViewPointBasis(Point : T3DPoint; C : TCamera) : T3DPoint;
var                   { Finds the coordinates of Point in the Camera Base System }
  P : TVetor3x1;      { not considering perspective deformation }
begin
  { Changes origin to C.Obs }
  P[1] := Point.X-C.Obs.X;  P[2] := Point.Y-C.Obs.Y;  P[3] := Point.Z-C.Obs.Z;
  { Calculate P on ViewPoint Basis }
  P := ProdutoMatrizVetor(C.Basis,P);
  Result.X := P[1];  Result.Y := P[2];  Result.Z := P[3];
end;  { TCGraphic.ViewPointBasis }

class function TCGraphic.RevertViewPointBasis(Point : T3DPoint; C : TCamera) : T3DPoint;
var                   { Transforms the coordinates of Point in the Camera Base System }
  P : TVetor3x1;      { back to the world base system }
begin
  { Returns P to World Base System }
  P := ProdutoMatrizVetor(MatrizTransposta(C.Basis),Vetor3x1(Point.X,Point.Y,Point.Z));
  { Changes origin to (0,0,0) }
  Result.X := P[1]+C.Obs.X;  Result.Y := P[2]+C.Obs.Y;  Result.Z := P[3]+C.Obs.Z;
end;  { TCGraphic.RevertViewPointBasis }

class procedure TCGraphic.MoveCameraPos(V, A : T3DPoint;
                                        var XCo, ZCo : TVetor3x1;
                                        var Vo, Ao : T3DPoint;
                                        var RefY, RefZ : T3DPoint;
                                        var TCBase : TMatriz3x3);
var       { Translação da Câmera }
  Axis : T3DPoint;
  XUCS,YUCS,ZUCS : TVetor3x1;
  Angle : TFloatType;
  Matriz : TMatriz3x3;
begin

  If EqualPoints(V,A) = False then         { V <> A }      // Alvo da Câmera Não coincidente com Observador
  begin
    { Determinação dos Eixos (vetores unitários) da Câmera : XUCS, YUCS, ZUCS }

    { Vetor X Unitátio da Base Câmera }
    XUCS[1] := V.X-A.X;  XUCS[2] := V.Y-A.Y;  XUCS[3] := V.Z-A.Z;
    XUCS := VetorUnitario(XUCS);

    { Vetor Z Unitário da Base Câmera }
    If EqualPoints(V,Vo) = False then   { Movimentação do Observador (V <> Vo) }
    begin
      { Eixo da rotação equivalente ao deslocamento da câmera }
      Axis := VectorToPoint(ProdutoVetorial(XCo, XUCS));
      Angle := ProdutoEscalar_ANG(XCo,XUCS);  // deslocamento --> rotação equivalente

      { Rotação do Eixo ZCo conforme deslocamento da câmera }
      TCGraphic.Rotation3DAxis(Angle,Axis.X,Axis.Y,Axis.Z,Matriz);
      ZUCS := ProdutoMatrizVetor(Matriz,ZCo);
      ZUCS := VetorUnitario(ZUCS);  //vetor Z Unitário da Base Câmera
    end;
    If EqualPoints(A,Ao) = False then   { Movimentação do Alvo (A <> Ao) }
    begin
      { Eixo da rotação equivalente ao deslocamento do Alvo }
      Axis := VectorToPoint(ProdutoVetorial(XCo, XUCS));
      Angle := ProdutoEscalar_ANG(XCo,XUCS);  // deslocamento --> rotação equivalente

      { Rotação do Eixo ZCo conforme deslocamento do Alvo }
      TCGraphic.Rotation3DAxis(Angle,Axis.X,Axis.Y,Axis.Z,Matriz);
      ZUCS := ProdutoMatrizVetor(Matriz,ZCo);
      ZUCS := VetorUnitario(ZUCS);  //vetor Z Unitário da Base Câmera
    end;
    If (EqualPoints(V,Vo)) and  (EqualPoints(A,Ao)) then   { V = Vo   A = Ao }
    begin
      ZUCS := ZCo;   //vetor Z Unitário da Base Câmera
    end;

    { Vetor Y Unitário da Base Câmera }
    YUCS := ProdutoVetorial(ZUCS,XUCS);
    YUCS := VetorUnitario(YUCS);  //vetor Y Unitário da Base Câmera
  end
  Else If EqualPoints(V,A) then        { V = A }       // Alvo da Câmera coincidente com Observador }
  begin
    XUCS := XCo;  // vetor X unitário da Base Câmera
    ZUCS := ZCo;  // vetor Z unitário da Base Câmera

    { Vetor Y Unitário da Base Câmera }
    YUCS := ProdutoVetorial(ZUCS,XUCS);
    YUCS := VetorUnitario(YUCS);  //vetor Y Unitário da Base Câmera
  end;

  { Matriz de Mudança de Base }
  TCBase[1,1] := XUCS[1];  TCBase[1,2] := XUCS[2];  TCBase[1,3] := XUCS[3];
  TCBase[2,1] := YUCS[1];  TCBase[2,2] := YUCS[2];  TCBase[2,3] := YUCS[3];
  TCBase[3,1] := ZUCS[1];  TCBase[3,2] := ZUCS[2];  TCBase[3,3] := ZUCS[3];

  { Armazena eixos XCo e ZCo para próximo movimento }

  XCo := XUCS;  // vetor X unitário da Base Câmera
  ZCo := ZUCS;  // vetor Z unitário da Base Câmera

  RefY.X := V.X+YUCS[1]; RefY.Y := V.Y+YUCS[2]; RefY.Z := V.Z+YUCS[3];
  RefZ.X := V.X+ZUCS[1]; RefZ.Y := V.Y+ZUCS[2]; RefZ.Z := V.Z+ZUCS[3];

  Vo := V;  Ao := A;
end;  { TCGraphic.MoveCameraPos }

class procedure TCGraphic.MoveCameraNav(V, A : T3DPoint;
                                        var XCo, ZCo : TVetor3x1;
                                        var Vo, Ao : T3DPoint;
                                        var RefY, RefZ : T3DPoint;
                                        var TCBase : TMatriz3x3);
var
  XUCS,YUCS,ZUCS : TVetor3x1;
begin

  If EqualPoints(V,A) = False then         { V <> A }      // Alvo da Câmera Não coincidente com Observador
  begin
    { Determinação dos Eixos (vetores unitários) da Câmera : XUCS, YUCS, ZUCS }

    { Vetor X Unitátio da Base Câmera }
    XUCS[1] := V.X-A.X;  XUCS[2] := V.Y-A.Y;  XUCS[3] := V.Z-A.Z;
    XUCS := VetorUnitario(XUCS);

    { Vetor Y unitátio da Base Câmera }
    YUCS[1] := RefY.X-V.X;  YUCS[2] := RefY.Y-V.Y;  YUCS[3] := RefY.Z-V.Z;
    YUCS := VetorUnitario(YUCS);

    { Vetor Z unitátio da Base Câmera }
    ZUCS[1] := RefZ.X-V.X;  ZUCS[2] := RefZ.Y-V.Y;  ZUCS[3] := RefZ.Z-V.Z;
    ZUCS := VetorUnitario(ZUCS);
  end
  Else If EqualPoints(V,A) then        { V = A }       // Alvo da Câmera igual ao Observador
  begin
    { Vetor X unitário da Base Câmera }
    XUCS[1] := XCo[1];  XUCS[2] := XCo[2];  XUCS[3] := XCo[3];
    { Vetor Z unitário da Base Câmera }
    ZUCS[1] := ZCo[1];  ZUCS[2] := ZCo[2];  ZUCS[3] := ZCo[3];

    { Vetor Y Unitário da Base Câmera }
    YUCS := ProdutoVetorial(ZUCS,XUCS);
    YUCS := VetorUnitario(YUCS);  //vetor Y Unitário da Base Câmera
  end;

  TCBase[1,1] := XUCS[1];  TCBase[1,2] := XUCS[2];  TCBase[1,3] := XUCS[3];
  TCBase[2,1] := YUCS[1];  TCBase[2,2] := YUCS[2];  TCBase[2,3] := YUCS[3];
  TCBase[3,1] := ZUCS[1];  TCBase[3,2] := ZUCS[2];  TCBase[3,3] := ZUCS[3];

  { Armazena eixos XCo e ZCo para próximo movimento }

  XCo := XUCS;  // vetor X unitário da Base Câmera
  ZCo := ZUCS;  // vetor Z unitário da Base Câmera

  RefY.X := V.X+YUCS[1]; RefY.Y := V.Y+YUCS[2]; RefY.Z := V.Z+YUCS[3];
  RefZ.X := V.X+ZUCS[1]; RefZ.Y := V.Y+ZUCS[2]; RefZ.Z := V.Z+ZUCS[3];

  Vo := V;  Ao := A;
end;  { TCGraphic.MoveCameraNav }

class procedure TCGraphic.ViewLine(X1 : TFloatType; Y1 : TFloatType; Z1 : TFloatType;
                                   X2 : TFloatType; Y2 : TFloatType; Z2 : TFloatType;
                                   xV : TFloatType; Persp: boolean; var Visible : boolean;
                                   var X1F : TFloatType;  var Y1F : TFloatType;  var Z1F : TFloatType;
                                   var X2F : TFloatType;  var Y2F : TFloatType;  var Z2F : TFloatType);
var
  Vetor,VetorObs,VetorR : TVetor3x1;
  yIntR, zIntR : TFloatType;
begin
  VetorObs[1] := 0;     VetorObs[2] := 0;     VetorObs[3] := 0;
  Visible := False;
  If (LowerEq(X1,xV,RelPrecision)) and (LowerEq(X2,xV,RelPrecision)) then
  Begin
    Visible := True;
    X1F := X1;  Y1F := Y1;  Z1F := Z1;
    X2F := X2;  Y2F := Y2;  Z2F := Z2;
  End
  Else If (((GreaterEq(X1,xV,RelPrecision)) and (Lower(X2,xV,RelPrecision))) or
           ((GreaterEq(X2,xV,RelPrecision)) and (Lower(X1,xV,RelPrecision))))
  and ((Unequal(X2,0,RelPrecision)) and (Unequal(X1,0,RelPrecision))) then
  Begin
    If Persp then
    begin          { Transformação Inversa de Perspectiva }
      Vetor[1] := X1;  Vetor[2] := Y1;  Vetor[3] := Z1;
      TCGraphic.ReversePerspectiveProjection(Vetor,VetorObs,xV,VetorR);
      X1 := VetorR[1];  Y1 := VetorR[2];  Z1 := VetorR[3];

      Vetor[1] := X2;  Vetor[2] := Y2;  Vetor[3] := Z2;
      TCGraphic.ReversePerspectiveProjection(Vetor,VetorObs,xV,VetorR);
      X2 := VetorR[1];  Y2 := VetorR[2];  Z2 := VetorR[3];
    end;

    yIntR := ((xV-X1)*(Y2-Y1)/(X2-X1))+Y1;
    zIntR := ((xv-X1)*(Z2-Z1)/(X2-X1))+Z1;

    If Persp then
    begin          { Retorno à Perspectiva }
      if Unequal(X2,0,RelPrecision) then
      begin
        Vetor[1] := X2;  Vetor[2] := Y2;  Vetor[3] := Z2;
        PerspectiveProjection(Vetor,VetorObs,xV,VetorR);
        X2 := VetorR[1];  Y2 := VetorR[2];  Z2 := VetorR[3];
      end;
      if Unequal(X1,0,RelPrecision) then
      begin
        Vetor[1] := X1;  Vetor[2] := Y1;  Vetor[3] := Z1;
        PerspectiveProjection(Vetor,VetorObs,xV,VetorR);
        X1 := VetorR[1];  Y1 := VetorR[2];  Z1 := VetorR[3];
      end;
    end;
    If (GreaterEq(X1,xV,RelPrecision)) and (Lower(X2,xV,RelPrecision)) then
    begin
      Visible := True;
      X1F := xV;  Y1F := yIntR;  Z1F := zIntR;
      X2F := X2;        Y2F := Y2;     Z2F := Z2;
    end
    Else If (GreaterEq(X2,xV,RelPrecision)) and (Lower(X1,xV,RelPrecision)) then
    begin
      Visible := True;
      X1F := X1;        Y1F := Y1;     Z1F := Z1;
      X2F := xV;  Y2F := yIntR;  Z2F := zIntR;
    end;
  End;
end;  { TCGraphic.ViewLine }

class function TCGraphic.SetRatio_Display(Hmax,Vmax,HDisplay,VDisplay : TFloatType) : TFloatType;
begin
  Result := HDisplay/Hmax;
  If Greater((Hmax/Vmax),(HDisplay/VDisplay),RelPrecision) then
    Result := HDisplay/Hmax
  Else Result := VDisplay/Vmax;
end;  { SetRatio_Display }

class function TCGraphic.ZoomAll(Camera : TCamera; DisplayHeight, DisplayWidth : integer;
                                 B : TBox) : TFloatType;
var
  i : integer;
  YKey,ZKey : array[1..8]of double;
  XObj, YObj : TFloatType;
begin
  for i := 1 to 8 do
    B[i] := ApplyViewPointBasis(B[i],Camera);
  for i := 1 to 8 do
  begin
    YKey[i] := B[i].Y;  ZKey[i] := B[i].Z;
  end;
  XObj := MaxValue(YKey)-MinValue(YKey);
  YObj := MaxValue(ZKey)-MinValue(ZKey);
  
  Result := SetRatio_Display(XObj,YObj,DisplayWidth,DisplayHeight);
end;  { TCGraphic.ZoomAll }

class function TCGraphic.RotationAngleDisplay(X, Y, Xo, Yo : integer; Amplitude : TFloatType;
                                              Height, Width : integer) : TFloatType;
begin
  { Graus por Pixel em torno do eixo de Rotação }
  Result := sqrt(sqr(X-Xo)+sqr((Height - Y) - Yo))*Amplitude/sqrt(sqr(Height)+sqr(Width));
end;  { TCGraphic.RotationAngleDisplay }

class procedure TCGraphic.CrossDisplay(Bmp : TBitmap; X, Y : TFloatType; R : integer; SizeRatio : TFloatType;
                                       XPan, YPan : integer);
begin                    { Draws a cross of radius R and center (X,Y) }
  with Bmp.Canvas do
  begin
    MoveTo(Round(X*SizeRatio) + XPan - R,Bmp.Height-(Round(Y*SizeRatio) + YPan));
    LineTo(Round(X*SizeRatio) + XPan + R,Bmp.Height-(Round(Y*SizeRatio) + YPan));
    MoveTo(Round(X*SizeRatio) + XPan,Bmp.Height-(Round(Y*SizeRatio) + YPan) - R);
    LineTo(Round(X*SizeRatio) + XPan,Bmp.Height-(Round(Y*SizeRatio) + YPan) + R);
  end;
end;  { TCGraphic.CrossDisplay }

class function TCGraphic.PixelOnRectangleVertice(X, Y : integer; R : TRect; T : integer) : boolean;
begin                  { Checks if pixel (X,Y) is lying on one of the rectangle R vertices, }
                       { considering a tolerance/thickness of T }
  If ((X >= R.Left-T) and (X <= R.Left+T) and      { Vértice 1 }
      (Y >= R.Bottom-T) and (Y <= R.Bottom+T))
     or
     ((X >= R.Right-T) and (X <= R.Right+T) and    { Vértice 2 }
      (Y >= R.Bottom-T) and (Y <= R.Bottom+T))
     or
     ((X >= R.Right-3) and (X <= R.Right+3) and    { Vértice 3 }
      (Y >= R.Top-3) and (Y <= R.Top+3))
     or
     ((X >= R.Left-3) and (X <= R.Left+3) and      { Vértice 4 }
      (Y >= R.Top-3) and (Y <= R.Top+3)) then
    Result := True
  Else Result := False;
end;  { TCGraphic.PixelOnRectangleVertice }

class function TCGraphic.CursorOnRectangleVertice(X, Y : integer; R : TRect; T : integer;
                                                  DefaultCursor : TCursor) : TCursor;
begin                  { Checks if pixel (X,Y) is lying on one of the rectangle R vertices, }
                       { considering a tolerance/thickness of T and returns a cursor }
  Result := DefaultCursor;                                                  { 4----3 }
  If ((X >= R.Left-T) and (X <= R.Left+T) and      { Vértice 1 }            { |    | }
      (Y >= R.Bottom-T) and (Y <= R.Bottom+T))                              { 1----2 }
     or
     ((X >= R.Right-T) and (X <= R.Right+T) and    { Vértice 3 }
      (Y >= R.Top-T) and (Y <= R.Top+T)) then
    Result := crSizeNESW
  Else If
     ((X >= R.Right-T) and (X <= R.Right+T) and    { Vértice 2 }
      (Y >= R.Bottom-T) and (Y <= R.Bottom+T))
     or
     ((X >= R.Left-T) and (X <= R.Left+T) and      { Vértice 4 }
      (Y >= R.Top-T) and (Y <= R.Top+T)) then
    Result := crSizeNWSE;
end;  { TCGraphic.CursorOnRectangleVertice }

class function TCGraphic.CursorOnRectangleVertice(X, Y : integer; R : TRect; T : integer;
                                                  DefaultCursor : TCursor; var Vertice : byte) : TCursor;
begin                      { Checks if pixel (X,Y) is lying on one of the rectangle R vertices, }
                           { considering a tolerance/thickness of T and returns a cursor and }
  Result := DefaultCursor; { the index of the vertice }                             { 4----3 }
  Vertice := 0;                                                                     { |    | }
  If ((X >= R.Left-T) and (X <= R.Left+T) and      { Vértice 1 }                    { 1----2 }
      (Y >= R.Bottom-T) and (Y <= R.Bottom+T)) then
  begin
    Result := crSizeNESW;
    Vertice := 1;
  end
  Else If
     ((X >= R.Right-3) and (X <= R.Right+3) and    { Vértice 3 }
      (Y >= R.Top-3) and (Y <= R.Top+3)) then
  begin                                                                    
    Result := crSizeNESW;
    Vertice := 3;
  end
  Else If
     ((X >= R.Right-T) and (X <= R.Right+T) and    { Vértice 2 }
      (Y >= R.Bottom-T) and (Y <= R.Bottom+T)) then
  begin
    Result := crSizeNWSE;
    Vertice := 2;
  end
  Else If
     ((X >= R.Left-3) and (X <= R.Left+3) and      { Vértice 4 }
      (Y >= R.Top-3) and (Y <= R.Top+3)) then
  begin
    Result := crSizeNWSE;
    Vertice := 4;
  end;
end;  { TCGraphic.CursorOnRectangleVertice }

class function TCGraphic.CursorOnPlineINVertice(Poly : TPlineIN; X, Y : integer; T : integer;
                                                DefaultCursor : TCursor; var Vertice : integer) : TCursor;
var
  i : integer;
begin
  Vertice := 0; Result := DefaultCursor;
  If Poly.Npoly > 0 then
    for i := 1 to Poly.Npoly do
    begin
      if ((Poly.X[i]-T)<=X) and (X<=(Poly.X[i]+T)) and
         ((Poly.Y[i]-T)<=Y) and (Y<=(Poly.Y[i]+T)) then
      begin
        Vertice := i; Result := crHandPoint;
      end;
    end;
end;  { TCGraphic.CursorOnPlineINVertice }

class function TCGraphic.CursorOnPlineINVertice(Poly : TPlineIN; X, Y : integer; T : integer;
                                                DefaultCursor : TCursor) : TCursor;
var
  i : integer;
begin
  Result := DefaultCursor;
  If Poly.Npoly > 0 then
    for i := 1 to Poly.Npoly do
    begin
      if ((Poly.X[i]-T)<=X) and (X<=(Poly.X[i]+T)) and
         ((Poly.Y[i]-T)<=Y) and (Y<=(Poly.Y[i]+T)) then
      begin
        Result := crHandPoint;
      end;
    end;
end;  { TCGraphic.CursorOnPlineINVertice }

class function TCGraphic.RectangleVertice(Index : byte; R : TRect) : TPoint;
begin                                                   { 4----3 }
  Case Index of                                         { |    | }
    0 : begin                                           { 1----2 }
          Result.X := 0;  Result.Y := 0;             
        end;
    1 : begin
          Result.X := R.Left;  Result.Y := R.Bottom;
        end;
    2 : begin
          Result := R.BottomRight;
        end;
    3 : begin
          Result.X := R.Right;  Result.Y := R.Top;
        end;
    4 : begin
          Result := R.TopLeft;
        end;
  end;
end;  { TCGraphic.RectangleVertice }

class procedure TCGraphic.RectangleEditVertice(Index : byte; X, Y : integer; var R : TRect);
begin                                          { 4----3 }
  Case Index of                                { |    | }
    1 : begin                                  { 1----2 }
          R.Left := X;  R.Bottom := Y;
        end;
    2 : begin
          R.Right := X;  R.Bottom := Y;
        end;
    3 : begin
          R.Right := X;  R.Top := Y;
        end;
    4 : begin
          R.Left := X;  R.Top := Y;
        end;
  end;
end;  { TCGraphic.RectangleEditVertice }

class procedure TCGraphic.Draw_CustomRectangle(Bmp : TBitmap; R : TRect; PenColor : TColor;
                                               PenWidth : integer; PenStyle : TPenStyle);
begin
  with Bmp.Canvas do
  begin
    Pen.Color := PenColor;
    Pen.Style := PenStyle;
    Pen.Width := PenWidth;
    Brush.Style := bsClear;
    Rectangle(R);
  end;
end;  { TCGraphic.Draw_CustomRectangle }

class procedure TCGraphic.EllipseDisplay(Bmp : TBitmap; X, Y : TFloatType; R : integer; SizeRatio : TFloatType;
                                         XPan, YPan : integer);
begin
  Bmp.Canvas.Ellipse(Round(X*SizeRatio) + XPan - R,
                     Bmp.Height-(Round(Y*SizeRatio) + YPan) - R,
                     Round(X*SizeRatio) + XPan + R,
                     Bmp.Height-(Round(Y*SizeRatio) + YPan) + R);
end;  { TCGraphic.EllipseDisplay }

class function TCGraphic.PixelInsideLine(X, Y : integer; X1,Y1,X2,Y2 : TFloatType) : boolean;
begin                    { Uses Bresenham's line tolerance of 0.5 for y error }
  Result := False;
  If (BetweenEq(X,X1,X2,RelPrecision)) then
  begin
    If Unequal(X1,X2,RelPrecision) then
    begin
      If LowerEq(ABS(Y-Linear_Interpolation(X,X1,Y1,X2,Y2)),0.5,RelPrecision) then
        Result := True;
    end
    Else If (BetweenEq(Y,Y1,Y2,RelPrecision)) then
      Result := True;
  end;
end;  { TCGraphic.PixelInsideLine }

class procedure TCGraphic.AddLightPoint(NL : integer; PLs : TLights; N : integer; P : TLight;
                                        var NR : integer; var PR : TLights);
var                       { Acrescenta ponto de luz especificado a frente do ponto de luz N }
  i : integer;
begin
  NR := NL + 1;
  SetLength(PR,NR+1);

  If (1<=N) and (N<=NL-1) then    { N E [1,NL-1] }
  begin
    for i := 1 to N do
      PR[i] := PLs[i];
    PR[N+1] := P;
    for i := N+2 to NR do
      PR[i] := PLs[i-1];
  end
  Else If N = 0 then                      { N = 0 }
  begin
    for i := 1 to NL do
      PR[i+1] := PLs[i];
    PR[1] := P;
  end
  Else If N = NL then             { N = NL }
  begin
    for i := 1 to NL do
      PR[i] := PLs[i];
    PR[NL+1] := P;
  end;

end;  { TCGraphic.AddLightPoint }

class procedure TCGraphic.RemoveLightPoint(NL : integer; PLs : TLights; N : integer;
                                           var NR : integer; var PR : TLights);
var             { Remove ponto de luz especificado na ordem N dos pontos listados }
  i : integer;
begin
  NR := NL-1;
  SetLength(PR,NR+1);
  If (1<=N) and (N<NL) then
  begin
    for i := 1 to N do
      PR[i] := PLs[i];

    for i := N to NL-1 do
      PR[i] := PLs[i+1];
  end
  Else If N = NL then
  begin
    for i := 1 to NL-1 do
      PR[i] := PLs[i];
  end;
end;  { TCGraphic.RemoveLightPoint }

class procedure TCGraphic.AddLightPointSettings(PLs : TLightsSettings; N : integer; P : TLightSettings;
                                                var PR : TLightsSettings);

var                    { Acrescenta ponto de luz especificado a frente do ponto de luz N }
  NL, NR, i : integer;
begin
  NL := High(PLs)+1;
  NR := NL + 1;
  SetLength(PR,NR+1);

  If (1<=N) and (N<=NL-1) then    { N E [1,NL-1] }
  begin
    for i := 1 to N do
      PR[i] := PLs[i];
    PR[N+1] := P;
    for i := N+2 to NR do
      PR[i] := PLs[i-1];
  end
  Else If N = 0 then                      { N = 0 }
  begin
    for i := 1 to NL do
      PR[i+1] := PLs[i];
    PR[1] := P;
  end
  Else If N = NL then             { N = NL }
  begin
    for i := 1 to NL do
      PR[i] := PLs[i];
    PR[NL+1] := P;
  end;

end;  { TCGraphic.AddLightPointSettings }

class procedure TCGraphic.RemoveLightPointSettings(PLs : TLightsSettings; N : integer; var PR : TLightsSettings);
var             { Remove ponto de luz especificado na ordem N dos pontos listados }
  i, NL, NR : integer;
begin
  NL := High(PLs)+1;
  NR := NL-1;
  SetLength(PR,NR+1);
  If (1<=N) and (N<NL) then
  begin
    for i := 1 to N do
      PR[i] := PLs[i];

    for i := N to NL-1 do
      PR[i] := PLs[i+1];
  end
  Else If N = NL then
  begin
    for i := 1 to NL-1 do
      PR[i] := PLs[i];
  end;
end;  { TCGraphic.RemoveLightPointSettings }

class function TCGraphic.PaintersAlgorithm(Faces : TMesh; C : TCamera) : TMesh;
var                       { Algoritmo do Pintor }
  i, j : integer;
  Key : TVetorIN;
  X : TVetorN;
begin
  Result.N := Faces.N;  SetLength(X,Faces.N+1);  SetLength(Result.F,Result.N+1);
  for i := 1 to Faces.N do
    for j := 1 to 3 do
      Result.F[i][j] := ApplyViewPointBasis(Faces.F[i][j],C);

  for i := 1 to Result.N do
    X[i] := (Result.F[i][1].X + Result.F[i][2].X + Result.F[i][3].X)/3;

  { QuickSort at X Centroid Coordinates }
  X := QuickSortMap(Result.N,X,Key);
  Result.F := RefSort(Faces.N,Result.F,Key);
end;  { PaintersAlgorithm }

class function TCGraphic.PaintersAlgorithm(Faces : TMesh) : TMesh;
var                       { Algoritmo do Pintor }
  i, j, k : integer;      { Reordena faces conforme distância ao observador }
  Key : TVetorIN;         { da face N1 até a N2 }
  X : TVetorN;            { Condições: N1 <= N2 ; N1,N2 E [1,Faces.N] }
begin
  Result.N := Faces.N;  SetLength(X,Faces.N+1);  SetLength(Result.F,Faces.N+1);

  for i := 1 to Faces.N do
    X[i] := (Faces.F[i][1].X + Faces.F[i][2].X + Faces.F[i][3].X)/3;

  { QuickSort at X Centroid Coordinates }
  X := QuickSortMap(Faces.N,X,Key);
  Result.F := RefSort(Faces.N,Faces.F,Key);
end;  { PaintersAlgorithm }

class function TCGraphic.CoveredLineX(L1, L2 : T2DLine) : boolean;
begin    { Checks if line L2 is covered by L1 comparing X end's coordinates }
  Result := False;
  If (BetweenEq(L2[1].Y,L1[1].Y,L1[2].Y,RelPrecision)) and
     (BetweenEq(L2[2].Y,L1[1].Y,L1[2].Y,RelPrecision)) then
    Result := True;
end;  { TCGraphic.CoveredLineX }

class function TCGraphic.CoveredLineY(L1, L2 : T2DLine) : boolean;
begin    { Checks if line L2 is covered by L1 comparing Y end's coordinates }
  Result := False;
  If (BetweenEq(L2[1].X,L1[1].X,L1[2].X,RelPrecision)) and
     (BetweenEq(L2[2].X,L1[1].X,L1[2].X,RelPrecision)) then
    Result := True;
end;  { TCGraphic.CoveredLineY }

class procedure TCGraphic.TriangleDominantEdge(T : TTriangle; var N1, N2 : integer);
var
  i : integer;
  Z : TFloatType;
  P : array[1..3]of T2DPoint;
begin
  N1 := 1;  N2 := 2;
  { Change base to plan of triangle }
  for i := 1 to 3 do
    Change_Base_Plan(T[i].X,T[i].Y,T[i].Z,T,P[i].X,P[i].Y,Z);

  { Edge 1-2 }
  If (CoveredLineY(Line2D(P[1],P[2]),Line2D(P[2],P[3]))) and
     (CoveredLineY(Line2D(P[1],P[2]),Line2D(P[3],P[1]))) then
  begin
    N1 := 1;  N2 := 2;
  end;

  { Edge 2-3 }
  If (CoveredLineY(Line2D(P[2],P[3]),Line2D(P[1],P[2]))) and
     (CoveredLineY(Line2D(P[2],P[3]),Line2D(P[3],P[1]))) then
  begin
    N1 := 2;  N2 := 3;
  end;

  { Edge 3-1 }
  If (CoveredLineY(Line2D(P[3],P[1]),Line2D(P[1],P[2]))) and
     (CoveredLineY(Line2D(P[3],P[1]),Line2D(P[2],P[3]))) then
  begin
    N1 := 3;  N2 := 1;
  end;
end;  { TCGraphic.TriangleDominantEdge }

class procedure TCGraphic.TriangleDominantEdgeYZ(T : TTriangle; var N1, N2 : integer);
var
  i : integer;
  P : array[1..3]of T2DPoint;
begin
  N1 := 1;  N2 := 2;
  { Create projections of the Triangle points in YZ plan }
  for i := 1 to 3 do
  begin
    P[i].X := T[i].Y;
    P[i].Y := T[i].Z;
  end;

  { Edge 1-2 }
  If (CoveredLineY(Line2D(P[1],P[2]),Line2D(P[2],P[3]))) and
     (CoveredLineY(Line2D(P[1],P[2]),Line2D(P[3],P[1]))) then
  begin
    N1 := 1;  N2 := 2;
  end;

  { Edge 2-3 }
  If (CoveredLineY(Line2D(P[2],P[3]),Line2D(P[1],P[2]))) and
     (CoveredLineY(Line2D(P[2],P[3]),Line2D(P[3],P[1]))) then
  begin
    N1 := 2;  N2 := 3;
  end;

  { Edge 3-1 }
  If (CoveredLineY(Line2D(P[3],P[1]),Line2D(P[1],P[2]))) and
     (CoveredLineY(Line2D(P[3],P[1]),Line2D(P[2],P[3]))) then
  begin
    N1 := 3;  N2 := 1;
  end;
end;  { TCGraphic.TriangleDominantEdgeYZ }

class function TCGraphic.PixelOnTriangleEdge(X, Y : integer; T : TTriangle) : boolean;
begin
  Result := False;
  If (PixelInsideLine(X,Y,T[1].Y,T[1].Z,T[2].Y,T[2].Z)) or
     (PixelInsideLine(X,Y,T[2].Y,T[2].Z,T[3].Y,T[3].Z)) or
     (PixelInsideLine(X,Y,T[3].Y,T[3].Z,T[1].Y,T[1].Z)) then
    Result := True;
end;  { TCGraphic.PixelOnTriangleEdge }

class function TCGraphic.ScanLineTriangleIntersection(T : TTriangle; Z : TFloatType; var L : T2DLine) : boolean;
var                         { Checks if there are intersections between T and Z }
  Y : array[1..3]of TFloatType;
begin
  Result := False;  L[1] := Point2D(T[1].Y,Z);  L[2] := Point2D(T[1].Y,Z);
  { Calculates the intersections between the Edges and ScanLine Z }
  Y[1] := Linear_Interpolation(Z,T[1].Z,T[1].Y,T[2].Z,T[2].Y);  { Edge 1-2 }
  Y[2] := Linear_Interpolation(Z,T[2].Z,T[2].Y,T[3].Z,T[3].Y);  { Edge 2-3 }
  Y[3] := Linear_Interpolation(Z,T[3].Z,T[3].Y,T[1].Z,T[1].Y);  { Edge 3-1 }

  { Edge 1-2 }
  If (PointInsideLine(0,Y[1],Z,0,T[1].Y,T[1].Z,0,T[2].Y,T[2].Z)) then
  begin
    //ShowMessage('1-2   '+FloatToStrF(Y[1],fffixed,7,3));
    Result := True;
    L[1].X := Y[1];  L[1].Y := Z;  L[2].X := Y[1];  L[2].Y := Z;
  end;
  { Edge 2-3 }
  If (PointInsideLine(0,Y[2],Z,0,T[2].Y,T[2].Z,0,T[3].Y,T[3].Z)) then
  begin
    If Result then        { in case it's not the first intersection }
    begin   //ShowMessage('2-3'+'  2nd   '+FloatToStrF(Y[2],fffixed,7,3));
      L[2].X := Y[2];  L[2].Y := Z;
    end
    Else If Result = False then  { if it's the first intersection }
    begin   //ShowMessage('2-3'+'  1st   '+FloatToStrF(Y[2],fffixed,7,3));
      L[1].X := Y[2];  L[1].Y := Z;  L[2].X := Y[2];  L[2].Y := Z;
    end;
    Result := True;
  end;
  { Edge 3-1 }
  If (PointInsideLine(0,Y[3],Z,0,T[3].Y,T[3].Z,0,T[1].Y,T[1].Z)) then
  begin
    If Result then        { in case it's not the first intersection }
    begin   //ShowMessage('3-1'+'  2nd   '+FloatToStrF(Y[3],fffixed,7,3));
      L[2].X := Y[3];  L[2].Y := Z;
    end
    Else If Result = False then  { if it's the first intersection }
    begin   //ShowMessage('3-1'+'  1st   '+FloatToStrF(Y[3],fffixed,7,3));
      L[1].X := Y[3];  L[1].Y := Z;  L[2].X := Y[3];  L[2].Y := Z;
    end;
    Result := True;
  end;
end;  { TCGraphic.ScanLineTriangleIntersection }

class function TCGraphic.ScanLineTriangleIntersection(T : TTriangle; Z : integer; A1,A2,B1,B2 : Int03) : TLine;
var
  Amin, Amax, Bmin, Bmax : integer;
begin                         { Checks the intersections between T and Z }
  Amin := Round(Min(T[A1].Y,T[A2].Y));  Amax := Round(Max(T[A1].Y,T[A2].Y));
  Bmin := Round(Min(T[B1].Y,T[B2].Y));  Bmax := Round(Max(T[B1].Y,T[B2].Y));
  { Calculates the intersections between the Edges and ScanLine Z }
  Result[1].X := Round(Linear_Interpolation(Z,T[A1].Z,T[A1].Y,T[A2].Z,T[A2].Y));  { Edge A1-A2 }
  Result[2].X := Round(Linear_Interpolation(Z,T[B1].Z,T[B1].Y,T[B2].Z,T[B2].Y));  { Edge B1-B2 }

  Result[1].X := Confine(Result[1].X,Amin,Amax);  Result[2].X := Confine(Result[2].X,Bmin,Bmax);
  Result[1].Y := Z;  Result[2].Y := Z;
end;  { TCGraphic.ScanLineTriangleIntersection }

class function TCGraphic.ScanLineTriangle(T : TTriangle; Z : TFloatType; C : TCamera; Width,Height : integer;
                                          SizeRatio : TFloatType; XPan, YPan : integer) : TScreenLine;
var                  { Determines the intersections between a triangle and a scanline }
  i, j : integer;    { Screen points are pixels with x buffer depth information }
  L : T2DLine;
  Smin, Smax : integer;
  TR : TTriangle;
  XN,YN,ZN : TFloatType;
  P : T3DPoint;
begin
  { Initializes variables }
  L[1] := Point2D(0,0);  L[2] := Point2D(0,0);

  for i := 1 to 3 do
    TR[i] := ReverseScalePanFloat(T[i],Height,SizeRatio,XPan,YPan);

  { Computes Intersections between edges and scanline }
  If C.Perspective then        { Perspective }
  begin
    for i := 1 to 3 do
      TR[i] := ReversePerspectiveProjection(TR[i],Point3D(0,0,0),C.xlens);
    TriangleNormalVector(TR,XN,YN,ZN);

    If ScanLineTriangleIntersection(T,Z,L) then
    begin     { It exists intersection }
      If not (((Lower(L[1].X,0,RelPrecision)) and (Lower(L[2].X,0,RelPrecision))) or
              ((Greater(L[1].X,Width,RelPrecision)) and (Greater(L[2].X,Width,RelPrecision)))) then
      begin   { Intersections are inside the screen boundaries }
        Smin := Round(Min(L[1].X,L[2].X));
        Smax := Round(Max(L[1].X,L[2].X));
        Smin := Min(Width,Smin);  Smin := Max(0,Smin);
        Smax := Min(Width,Smax);  Smax := Max(0,Smax);

        j := 0;  SetLength(Result,Smax-Smin+2);
        for i := Smin to Smax do
        begin
          j := j + 1;
          Result[j].P.X := i;
          Result[j].P.Y := Round(Z);
          P := Point3D(0,i,Z);
          P := ReverseScalePanFloat(P,Height,SizeRatio,XPan,YPan);
          Result[j].X := PlanePointDepthPersp(P.Y,P.Z,C.xlens,TR[1].X,TR[1].Y,TR[1].Z,XN,YN,ZN);
        end;
      end;
    end;
  end
  Else If C.Perspective = False then  { Isometric }
  begin
    TriangleNormalVector(TR,XN,YN,ZN);

    If ScanLineTriangleIntersection(T,Z,L) then
    begin     { It exists intersection }
      If not (((Lower(L[1].X,0,RelPrecision)) and (Lower(L[2].X,0,RelPrecision))) or
              ((Greater(L[1].X,Width,RelPrecision)) and (Greater(L[2].X,Width,RelPrecision)))) then
      begin   { Intersections are inside the screen boundaries }
        Smin := Round(Min(L[1].X,L[2].X));
        Smax := Round(Max(L[1].X,L[2].X));
        Smin := Min(Width,Smin);  Smin := Max(0,Smin);
        Smax := Min(Width,Smax);  Smax := Max(0,Smax);

        j := 0;  SetLength(Result,Smax-Smin+2);
        for i := Smin to Smax do
        begin
          j := j + 1;
          Result[j].P.X := i;
          Result[j].P.Y := Round(Z);
          P := Point3D(0,i,Z);
          P := ReverseScalePanFloat(P,Height,SizeRatio,XPan,YPan);
          Result[j].X := PlanePointDepth(P.Y,P.Z,TR[1].X,TR[1].Y,TR[1].Z,XN,YN,ZN);
        end;
      end;
    end;
  end;
end;  { TCGraphic.ScanLineTriangle }

class function TCGraphic.ScanLineTriangle_Isom(T : TTriangle; Z : TFloatType; C : TCamera; Width,Height : integer;
                                               SizeRatio : TFloatType; XPan, YPan : integer) : TScreenLine;
var                  { Determines the intersections between a triangle and a scanline }
  i, j : integer;    { Screen points are pixels with x buffer depth information }
  L : T2DLine;
  Smin, Smax : integer;
  TR : TTriangle;
  XN,YN,ZN : TFloatType;
  P : T3DPoint;
begin
  { Initializes variables }
  L[1] := Point2D(0,0);  L[2] := Point2D(0,0);

  for i := 1 to 3 do
    TR[i] := ReverseScalePanFloat(T[i],Height,SizeRatio,XPan,YPan);

  TriangleNormalVector(TR,XN,YN,ZN);

  { Computes Intersections between edges and scanline }
  If ScanLineTriangleIntersection(T,Z,L) then
  begin     { It exists intersection }
    If not (((Lower(L[1].X,0,RelPrecision)) and (Lower(L[2].X,0,RelPrecision))) or
            ((Greater(L[1].X,Width,RelPrecision)) and (Greater(L[2].X,Width,RelPrecision)))) then
    begin   { Intersections are inside the screen boundaries }
      Smin := Round(Min(L[1].X,L[2].X));
      Smax := Round(Max(L[1].X,L[2].X));
      Smin := Min(Width,Smin);  Smin := Max(0,Smin);
      Smax := Min(Width,Smax);  Smax := Max(0,Smax);

      j := 0;  SetLength(Result,Smax-Smin+2);
      for i := Smin to Smax do
      begin
        j := j + 1;
        Result[j].P.X := i;
        Result[j].P.Y := Round(Z);
        P := Point3D(0,i,Z);
        P := ReverseScalePanFloat(P,Height,SizeRatio,XPan,YPan);
        Result[j].X := PlanePointDepth(P.Y,P.Z,TR[1].X,TR[1].Y,TR[1].Z,XN,YN,ZN);
      end;
    end;
  end;
end;  { TCGraphic.ScanLineTriangle_Isom }

class function TCGraphic.ScanLineTriangle_Persp(T : TTriangle; Z : TFloatType; C : TCamera; Width,Height : integer;
                                                SizeRatio : TFloatType; XPan, YPan : integer) : TScreenLine;
var                  { Determines the intersections between a triangle and a scanline }
  i, j : integer;    { Screen points are pixels with x buffer depth information }
  L : T2DLine;
  Smin, Smax : integer;
  TR : TTriangle;
  XN,YN,ZN : TFloatType;
  P : T3DPoint;
begin
  { Initializes variables }
  L[1] := Point2D(0,0);  L[2] := Point2D(0,0);

  for i := 1 to 3 do
    TR[i] := ReverseScalePanFloat(T[i],Height,SizeRatio,XPan,YPan);

  TriangleNormalVector(TR,XN,YN,ZN);

  for i := 1 to 3 do
    TR[i] := ReversePerspectiveProjection(TR[i],Point3D(0,0,0),C.xlens);
  TriangleNormalVector(TR,XN,YN,ZN);

  { Computes Intersections between edges and scanline }
  If ScanLineTriangleIntersection(T,Z,L) then
  begin     { It exists intersection }
    If not (((Lower(L[1].X,0,RelPrecision)) and (Lower(L[2].X,0,RelPrecision))) or
            ((Greater(L[1].X,Width,RelPrecision)) and (Greater(L[2].X,Width,RelPrecision)))) then
    begin   { Intersections are inside the screen boundaries }
      Smin := Round(Min(L[1].X,L[2].X));
      Smax := Round(Max(L[1].X,L[2].X));
      Smin := Min(Width,Smin);  Smin := Max(0,Smin);
      Smax := Min(Width,Smax);  Smax := Max(0,Smax);

      j := 0;  SetLength(Result,Smax-Smin+2);
      for i := Smin to Smax do
      begin
        j := j + 1;
        Result[j].P.X := i;
        Result[j].P.Y := Round(Z);
        P := Point3D(0,i,Z);
        P := ReverseScalePanFloat(P,Height,SizeRatio,XPan,YPan);
        Result[j].X := PlanePointDepthPersp(P.Y,P.Z,C.xlens,TR[1].X,TR[1].Y,TR[1].Z,XN,YN,ZN);
      end;
    end;
  end;
end;  { TCGraphic.ScanLineTriangle_Persp }

class function TCGraphic.ScanLineTriangleIntersectionR(T : TTriangle; Z : TFloatType; var L : T2DLine) : boolean;
var                         { Checks if there are intersections between T and Z }
  Y : array[1..3]of TFloatType;
begin
  Result := False;  L[1] := Point2D(0,0);  L[2] := Point2D(0,0);
  { Calculates the intersections between the Edges and ScanLine Z }
  Y[1] := Linear_Interpolation(Z,T[1].Z,T[1].Y,T[2].Z,T[2].Y);
  Y[2] := Linear_Interpolation(Z,T[2].Z,T[2].Y,T[3].Z,T[3].Y);
  Y[3] := Linear_Interpolation(Z,T[3].Z,T[3].Y,T[1].Z,T[1].Y);

  { Edge 1-2 }
  If (PointInsideLineR(0,Y[1],Z,0,T[1].Y,T[1].Z,0,T[2].Y,T[2].Z)) then
  begin
    //ShowMessage('1-2   '+FloatToStrF(Y[1],fffixed,7,3));
    Result := True;
    L[1].X := Y[1];  L[1].Y := Z;  L[2].X := Y[1];  L[2].Y := Z;
  end;
  { Edge 2-3 }
  If (PointInsideLineR(0,Y[2],Z,0,T[2].Y,T[2].Z,0,T[3].Y,T[3].Z)) then
  begin

    If Result then        { in case it's not the first intersection }
    begin   //ShowMessage('2-3'+'  2nd   '+FloatToStrF(Y[2],fffixed,7,3));
      L[2].X := Y[2];  L[2].Y := Z;
    end
    Else If Result = False then  { it's the first intersection }
    begin   //ShowMessage('2-3'+'  1st   '+FloatToStrF(Y[2],fffixed,7,3));
      L[1].X := Y[2];  L[1].Y := Z;  L[2].X := Y[2];  L[2].Y := Z;
    end;
    Result := True;
  end;
  { Edge 3-1 }
  If (PointInsideLineR(0,Y[3],Z,0,T[3].Y,T[3].Z,0,T[1].Y,T[1].Z)) then
  begin
    If Result then        { in case it's not the first intersection }
    begin   //ShowMessage('3-1'+'  2nd   '+FloatToStrF(Y[3],fffixed,7,3));
      L[2].X := Y[3];  L[2].Y := Z;
    end
    Else If Result = False then  { it's the first intersection }
    begin   //ShowMessage('3-1'+'  1st   '+FloatToStrF(Y[3],fffixed,7,3));
      L[1].X := Y[3];  L[1].Y := Z;  L[2].X := Y[3];  L[2].Y := Z;
    end;
    Result := True;
  end;
end;  { TCGraphic.ScanLineTriangleIntersectionR }

class function TCGraphic.ScanLineTriangleR(T : TTriangle; Z : TFloatType; C : TCamera; Width,Height : integer;
                                           SizeRatio : TFloatType; XPan, YPan : integer) : TScreenLine;
var                  { Determines the intersections between a triangle and a scanline }
  i, j : integer;    { Screen points are pixels with x buffer depth information }
  L : T2DLine;
  Smin, Smax : integer;
  TR : TTriangle;
  XN,YN,ZN : TFloatType;
  P : T3DPoint;
begin
  { Initializes variables }
  L[1] := Point2D(0,0);  L[2] := Point2D(0,0);

  for i := 1 to 3 do
    TR[i] := ReverseScalePanFloat(T[i],Height,SizeRatio,XPan,YPan);

  { Computes Intersections between edges and scanline }
  If C.Perspective then        { Perspective }
  begin
    for i := 1 to 3 do
      TR[i] := ReversePerspectiveProjection(TR[i],Point3D(0,0,0),C.xlens);
    TriangleNormalVector(TR,XN,YN,ZN);

    If ScanLineTriangleIntersection(T,Z,L) then
    begin     { It exists intersection }
      If not (((L[1].X < 0) and (L[2].X < 0)) or
              ((L[1].X > Width) and (L[2].X > Width))) then
      begin   { Intersections are inside the screen boundaries }
        Smin := Round(Min(L[1].X,L[2].X));
        Smax := Round(Max(L[1].X,L[2].X));
        Smin := Min(Width,Smin);  Smin := Max(0,Smin);
        Smax := Min(Width,Smax);  Smax := Max(0,Smax);
        
        j := 0;  SetLength(Result,Smax-Smin+2);
        for i := Smin to Smax do
        begin
          j := j + 1;
          Result[j].P.X := i;
          Result[j].P.Y := Round(Z);
          P := Point3D(0,i,Z);
          P := ReverseScalePanFloat(P,Height,SizeRatio,XPan,YPan);
          Result[j].X := PlanePointDepthPersp(P.Y,P.Z,C.xlens,TR[1].X,TR[1].Y,TR[1].Z,XN,YN,ZN);
        end;
      end;
    end;
  end
  Else If C.Perspective = False then  { Isometric }
  begin
    TriangleNormalVector(TR,XN,YN,ZN);

    If ScanLineTriangleIntersection(T,Z,L) then
    begin     { It exists intersection }
      If not (((L[1].X < 0) and (L[2].X < 0)) or
              ((L[1].X > Width) and (L[2].X > Width))) then
      begin   { Intersections are inside the screen boundaries }
        Smin := Round(Min(L[1].X,L[2].X));
        Smax := Round(Max(L[1].X,L[2].X));
        Smin := Min(Width,Smin);  Smin := Max(0,Smin);
        Smax := Min(Width,Smax);  Smax := Max(0,Smax);

        j := 0;  SetLength(Result,Smax-Smin+2);
        for i := Smin to Smax do
        begin
          j := j + 1;
          Result[j].P.X := i;
          Result[j].P.Y := Round(Z);
          P := Point3D(0,i,Z);
          P := ReverseScalePanFloat(P,Height,SizeRatio,XPan,YPan);
          Result[j].X := PlanePointDepth(P.Y,P.Z,TR[1].X,TR[1].Y,TR[1].Z,XN,YN,ZN);
        end;
      end;
    end;
  end;
end;  { TCGraphic.ScanLineTriangleR }

class procedure TCGraphic.ScanLineSubTriangleEnds(T : TTriangle; Index : Int03; Z : integer;
                                                  var L : TLine);
var                { Computes the intersection line L between T and Z }
  i, j : Int03;    { T is a subtriangle, i.e., it has a horizontal edge opposite to Index }
begin
  { Indexes of the Horizontal edge opposite to Index }
  i := TriangleEdgeIndexes[Index,1];  j := TriangleEdgeIndexes[Index,2];
  L[1].X := Round(Linear_Interpolation(Z,T[Index].Z,T[Index].Y,T[i].Z,T[i].Y));  { Edge Index-i }
  L[2].X := Round(Linear_Interpolation(Z,T[Index].Z,T[Index].Y,T[j].Z,T[j].Y));  { Edge Index-j }
  L[1].Y := Z;  L[2].Y := Z;
end;  { TCGraphic.ScanLineSubTriangleIntersection }

class function TCGraphic.ScanLineSubTriangle_Isom(T : TTriangle; Index : Int03; Z : integer;
                                                  C : TCamera; Width,Height : integer;
                                                  SizeRatio : TFloatType; XPan, YPan : integer) : TScreenLine;
var                  { Determines the intersections between a subtriangle and a scanline }
  i, j : integer;    { Screen points are pixels with x buffer depth information }
  L : TLine;
  Smin, Smax : integer;
  TR : TTriangle;
  XN,YN,ZN : TFloatType;
  P : T3DPoint;
begin
  { Initializes variables }
  for i := 1 to 3 do
    TR[i] := ReverseScalePanFloat(T[i],Height,SizeRatio,XPan,YPan);
  TriangleNormalVector(TR,XN,YN,ZN);

  { Computes Intersections between edges and scanline }
  ScanLineSubTriangleEnds(T,Index,Z,L);

  Smin := Round(Min(L[1].X,L[2].X));
  Smax := Round(Max(L[1].X,L[2].X));
  Smin := Confine(Smin,0,Width);  Smax := Confine(Smax,0,Width);

  j := 0;  SetLength(Result,Smax-Smin+2);
  If Smax>Smin then
    for i := Smin to Smax do
    begin
      j := j + 1;
      Result[j].P.X := i;
      Result[j].P.Y := Round(Z);
      P := Point3D(0,i,Z);
      P := ReverseScalePanFloat(P,Height,SizeRatio,XPan,YPan);
      Result[j].X := PlanePointDepth(P.Y,P.Z,TR[1].X,TR[1].Y,TR[1].Z,XN,YN,ZN);
    end;
end;  { TCGraphic.ScanLineSubTriangle_Isom }

class function TCGraphic.ScanLineSubTriangle_Persp(T : TTriangle; Index : Int03; Z : integer;
                                                   C : TCamera; Width,Height : integer;
                                                   SizeRatio : TFloatType; XPan, YPan : integer) : TScreenLine;
var                  { Determines the intersections between a triangle and a scanline }
  i, j : integer;    { Screen points are pixels with x buffer depth information }
  L : TLine;
  Smin, Smax : integer;
  TR : TTriangle;
  XN,YN,ZN : TFloatType;
  P : T3DPoint;
begin
  { Initializes variables }
  for i := 1 to 3 do
    TR[i] := ReverseScalePanFloat(T[i],Height,SizeRatio,XPan,YPan);

  TriangleNormalVector(TR,XN,YN,ZN);

  for i := 1 to 3 do
    TR[i] := ReversePerspectiveProjection(TR[i],Point3D(0,0,0),C.xlens);

  TriangleNormalVector(TR,XN,YN,ZN);

  { Computes Intersections between edges and scanline }
  ScanLineSubTriangleEnds(T,Index,Z,L);

  Smin := Round(Min(L[1].X,L[2].X));
  Smax := Round(Max(L[1].X,L[2].X));
  Smin := Confine(Smin,0,Width);  Smax := Confine(Smax,0,Width);

  j := 0;  SetLength(Result,Smax-Smin+2);
  for i := Smin to Smax do
  begin
    j := j + 1;
    Result[j].P.X := i;
    Result[j].P.Y := Round(Z);
    P := Point3D(0,i,Z);
    P := ReverseScalePanFloat(P,Height,SizeRatio,XPan,YPan);
    Result[j].X := PlanePointDepthPersp(P.Y,P.Z,C.xlens,TR[1].X,TR[1].Y,TR[1].Z,XN,YN,ZN);
  end;
end;  { TCGraphic.ScanLineSubTriangle_Persp }

class procedure TCGraphic.Draw_Polygons(Faces : TMesh; Bmp : TBitmap; PenColor : TColor;
                                        PenWidth : integer; SizeRatio : TFloatType;
                                        AmbientLight : TAmbientLight; NoLights : integer;
                                        PtsLight : TLights; M : TMaterial;
                                        C : TCamera; Edges : boolean; XPan, YPan : integer);
var
  i, j : integer;
  X,Y,Z, XN,YN,ZN, XR,YR,ZR: TFloatType;
  V, B : T3DPoint;
  P : array[1..3]of TScreenPoint;
  TR : TTriangle;
  PtsL : TLights;
  LR, LG, LB : TFloatType;
begin
  EMsg := '';
  { Pontos de Luz em Relação à Câmera }
  SetLength(PtsL,NoLights+1);
  for i := 1 to NoLights do
  begin
    PtsL[i].Pos := ApplyViewPointBasis(PtsLight[i].Pos,C);
    PtsL[i].IL := PtsLight[i].IL;
    PtsL[i].Attenuation := PtsLight[i].Attenuation;
  end;
  V := Point3D(0,0,0);
  If C.Perspective then     // Transformação Inversa de Perspectiva
  begin
    for i := 1 to NoLights do
      PtsL[i].Pos := TCGraphic.ReversePerspectiveProjection(PtsL[i].Pos,V,C.xlens);
  end;

  { Algoritmo do Pintor }
  Faces := PaintersAlgorithm(Faces);

  for i := 1 to Faces.N do
  begin
    TR := Faces.F[i];
    { Transformação Inversa de Perspectiva }
    If C.Perspective then
    begin
      for j := 1 to 3 do
        TR[j] := TCGraphic.ReversePerspectiveProjection(Faces.F[i][j],V,C.xlens);
    end;

    { Calcula Vetor Normal e Centróide do triângulo }
    TriangleNormalVector(TR,XN,YN,ZN);
    TriangleCenter(TR,X,Y,Z);

    {EMsg := EMsg + IntToStr(i)+char(9)+TriangleToStr(TR,', ',fffixed,7,3)+char(13)+
                   char(9)+'VN '+PointToStr(XN,YN,ZN,', ',fffixed,7,3)+char(9)+
                   'C '+PointToStr(X,Y,Z,', ',fffixed,7,3)+char(13);}

    { Determina Intensidade da Luz - LR, LG, LB }
    TCGraphic.PhongShadeR(AmbientLight,NoLights,PtsL,M,X,Y,Z,XN,YN,ZN,LR,LG,LB);
    { Limita LR,LG,LB entre 0 e 255 }
    LR := Confine(LR,0,255);  LG := Confine(LG,0,255);  LB := Confine(LB,0,255);

    //ShowMessage(IntToStr(i)+' '+PointToStr(Point3D(X,Y,Z),fffixed,7,3));

    { Desenha Polígono }
    Bmp.Canvas.Pen.Width := PenWidth;
    Bmp.Canvas.Brush.Color := RGB(Round(LR),Round(LG),Round(LB));

    If Edges = False then       { não exibe arestas do polígono }
      Bmp.Canvas.Pen.Color := RGB(Round(LR),Round(LG),Round(LB))
    Else If Edges then   { exibe arestas do polígono }
      Bmp.Canvas.Pen.Color := PenColor;

    for j := 1 to 3 do
      P[j] := ScreenPoint(Faces.F[i][j],SizeRatio,Bmp.Height,XPan,YPan);

    //ShowMessage(IntToStr(i)+' '+PointToStr(Point3D(P[1].X,P[1].P.X,P[1].P.Y),fffixed,7,3));

    If TriangleLowerEqX(TR,C.xlens) then
      Bmp.Canvas.Polygon([P[1].P, P[2].P, P[3].P]);

    (*ReflectedVector(X-PtsL[1].Pos.X, Y-PtsL[1].Pos.Y, Z-PtsL[1].Pos.Z, XN, YN, ZN, XR, YR, ZR);
    {VetorUnitario(XR,YR,ZR,XR,YR,ZR);    FactorPoint3D(2,XR,YR,ZR);}
    VetorUnitario(XN,YN,ZN, XN,YN,ZN);    //FactorPoint3D(2,XN,YN,ZN);
    B := SumPoint3D(Point3D(X,Y,Z),Point3D(XN,YN,ZN));
    TCGraphic.Mark_2DPoint(B.Y,B.Z,Bmp,clRed,1,1,2,SizeRatio,XPan,YPan);*)
  end;
end;  { TCGraphic.Draw_Polygons }

class procedure TCGraphic.Draw_Polygons_XBuffer(Faces : TMesh; Bmp : TBitmap; PenColor : TColor;
                                                AmbientLight : TAmbientLight; NoLights : integer;
                                                PtsLight : TLights; M : TMaterial; C : TCamera;
                                                Edges : boolean; SizeRatio : TFloatType; XPan, YPan : integer;
                                                var Buffer : TMatrizNxN);
var                               { Render algorithm that checks all polygons intersections }
  i, j, k, N, s : integer;        { for each scanline. It's recommended for big polygons, }
  PtsL : TLights;                 { that cover the whole screen. It's very slow. }
  PixelLine : TScreenLine;
  TID : TVetorIN;
  T : TTriangle;
  P : T3DPoint;
  XN,YN,ZN : TFloatType;
  LR,LG,LB : TFloatType;
begin
  { Light points relative to camera }
  SetLength(PtsL,NoLights+1);
  for i := 1 to NoLights do
  begin
    PtsL[i].Pos := ApplyViewPointBasis(PtsLight[i].Pos,C);
    PtsL[i].IL := PtsLight[i].IL;
    PtsL[i].Attenuation := PtsLight[i].Attenuation;
  end;
  If C.Perspective then
  begin
    for i := 1 to NoLights do
      PtsL[i].Pos := TCGraphic.ReversePerspectiveProjection(PtsL[i].Pos,Point3D(0,0,0),C.xlens);
  end;

  { Mesh as it is shown on screen }
  for i := 1 to Faces.N do
    for j := 1 to 3 do
      Faces.F[i][j] := ScalePanFloat(Faces.F[i][j],Bmp.Height,SizeRatio,XPan,YPan);

  SetLength(TID,Bmp.Width+1);

  for i := 0 to Bmp.Height-1 do    { on each ScanLine }
  begin
    for j := 0 to Bmp.Width-1 do
      TID[j] := 0;
    for j := 1 to Faces.N do     { on each triangle }
    begin
      SetLength(PixelLine,0);
      PixelLine := ScanLineTriangleR(Faces.F[j],i,C,Bmp.Width,Bmp.Height,SizeRatio,XPan,YPan);
      N := High(PixelLine);
      //ShowMessage(IntToStr(i)+'  '+IntToStr(N));
      If N > 0 then  { not an empty array }
      begin
        s := 0;
        for k := PixelLine[1].P.X to PixelLine[N].P.X do
        begin
          s := s + 1;

          If Buffer[k,i] < PixelLine[s].X then
          begin
            Buffer[k,i] := PixelLine[s].X;
            TID[k] := j;  { triangle index that generates the pixel }
          end;
        end;
      end;
    end;

    for j := 0 to Bmp.Width-1 do
    begin
      If TID[j] > 0 then
      begin
        P := ReverseScalePanFloat(Point3D(Buffer[j,i],j,i),Bmp.Height,SizeRatio,XPan,YPan);
        for k := 1 to 3 do
          T[k] := ReverseScalePanFloat(Faces.F[TID[j]][k],Bmp.Height,SizeRatio,XPan,YPan);

        If C.Perspective then
        begin
          for k := 1 to 3 do
            T[k] := TCGraphic.ReversePerspectiveProjection(T[k],Point3D(0,0,0),C.xlens);
        end;
        { Normal Vector }
        TriangleNormalVector(T,XN,YN,ZN);

        { Light Intensity }
        TCGraphic.PhongShade(AmbientLight,NoLights,PtsL,M,P.X,P.Y,P.Z,XN,YN,ZN,LR,LG,LB);
        { Limit Lights Intensities between 0 and 255 }
        LR := Confine(LR,0,255);  LG := Confine(LG,0,255);  LB := Confine(LB,0,255);

        Bmp.Canvas.Pixels[j,i] := RGB(Round(LR),Round(LG),Round(LB));
      end;
    end;
  end;
end;  { TCGraphic.Draw_Polygons_XBuffer }

class procedure TCGraphic.Draw_Polygons_XBuffer_Opt(Faces : TMesh; Bmp : TBitmap; PenColor : TColor;
                                                    AmbientLight : TAmbientLight; NoLights : integer;
                                                    PtsLight : TLights; M : TMaterial; C : TCamera;
                                                    Edges : boolean; SizeRatio : TFloatType; XPan, YPan : integer;
                                                    var Buffer : TMatrizNxN);
var                               { Render algorithm that determines the scanlines required to map }
  i, j, k, N, s : integer;        { each polygon. It's recommended for small polygons, that do not }
  PtsL          : TLights;        { cover the whole screen. }
  PixelLine     : TScreenLine;
  T             : TTriangle;
  Zmin, Zmax    : integer;
  InBounds      : boolean;
  P             : T3DPoint;
  XN,YN,ZN      : TFloatType;
  LR,LG,LB      : TFloatType;
begin
  { Light points relative to camera }
  SetLength(PtsL,NoLights+1);
  for i := 1 to NoLights do
  begin
    PtsL[i].Pos := ApplyViewPointBasis(PtsLight[i].Pos,C);
    PtsL[i].IL := PtsLight[i].IL;
    PtsL[i].Attenuation := PtsLight[i].Attenuation;
  end;
  If C.Perspective then
  begin
    for i := 1 to NoLights do
      PtsL[i].Pos := TCGraphic.ReversePerspectiveProjection(PtsL[i].Pos,Point3D(0,0,0),C.xlens);
  end;

  { Building Buffer from the Faces }
  If Edges then                  { EDGES - ON }
    XBuffer_Mesh(Faces,Bmp.Width,Bmp.Height,C,SizeRatio,XPan,YPan,Buffer,TID,EdgeID)
  Else If Edges = False then            { EDGES - OFF }
    XBuffer_Mesh(Faces,Bmp.Width,Bmp.Height,C,SizeRatio,XPan,YPan,Buffer,TID);

  If C.Perspective then
  begin
    If Edges then
      DrawPolXBuffer_BMP(Faces,Bmp,PenColor,Buffer,TID,EdgeID,AmbientLight,NoLights,PtsL,M,C.xlens,SizeRatio,XPan,YPan)
    Else If Edges = False then
      DrawPolXBuffer_BMP(Faces,Bmp,Buffer,TID,AmbientLight,NoLights,PtsL,M,C.xlens,SizeRatio,XPan,YPan)
  end
  Else If C.Perspective = False then
  begin
    If Edges then
      DrawPolXBuffer_BMP(Faces,Bmp,PenColor,Buffer,TID,EdgeID,AmbientLight,NoLights,PtsL,M,SizeRatio,XPan,YPan)
    Else If Edges = False then
      DrawPolXBuffer_BMP(Faces,Bmp,Buffer,TID,AmbientLight,NoLights,PtsL,M,SizeRatio,XPan,YPan);
  end;
end;  { TCGraphic.Draw_Polygons_XBuffer_Opt }

class procedure TCGraphic.Draw_Polygons_XBuffer_Opt2(Faces : TMesh; Bmp : TBitmap; PenColor : TColor;
                                                     AmbientLight : TAmbientLight; NoLights : integer;
                                                     PtsLight : TLights; M : TMaterial; C : TCamera;
                                                     Edges : boolean; SizeRatio : TFloatType; XPan, YPan : integer;
                                                     var Buffer : TMatrizNxN);
var                                { Render algorithm that determines the scanlines required to map }
  i, j, k, N, s  : integer;        { each polygon. It's recommended for small polygons, that do not }
  PtsL           : TLights;        { cover the whole screen. }
  PixelLine      : TScreenLine;
  T              : TTriangle;
  Zmin, Zmax     : integer;        { WARNING }
  InBounds       : boolean;        { Use Drawing Parameters as Global variables }
  P              : T3DPoint;       { Use Buffer as Global variable }
  XN,YN,ZN       : TFloatType;     { Drawing Parameters - AmbientLight, NoLights, PtsLights, Material }
  LR,LG,LB       : TFloatType;     {                      Camera, Edges, SizeRatio, XPan, YPan }
  Index1, Index2 : Int03;
  FacesScreen    : TMesh;
begin
  { Light points relative to camera }
  SetLength(PtsL,NoLights+1);
  for i := 1 to NoLights do
  begin
    PtsL[i].Pos := ApplyViewPointBasis(PtsLight[i].Pos,C);
    PtsL[i].IL := PtsLight[i].IL;
    PtsL[i].Attenuation := PtsLight[i].Attenuation;
  end;
  If C.Perspective then
  begin
    for i := 1 to NoLights do
      PtsL[i].Pos := TCGraphic.ReversePerspectiveProjection(PtsL[i].Pos,Point3D(0,0,0),C.xlens);
  end;

  { Mesh as it is shown on screen }
  FacesScreen := Faces;
  for i := 1 to Faces.N do
    for j := 1 to 3 do
      FacesScreen.F[i][j] := ScalePanFloat(Faces.F[i][j],Bmp.Height,SizeRatio,XPan,YPan);

  { Rasterization - Building Buffer from the Faces }
  If Edges then                        { EDGES - ON }
  begin
    TID := InitializeMatrix(Bmp.Height,Bmp.Width,0);         { Identifier of triangle index from which the pixel belongs }
    EdgeID := InitializeMatrix(Bmp.Height,Bmp.Width,False);  { Identifier of pixel belonging to a triangle edge }

    If not C.Perspective then          { Perspective - OFF }
    begin
      for i := 1 to Faces.N do begin
        RasterizeTriangleIsom(FacesScreen.F[i],i,C,Bmp.Width,Bmp.Height,SizeRatio,XPan,YPan,Buffer,TID,EdgeID);
      end;
    end
    Else begin                         { Perspective - ON }
      for i := 1 to Faces.N do begin
        RasterizeTrianglePersp(FacesScreen.F[i],i,C,Bmp.Width,Bmp.Height,SizeRatio,XPan,YPan,Buffer,TID,EdgeID);
      end;
    end;
  end
  Else begin                           { EDGES - OFF }
    TID := InitializeMatrix(Bmp.Height,Bmp.Width,0);         { Identifier of triangle index from which the pixel belongs }

    If not C.Perspective then          { Perspective - OFF }
    begin
      for i := 1 to Faces.N do begin
        RasterizeTriangleIsom(FacesScreen.F[i],i,C,Bmp.Width,Bmp.Height,SizeRatio,XPan,YPan,Buffer,TID);
      end;
    end
    Else begin                         { Perspective - ON }
      for i := 1 to Faces.N do begin
        RasterizeTrianglePersp(FacesScreen.F[i],i,C,Bmp.Width,Bmp.Height,SizeRatio,XPan,YPan,Buffer,TID);
      end;
    end;
  end;

  If C.Perspective then
  begin
    If Edges then
      DrawPolXBuffer_BMP(Faces,Bmp,PenColor,Buffer,TID,EdgeID,AmbientLight,NoLights,PtsL,M,C.xlens,SizeRatio,XPan,YPan)
    Else If Edges = False then
      DrawPolXBuffer_BMP(Faces,Bmp,Buffer,TID,AmbientLight,NoLights,PtsL,M,C.xlens,SizeRatio,XPan,YPan)
  end
  Else If C.Perspective = False then
  begin
    If Edges then
      DrawPolXBuffer_BMP(Faces,Bmp,PenColor,Buffer,TID,EdgeID,AmbientLight,NoLights,PtsL,M,SizeRatio,XPan,YPan)
    Else If Edges = False then
      DrawPolXBuffer_BMP(Faces,Bmp,Buffer,TID,AmbientLight,NoLights,PtsL,M,SizeRatio,XPan,YPan);
  end;
end;  { TCGraphic.Draw_Polygons_XBuffer_Opt2 }

class function TCGraphic.ScanLineTriangleIsom(T : TTriangle; Z : integer; A1,A2,B1,B2 : Int03;
                                              C : TCamera; Width,Height : integer;
                                              SizeRatio : TFloatType; XPan, YPan : integer) : TScreenLine;
var                  { Determines the intersections between a subtriangle and a scanline }
  i, j : integer;    { Screen points are pixels with x buffer depth information }
  L : TLine;
  Smin, Smax : integer;
  TR : TTriangle;
  XN,YN,ZN : TFloatType;
  P : T3DPoint;
begin
  { Initializes variables }
  for i := 1 to 3 do
    TR[i] := ReverseScalePanFloat(T[i],Height,SizeRatio,XPan,YPan);
  TriangleNormalVector(TR,XN,YN,ZN);

  { Computes Intersections between edges and scanline }
  L := ScanLineTriangleIntersection(T,Z,A1,A2,B1,B2);

  Smin := Round(Min(L[1].X,L[2].X));
  Smax := Round(Max(L[1].X,L[2].X));
  Smin := Confine(Smin,0,Width-1);  Smax := Confine(Smax,0,Width-1);

  j := 0;  SetLength(Result,Smax-Smin+2);
  for i := Smin to Smax do
  begin
    j := j + 1;
    Result[j].P.X := i;
    Result[j].P.Y := Z;
    P := Point3D(0,i,Z);
    P := ReverseScalePanFloat(P,Height,SizeRatio,XPan,YPan);
    Result[j].X := PlanePointDepth(P.Y,P.Z,TR[1].X,TR[1].Y,TR[1].Z,XN,YN,ZN);
  end;
end;  { TCGraphic.ScanLineTriangleIsom }

class function TCGraphic.ScanLineTrianglePersp(T : TTriangle; Z : integer; A1,A2,B1,B2 : Int03;
                                               C : TCamera; Width,Height : integer;
                                               SizeRatio : TFloatType; XPan, YPan : integer) : TScreenLine;
var                  { Determines the intersections between a triangle and a scanline }
  i, j : integer;    { Screen points are pixels with x buffer depth information }
  L : TLine;
  Smin, Smax : integer;
  TR : TTriangle;
  XN,YN,ZN : TFloatType;
  P : T3DPoint;
begin
  { Initializes variables }
  for i := 1 to 3 do
    TR[i] := ReverseScalePanFloat(T[i],Height,SizeRatio,XPan,YPan);

  TriangleNormalVector(TR,XN,YN,ZN);

  for i := 1 to 3 do
    TR[i] := ReversePerspectiveProjection(TR[i],Point3D(0,0,0),C.xlens);

  TriangleNormalVector(TR,XN,YN,ZN);

  { Computes Intersections between edges and scanline }
  L := ScanLineTriangleIntersection(T,Z,A1,A2,B1,B2);

  Smin := Round(Min(L[1].X,L[2].X));
  Smax := Round(Max(L[1].X,L[2].X));
  Smin := Confine(Smin,0,Width-1);  Smax := Confine(Smax,0,Width-1);

  j := 0;  SetLength(Result,Smax-Smin+2);
  for i := Smin to Smax do
  begin
    j := j + 1;
    Result[j].P.X := i;
    Result[j].P.Y := Z;
    P := Point3D(0,i,Z);
    P := ReverseScalePanFloat(P,Height,SizeRatio,XPan,YPan);
    Result[j].X := PlanePointDepthPersp(P.Y,P.Z,C.xlens,TR[1].X,TR[1].Y,TR[1].Z,XN,YN,ZN);
  end;
end;  { TCGraphic.ScanLineTrianglePersp }

class procedure TCGraphic.RasterizeTriangleIsom(T : TTriangle; TriangleIndex : integer;
                                                C : TCamera; BmpWidth, BmpHeight : integer;
                                                SizeRatio : TFloatType; XPan, YPan : integer;
                                                var Buffer : TMatrizNxN;
                                                var TID : TMatrizINxN);
var                                 { Compare the rasterized triangle pixels depth with the screen depth Buffer }
  Index1,Index2,Index3 : Int03;     { Updates TID (Triangle ID) if the depth is closer to the observer }
  ZInt : integer;
  i, j : integer;                   { PERSPECTIVE - OFF }
  Zmin, Zmax : integer;
  PixelLine : TScreenLine;          { EDGES - OFF }
begin
  If (TriangleInBounds(T,C.xlens,BmpWidth,BmpHeight,Zmin,Zmax)) and
     (Greater(abs(TriangleAreaYZ(T)),0,RelPrecision)) then
  begin
    TriangleMaximumVerticalGapIndex(T,Index1,Index2);
    Index3 := TrianglePointIndex[Index1,Index2];
    ZInt := Round(T[Index3].Z);

    If (Zmin<ZInt) and (ZInt<ZMax) then
    begin
      { ScanLines from Lowest to Intermediate }
      for i := Zmin to ZInt do
      begin
        SetLength(PixelLine,0);
        PixelLine := ScanLineTriangleIsom(T,i,Index1,Index2,Index1,Index3,C,BmpWidth,BmpHeight,SizeRatio,XPan,YPan);
        ScanLineXBufferUpdate(TriangleIndex,i,PixelLine,C,Buffer,TID);
      end;
      { ScanLines from Intermediate to Highest }
      for i := ZInt to ZMax do
      begin
        SetLength(PixelLine,0);
        PixelLine := ScanLineTriangleIsom(T,i,Index1,Index2,Index2,Index3,C,BmpWidth,BmpHeight,SizeRatio,XPan,YPan);
        ScanLineXBufferUpdate(TriangleIndex,i,PixelLine,C,Buffer,TID);
      end;
    end
    Else If ZInt<=Zmin then
    begin
      for i := Zmin to ZMax do
      begin
        SetLength(PixelLine,0);
        PixelLine := ScanLineTriangleIsom(T,i,Index1,Index2,Index2,Index3,C,BmpWidth,BmpHeight,SizeRatio,XPan,YPan);
        ScanLineXBufferUpdate(TriangleIndex,i,PixelLine,C,Buffer,TID);
      end;
    end
    Else If ZInt>=ZMax then
    begin
      for i := Zmin to ZMax do
      begin
        SetLength(PixelLine,0);
        PixelLine := ScanLineTriangleIsom(T,i,Index1,Index2,Index1,Index3,C,BmpWidth,BmpHeight,SizeRatio,XPan,YPan);
        ScanLineXBufferUpdate(TriangleIndex,i,PixelLine,C,Buffer,TID);
      end;
    end;
  end;
end;  { TCGraphic.RasterizeTriangleIsom }

class procedure TCGraphic.RasterizeTriangleIsom(T : TTriangle; TriangleIndex : integer;
                                                C : TCamera; BmpWidth, BmpHeight : integer;
                                                SizeRatio : TFloatType; XPan, YPan : integer;
                                                var Buffer : TMatrizNxN;
                                                var TID : TMatrizINxN;
                                                var EdgeID : TMatrizBNxN);
var                                 { Compare the rasterized triangle pixels depth with the screen depth Buffer }
  Index1,Index2,Index3 : Int03;     { Updates TID (Triangle ID) if the depth is closer to the observer }
  ZInt : integer;
  i : integer;                      { PERSPECTIVE - OFF }
  Zmin, Zmax : integer;
  PixelLine : TScreenLine;          { EDGES - ON }
begin
  If (TriangleInBounds(T,C.xlens,BmpWidth,BmpHeight,Zmin,Zmax)) and
     (Greater(abs(TriangleAreaYZ(T)),0,RelPrecision)) then
  begin
    TriangleMaximumVerticalGapIndex(T,Index1,Index2);
    Index3 := TrianglePointIndex[Index1,Index2];
    ZInt := Round(T[Index3].Z);

    If (Zmin<ZInt) and (ZInt<ZMax) then
    begin
      { ScanLines from Lowest to Intermediate }
      for i := Zmin to ZInt do
      begin
        SetLength(PixelLine,0);
        PixelLine := ScanLineTriangleIsom(T,i,Index1,Index2,Index1,Index3,C,BmpWidth,BmpHeight,SizeRatio,XPan,YPan);
        ScanLineXBufferUpdate(T,TriangleIndex,i,PixelLine,C,Buffer,TID,EdgeID);
      end;
      { ScanLines from Intermediate to Highest }
      for i := ZInt to ZMax do
      begin
        SetLength(PixelLine,0);
        PixelLine := ScanLineTriangleIsom(T,i,Index1,Index2,Index2,Index3,C,BmpWidth,BmpHeight,SizeRatio,XPan,YPan);
        ScanLineXBufferUpdate(T,TriangleIndex,i,PixelLine,C,Buffer,TID,EdgeID);
      end;
    end
    Else If ZInt<=Zmin then
    begin
      for i := Zmin to ZMax do
      begin
        SetLength(PixelLine,0);
        PixelLine := ScanLineTriangleIsom(T,i,Index1,Index2,Index2,Index3,C,BmpWidth,BmpHeight,SizeRatio,XPan,YPan);
        ScanLineXBufferUpdate(T,TriangleIndex,i,PixelLine,C,Buffer,TID,EdgeID);
      end;
    end
    Else If ZInt>=ZMax then
    begin
      for i := Zmin to ZMax do
      begin
        SetLength(PixelLine,0);
        PixelLine := ScanLineTriangleIsom(T,i,Index1,Index2,Index1,Index3,C,BmpWidth,BmpHeight,SizeRatio,XPan,YPan);
        ScanLineXBufferUpdate(T,TriangleIndex,i,PixelLine,C,Buffer,TID,EdgeID);
      end;
    end;
  end;
end;  { TCGraphic.RasterizeTriangleIsom }

class procedure TCGraphic.RasterizeTrianglePersp(T : TTriangle; TriangleIndex : integer;
                                                 C : TCamera; BmpWidth, BmpHeight : integer;
                                                 SizeRatio : TFloatType; XPan, YPan : integer;
                                                 var Buffer : TMatrizNxN;
                                                 var TID : TMatrizINxN);
var                                 { Compare the rasterized triangle pixels depth with the screen depth Buffer }
  Index1,Index2,Index3 : Int03;     { Updates TID (Triangle ID) if the depth is closer to the observer }
  ZInt : integer;
  i : integer;                      { PERSPECTIVE - ON }
  Zmin, Zmax : integer;
  PixelLine : TScreenLine;          { EDGES - OFF }
begin
  If (TriangleInBounds(T,C.xlens,BmpWidth,BmpHeight,Zmin,Zmax)) and
     (Greater(abs(TriangleAreaYZ(T)),0,RelPrecision)) then
  begin
    TriangleMaximumVerticalGapIndex(T,Index1,Index2);
    Index3 := TrianglePointIndex[Index1,Index2];
    ZInt := Round(T[Index3].Z);

    If (Zmin<ZInt) and (ZInt<ZMax) then
    begin
      { ScanLines from Lowest to Intermediate }
      for i := Zmin to ZInt do
      begin
        SetLength(PixelLine,0);
        PixelLine := ScanLineTrianglePersp(T,i,Index1,Index2,Index1,Index3,C,BmpWidth,BmpHeight,SizeRatio,XPan,YPan);
        ScanLineXBufferUpdate(TriangleIndex,i,PixelLine,C,Buffer,TID);
      end;
      { ScanLines from Intermediate to Highest }
      for i := ZInt to ZMax do
      begin
        SetLength(PixelLine,0);
        PixelLine := ScanLineTrianglePersp(T,i,Index1,Index2,Index2,Index3,C,BmpWidth,BmpHeight,SizeRatio,XPan,YPan);
        ScanLineXBufferUpdate(TriangleIndex,i,PixelLine,C,Buffer,TID);
      end;
    end
    Else If ZInt<=Zmin then
    begin
      for i := Zmin to ZMax do
      begin
        SetLength(PixelLine,0);
        PixelLine := ScanLineTrianglePersp(T,i,Index1,Index2,Index2,Index3,C,BmpWidth,BmpHeight,SizeRatio,XPan,YPan);
        ScanLineXBufferUpdate(TriangleIndex,i,PixelLine,C,Buffer,TID);
      end;
    end
    Else If ZInt>=ZMax then
    begin
      for i := Zmin to ZMax do
      begin
        SetLength(PixelLine,0);
        PixelLine := ScanLineTrianglePersp(T,i,Index1,Index2,Index1,Index3,C,BmpWidth,BmpHeight,SizeRatio,XPan,YPan);
        ScanLineXBufferUpdate(TriangleIndex,i,PixelLine,C,Buffer,TID);
      end;
    end;
  end;
end;  { TCGraphic.RasterizeTrianglePersp }

class procedure TCGraphic.RasterizeTrianglePersp(T : TTriangle; TriangleIndex : integer;
                                                 C : TCamera; BmpWidth, BmpHeight : integer;
                                                 SizeRatio : TFloatType; XPan, YPan : integer;
                                                 var Buffer : TMatrizNxN;
                                                 var TID : TMatrizINxN;
                                                 var EdgeID : TMatrizBNxN);
var                                 { Compare the rasterized triangle pixels depth with the screen depth Buffer }
  Index1,Index2,Index3 : Int03;     { Updates TID (Triangle ID) if the depth is closer to the observer }
  ZInt : integer;
  i : integer;                      { PERSPECTIVE - ON }
  Zmin, Zmax : integer;
  PixelLine : TScreenLine;          { EDGES - ON }
begin
  If (TriangleInBounds(T,C.xlens,BmpWidth,BmpHeight,Zmin,Zmax)) and
     (Greater(abs(TriangleAreaYZ(T)),0,RelPrecision)) then
  begin
    TriangleMaximumVerticalGapIndex(T,Index1,Index2);
    Index3 := TrianglePointIndex[Index1,Index2];
    ZInt := Round(T[Index3].Z);

    If (Zmin<ZInt) and (ZInt<ZMax) then
    begin
      { ScanLines from Lowest to Intermediate }
      for i := Zmin to ZInt do
      begin
        SetLength(PixelLine,0);
        PixelLine := ScanLineTrianglePersp(T,i,Index1,Index2,Index1,Index3,C,BmpWidth,BmpHeight,SizeRatio,XPan,YPan);
        ScanLineXBufferUpdate(T,TriangleIndex,i,PixelLine,C,Buffer,TID,EdgeID);
      end;
      { ScanLines from Intermediate to Highest }
      for i := ZInt to ZMax do
      begin
        SetLength(PixelLine,0);
        PixelLine := ScanLineTrianglePersp(T,i,Index1,Index2,Index2,Index3,C,BmpWidth,BmpHeight,SizeRatio,XPan,YPan);
        ScanLineXBufferUpdate(T,TriangleIndex,i,PixelLine,C,Buffer,TID,EdgeID);
      end;
    end
    Else If ZInt<=Zmin then
    begin
      for i := Zmin to ZMax do
      begin
        SetLength(PixelLine,0);
        PixelLine := ScanLineTrianglePersp(T,i,Index1,Index2,Index2,Index3,C,BmpWidth,BmpHeight,SizeRatio,XPan,YPan);
        ScanLineXBufferUpdate(T,TriangleIndex,i,PixelLine,C,Buffer,TID,EdgeID);
      end;
    end
    Else If ZInt>=ZMax then
    begin
      for i := Zmin to ZMax do
      begin
        SetLength(PixelLine,0);
        PixelLine := ScanLineTrianglePersp(T,i,Index1,Index2,Index1,Index3,C,BmpWidth,BmpHeight,SizeRatio,XPan,YPan);
        ScanLineXBufferUpdate(T,TriangleIndex,i,PixelLine,C,Buffer,TID,EdgeID);
      end;
    end;
  end;
end;  { TCGraphic.RasterizeTrianglePersp }

class procedure TCGraphic.ScanLineXBufferUpdate(TriangleIndex : integer; Z : integer;
                                                PixelLine : TScreenLine; C : TCamera;
                                                var Buffer : TMatrizNxN; var TID : TMatrizINxN);
var                                 { Compare the rasterized triangle pixels depth with the screen depth Buffer }
  i, j, N : integer;                { Updates TID (Triangle ID) if the depth is closer to the observer }
begin                               { EDGES - OFF }
  N := High(PixelLine);
  If N > 0 then  { not an empty array }
  begin
    j := 0;
    for i := PixelLine[1].P.X to PixelLine[N].P.X do
    begin
      j := j + 1;
      If (Lower(Buffer[i,Z],PixelLine[j].X,RelPrecision)) and (LowerEq(PixelLine[j].X,C.xlens,RelPrecision)) then
      begin
        Buffer[i,Z] := PixelLine[j].X;      { X-Buffer }
        TID[i,Z] := TriangleIndex;          { triangle index }
      end;
    end;
  end;
end;  { TCGraphic.ScanLineXBufferUpdate }

class procedure TCGraphic.ScanLineXBufferUpdate(T : TTriangle; TriangleIndex : integer; Z : integer;
                                                PixelLine : TScreenLine; C : TCamera;
                                                var Buffer : TMatrizNxN; var TID : TMatrizINxN;
                                                var EdgeID : TMatrizBNxN);
var                                 { Compare the rasterized triangle pixels depth with the screen depth Buffer }
  i, j, N : integer;                { Updates TID (Triangle ID) if the depth is closer to the observer }
begin                               { EDGES - ON }
  N := High(PixelLine);
  If N > 0 then  { not an empty array }
  begin
    j := 0;
    for i := PixelLine[1].P.X to PixelLine[N].P.X do
    begin
      j := j + 1;
      If (Lower(Buffer[i,Z],PixelLine[j].X,RelPrecision)) and (LowerEq(PixelLine[j].X,C.xlens,RelPrecision)) then
      begin
        Buffer[i,Z] := PixelLine[j].X;      { X-Buffer }
        TID[i,Z] := TriangleIndex;          { triangle index }
        If (PixelOnTriangleEdge(PixelLine[j].P.X,Z,T)) or (i = PixelLine[1].P.X)
        or (i = PixelLine[N].P.X) then
          EdgeID[i,Z] := True               { edge pixel }
        Else EdgeID[i,Z] := False;
      end;
    end;
  end;
end;  { TCGraphic.ScanLineXBufferUpdate }

class function TCGraphic.TriangleInBounds(T : TTriangle; CameraXlens : TFloatType;
                                          BmpWidth, BmpHeight : integer;
                                          var Zmin, Zmax : integer) : boolean;
begin        { Checks if the triangle T is not totally outside the screen frame }
             { and gives the maximum and minimum scanlines heights }
  Zmin := Round(TriangleMinZ(T));
  Zmax := Round(TriangleMaxZ(T));
  If (not (((Zmin < 0) and (Zmax < 0)) or
           ((Zmin > BmpHeight-1) and (Zmax > BmpHeight-1)))) and
     (TriangleLowerEqX(T,CameraXlens)) then
  begin
    Result := True;
    Zmin := Confine(Zmin,0,BmpHeight-1);  Zmax := Confine(Zmax,0,BmpHeight-1);
  end
  Else Result := False;
end;  { TCGraphic.TriangleInBounds }

class procedure TCGraphic.RasterizeSubTriangle_Isom(T : TTriangle; Index : Int03; TriangleIndex : integer;
                                                    C : TCamera; BmpWidth, BmpHeight : integer;
                                                    SizeRatio : TFloatType; XPan, YPan : integer;
                                                    var Buffer : TMatrizNxN;
                                                    var TID : TMatrizINxN);
var                              { Compare the rasterized triangle pixels depth with the screen depth Buffer }
  i : integer;                   { Updates TID (Triangle ID) if the depth is closer to the observer }
  Zmin, Zmax : integer;          { PERSPECTIVE - OFF }
  PixelLine : TScreenLine;       { EDGES - OFF }
begin
  If (TriangleInBounds(T,C.xlens,BmpWidth,BmpHeight,Zmin,Zmax)) and
     (Greater(abs(TriangleAreaYZ(T)),0,RelPrecision)) then
  begin
    for i := Zmin to Zmax do
    begin
      SetLength(PixelLine,0);
      PixelLine := ScanLineSubTriangle_Isom(T,Index,i,C,BmpWidth,BmpHeight,SizeRatio,XPan,YPan);
      ScanLineXBufferUpdate(TriangleIndex,i,PixelLine,C,Buffer,TID);
    end;
  end;
end;  { TCGraphic.RasterizeSubTriangle_Isom }

class procedure TCGraphic.RasterizeSubTriangle_Isom(T : TTriangle; Index : Int03; TriangleIndex : integer;
                                                    C : TCamera; BmpWidth, BmpHeight : integer;
                                                    SizeRatio : TFloatType; XPan, YPan : integer;
                                                    var Buffer : TMatrizNxN;
                                                    var TID : TMatrizINxN;
                                                    var EdgeID : TMatrizBNxN);
var                              { Compare the rasterized triangle pixels depth with the screen depth Buffer }
  i : integer;                   { Updates TID (Triangle Identity) if the depth is closer to the observer }
  Zmin, Zmax : integer;          { PERSPECTIVE - OFF }
  PixelLine : TScreenLine;       { EDGES - ON }
begin
  If (TriangleInBounds(T,C.xlens,BmpWidth,BmpHeight,Zmin,Zmax)) and
     (Greater(abs(TriangleAreaYZ(T)),0,RelPrecision)) then
  begin
    for i := Zmin to Zmax do
    begin
      SetLength(PixelLine,0);
      PixelLine := ScanLineSubTriangle_Isom(T,Index,i,C,BmpWidth,BmpHeight,SizeRatio,XPan,YPan);
      ScanLineXBufferUpdate(T,TriangleIndex,i,PixelLine,C,Buffer,TID,EdgeID);
    end;
  end;
end;  { TCGraphic.RasterizeSubTriangle_Isom }

class procedure TCGraphic.RasterizeSubTriangle_Persp(T : TTriangle; Index : Int03; TriangleIndex : integer;
                                                     C : TCamera; BmpWidth, BmpHeight : integer;
                                                     SizeRatio : TFloatType; XPan, YPan : integer;
                                                     var Buffer : TMatrizNxN;
                                                     var TID : TMatrizINxN);
var                              { Compare the rasterized triangle pixels depth with the screen depth Buffer }
  i : integer;                   { Updates TID (Triangle Identity) if the depth is closer to the observer }
  Zmin, Zmax : integer;          { PERSPECTIVE - ON }
  PixelLine : TScreenLine;       { EDGES - OFF }
begin
  If (TriangleInBounds(T,C.xlens,BmpWidth,BmpHeight,Zmin,Zmax)) and
     (Greater(abs(TriangleAreaYZ(T)),0,RelPrecision)) then
  begin
    for i := Zmin to Zmax do
    begin
      SetLength(PixelLine,0);
      PixelLine := ScanLineSubTriangle_Persp(T,Index,i,C,BmpWidth,BmpHeight,SizeRatio,XPan,YPan);
      ScanLineXBufferUpdate(TriangleIndex,i,PixelLine,C,Buffer,TID);
    end;
  end;
end;  { TCGraphic.RasterizeSubTriangle_Persp }

class procedure TCGraphic.RasterizeSubTriangle_Persp(T : TTriangle; Index : Int03; TriangleIndex : integer;
                                                     C : TCamera; BmpWidth, BmpHeight : integer;
                                                     SizeRatio : TFloatType; XPan, YPan : integer;
                                                     var Buffer : TMatrizNxN;
                                                     var TID : TMatrizINxN;
                                                     var EdgeID : TMatrizBNxN);
var                              { Compare the rasterized triangle pixels depth with the screen depth Buffer }
  i : integer;                   { Updates TID (Triangle Identity) if the depth is closer to the observer }
  Zmin, Zmax : integer;          { PERSPECTIVE - ON }
  PixelLine : TScreenLine;       { EDGES - ON }
begin
  If (TriangleInBounds(T,C.xlens,BmpWidth,BmpHeight,Zmin,Zmax)) and
     (Greater(abs(TriangleAreaYZ(T)),0,RelPrecision))  then
  begin
    for i := Zmin to Zmax do
    begin
      SetLength(PixelLine,0);
      PixelLine := ScanLineSubTriangle_Persp(T,Index,i,C,BmpWidth,BmpHeight,SizeRatio,XPan,YPan);
      ScanLineXBufferUpdate(T,TriangleIndex,i,PixelLine,C,Buffer,TID,EdgeID);
    end;
  end;
end;  { TCGraphic.RasterizeSubTriangle_Persp }

class procedure TCGraphic.XBuffer_Mesh(Faces : TMesh; BmpWidth, BmpHeight : integer; C : TCamera;
                                       SizeRatio : TFloatType; XPan, YPan : integer;
                                       var Buffer : TMatrizNxN;
                                       var TID : TMatrizINxN);
var                               { XBuffer algorithm that determines the depth of each pixel that }
  i, j  : integer;                { belongs to each polygon on the screen rectangle. }
  PixelLine : TScreenLine;
  P : T3DPoint;                   { EDGES - OFF }
  Index1, Index2 : Int03;
begin
  { Mesh as it is shown on screen }
  for i := 1 to Faces.N do
    for j := 1 to 3 do
      Faces.F[i][j] := ScalePanFloat(Faces.F[i][j],BmpHeight,SizeRatio,XPan,YPan);
  { Identifier of triangle index from which the pixel belongs }
  TID := InitializeMatrix(BmpHeight,BmpWidth,0);

  If C.Perspective = False then           { Perspective - OFF }
  begin
    for i := 1 to Faces.N do
      RasterizeTriangleIsom(Faces.F[i],i,C,BmpWidth,BmpHeight,SizeRatio,XPan,YPan,Buffer,TID);
  end
  Else If C.Perspective then            { Perspective - ON }
  begin
    for i := 1 to Faces.N do
      RasterizeTrianglePersp(Faces.F[i],i,C,BmpWidth,BmpHeight,SizeRatio,XPan,YPan,Buffer,TID);
  end;
end;  { TCGraphic.XBuffer_Mesh }

class procedure TCGraphic.XBuffer_Mesh(Faces : TMesh; BmpWidth, BmpHeight : integer; C : TCamera;
                                       SizeRatio : TFloatType; XPan, YPan : integer;
                                       var Buffer : TMatrizNxN;
                                       var TID : TMatrizINxN;
                                       var EdgeID : TMatrizBNxN);
var                               { XBuffer algorithm that determines the depth of each pixel that }
  i, j  : integer;                { belongs to each polygon on the screen rectangle. }
  PixelLine : TScreenLine;
  P : T3DPoint;                   { EDGES - ON }
  Index1, Index2 : Int03;
begin
  { Mesh as it is shown on screen }
  for i := 1 to Faces.N do
    for j := 1 to 3 do
      Faces.F[i][j] := ScalePanFloat(Faces.F[i][j],BmpHeight,SizeRatio,XPan,YPan);

  { Identifier of triangle index from which the pixel belongs }
  TID := InitializeMatrix(BmpHeight,BmpWidth,0);
  { Pixel is or not on a triangle edge }
  EdgeID := InitializeMatrix(BmpHeight,BmpWidth,False);

  If C.Perspective = False then           { Perspective - OFF }
  begin
    for i := 1 to Faces.N do
      RasterizeTriangleIsom(Faces.F[i],i,C,BmpWidth,BmpHeight,SizeRatio,XPan,YPan,Buffer,TID,EdgeID);
  end
  Else If C.Perspective then       { Perspective - ON }
  begin
    for i := 1 to Faces.N do
      RasterizeTrianglePersp(Faces.F[i],i,C,BmpWidth,BmpHeight,SizeRatio,XPan,YPan,Buffer,TID,EdgeID);
  end;
end;  { TCGraphic.XBuffer_Mesh }

class procedure TCGraphic.DrawPolXBuffer_NormalVector(Face : TTriangle; BmpHeight : integer; XBuffer : TFloatType;
                                                      IndexX, IndexY : integer; XLens : TFloatType;
                                                      SizeRatio : TFloatType; XPan, YPan : integer;
                                                      var P : T3DPoint;
                                                      var XN, YN, ZN : TFloatType);
var                   { Finds normal vector of Face in the Pixel (XBuffer, IndexX, IndexY) }
  i : integer;        { Perspective Correction - ON }
  T : TTriangle;
begin
  P := ReverseScalePanFloat(Point3D(XBuffer,IndexX,IndexY),BmpHeight,SizeRatio,XPan,YPan);
  P.X := XBuffer;
  for i := 1 to 3 do
    T[i] := ReverseScalePanFloat(Face[i],BmpHeight,SizeRatio,XPan,YPan);

  { Reverse Perspective Transformation }
  P := TCGraphic.ReversePerspectiveProjection(P,Point3D(0,0,0),XLens);
  for i := 1 to 3 do
    T[i] := TCGraphic.ReversePerspectiveProjection(T[i],Point3D(0,0,0),XLens);

  { Normal Vector }
  TriangleNormalVector(T,XN,YN,ZN);
end;  { TCGraphic.DrawPolXBuffer_NormalVector }

class procedure TCGraphic.DrawPolXBuffer_NormalVector(Face : TTriangle; BmpHeight : integer; XBuffer : TFloatType;
                                                      IndexX, IndexY : integer; SizeRatio : TFloatType;
                                                      XPan, YPan : integer;
                                                      var P : T3DPoint;
                                                      var XN, YN, ZN : TFloatType);
var       { Finds normal vector of in the Pixel (XBuffer, IndexX, IndexY) }
  i : integer;        { Perspective Correction - OFF }
  T : TTriangle;
begin
  P := ReverseScalePanFloat(Point3D(XBuffer,IndexX,IndexY),BmpHeight,SizeRatio,XPan,YPan);
  P.X := XBuffer;
  for i := 1 to 3 do
    T[i] := ReverseScalePanFloat(Face[i],BmpHeight,SizeRatio,XPan,YPan);

  { Normal Vector }
  TriangleNormalVector(T,XN,YN,ZN);
end;  { TCGraphic.DrawPolXBuffer_NormalVector }

class procedure TCGraphic.DrawPolXBuffer_BMP(Faces : TMesh; Bmp : TBitmap; PenColor : TColor;
                                             Buffer : TMatrizNxN; ID : TMatrizINxN; EdgeID : TMatrizBNxN;
                                             AmbientLight : TAmbientLight; NoLights : integer;
                                             PtsL : TLights; M : TMaterial; XLens : TFloatType;
                                             SizeRatio : TFloatType; XPan, YPan : integer);
var
  i, j : integer;                   { Render algorithm that executes the mapped scanlines mapped on a BMP }
  P : T3DPoint;
  XN,YN,ZN : TFloatType;
  LR,LG,LB : TFloatType;            { Perspective Correction - ON }
  PenRed,PenGreen,PenBlue : byte;
  BmpScanLine : PRGB24Array;        { PenColor Colored Edges - ON }
begin
  ColorToRGBBytes(PenColor,PenRed,PenGreen,PenBlue);
  for i := 0 to Bmp.Height-1 do
  begin
    BmpScanLine := Bmp.ScanLine[i];
    for j := 0 to Bmp.Width-1 do
    begin
      If ID[j,i] > 0 then
      begin
        { Normal Vector }
        DrawPolXBuffer_NormalVector(Faces.F[ID[j,i]],Bmp.Height,Buffer[j,i],j,i,XLens,SizeRatio,
                                    XPan,YPan,P,XN,YN,ZN);
        { Edge Color }
        If EdgeID[j,i] then
        begin
          BmpScanLine[j].R := PenRed;
          BmpScanLine[j].G := PenGreen;
          BmpScanLine[j].B := PenBlue;
        end
        Else begin
          { Light Intensity }
          TCGraphic.PhongShade(AmbientLight,NoLights,PtsL,M,P.X,P.Y,P.Z,XN,YN,ZN,LR,LG,LB);
          { Limits Lights Intensities between 0 and 255 }
          LR := Confine(LR,0,255);  LG := Confine(LG,0,255);  LB := Confine(LB,0,255);

          BmpScanLine[j].R := Round(LR);
          BmpScanLine[j].G := Round(LG);
          BmpScanLine[j].B := Round(LB);
        end;
      end;
    end;
  end;
end;  { TCGraphic.DrawPolXBuffer_BMP }

class procedure TCGraphic.DrawPolXBuffer_BMP(Faces : TMesh; Bmp : TBitmap; Buffer : TMatrizNxN;
                                             ID : TMatrizINxN; AmbientLight : TAmbientLight;
                                             NoLights : integer; PtsL : TLights; M : TMaterial;
                                             XLens : TFloatType; SizeRatio : TFloatType;
                                             XPan, YPan : integer);
var
  i, j : integer;                   { Render algorithm that executes the mapped scanlines mapped on a BMP }
  P : T3DPoint;
  XN,YN,ZN : TFloatType;            { Perspective Correction - ON }
  LR,LG,LB : TFloatType;
  BmpScanLine : PRGB24Array;        { PenColor Colored Edges - OFF }
begin                           

  for i := 0 to Bmp.Height-1 do
  begin
    BmpScanLine := Bmp.ScanLine[i];
    for j := 0 to Bmp.Width-1 do
    begin
      If ID[j,i] > 0 then
      begin
        { Normal Vector }
        DrawPolXBuffer_NormalVector(Faces.F[ID[j,i]],Bmp.Height,Buffer[j,i],j,i,XLens,SizeRatio,
                                    XPan,YPan,P,XN,YN,ZN);
        { Light Intensity }
        TCGraphic.PhongShade(AmbientLight,NoLights,PtsL,M,P.X,P.Y,P.Z,XN,YN,ZN,LR,LG,LB);
        { Limits Lights Intensities between 0 and 255 }
        LR := Confine(LR,0,255);  LG := Confine(LG,0,255);  LB := Confine(LB,0,255);

        BmpScanLine[j].R := Round(LR);
        BmpScanLine[j].G := Round(LG);
        BmpScanLine[j].B := Round(LB);
      end;
    end;
  end;
end;  { TCGraphic.DrawPolXBuffer_BMP }

class procedure TCGraphic.DrawPolXBuffer_BMP(Faces : TMesh; Bmp : TBitmap; PenColor : TColor;
                                             Buffer : TMatrizNxN; ID : TMatrizINxN; EdgeID : TMatrizBNxN;
                                             AmbientLight : TAmbientLight; NoLights : integer;
                                             PtsL : TLights; M : TMaterial;
                                             SizeRatio : TFloatType; XPan, YPan : integer);
var
  i, j : integer;                   { Render algorithm that executes the mapped scanlines mapped on a BMP }
  P : T3DPoint;
  XN,YN,ZN : TFloatType;
  LR,LG,LB : TFloatType;            { Perspective Correction - OFF }
  PenRed,PenGreen,PenBlue : byte;
  BmpScanLine : PRGB24Array;        { PenColor Colored Edges - ON }
begin
  ColorToRGBBytes(PenColor,PenRed,PenGreen,PenBlue);
  for i := 0 to Bmp.Height-1 do
  begin
    BmpScanLine := Bmp.ScanLine[i];
    for j := 0 to Bmp.Width-1 do
    begin
      If ID[j,i] > 0 then
      begin
        { Normal Vector }
        DrawPolXBuffer_NormalVector(Faces.F[ID[j,i]],Bmp.Height,Buffer[j,i],j,i,SizeRatio,
                                    XPan,YPan,P,XN,YN,ZN);

        { Edge Color }
        If EdgeID[j,i] then
        begin
          BmpScanLine[j].R := PenRed;
          BmpScanLine[j].G := PenGreen;
          BmpScanLine[j].B := PenBlue;
        end
        Else begin
          { Light Intensity }
          TCGraphic.PhongShade(AmbientLight,NoLights,PtsL,M,P.X,P.Y,P.Z,XN,YN,ZN,LR,LG,LB);
          { Limits Lights Intensities between 0 and 255 }
          LR := Confine(LR,0,255);  LG := Confine(LG,0,255);  LB := Confine(LB,0,255);

          BmpScanLine[j].R := Round(LR);
          BmpScanLine[j].G := Round(LG);
          BmpScanLine[j].B := Round(LB);
        end;
      end;
    end;
  end;
end;  { TCGraphic.DrawPolXBuffer_BMP }

class procedure TCGraphic.DrawPolXBuffer_BMP(Faces : TMesh; Bmp : TBitmap;
                                             Buffer : TMatrizNxN; ID : TMatrizINxN;
                                             AmbientLight : TAmbientLight;
                                             NoLights : integer; PtsL : TLights; M : TMaterial;
                                             SizeRatio : TFloatType; XPan, YPan : integer);
var
  i, j : integer;               { Render algorithm that executes the mapped scanlines mapped on a BMP }
  P : T3DPoint;
  XN,YN,ZN : TFloatType;        { Perspective Correction - OFF }
  LR,LG,LB : TFloatType;
  BmpScanLine : PRGB24Array;
begin                           { PenColor Colored Edges - OFF }

  for i := 0 to Bmp.Height-1 do
  begin
    BmpScanLine := Bmp.ScanLine[i];
    for j := 0 to Bmp.Width-1 do
    begin
      If ID[j,i] > 0 then
      begin
        { Normal Vector }
        DrawPolXBuffer_NormalVector(Faces.F[ID[j,i]],Bmp.Height,Buffer[j,i],j,i,SizeRatio,
                                    XPan,YPan,P,XN,YN,ZN);

        { Light Intensity }
        TCGraphic.PhongShade(AmbientLight,NoLights,PtsL,M,P.X,P.Y,P.Z,XN,YN,ZN,LR,LG,LB);
        { Limits Lights Intensities between 0 and 255 }
        LR := Confine(LR,0,255);  LG := Confine(LG,0,255);  LB := Confine(LB,0,255);

        BmpScanLine[j].R := Round(LR);
        BmpScanLine[j].G := Round(LG);
        BmpScanLine[j].B := Round(LB);

        //Bmp.Canvas.Pixels[j,i] := RGB(Round(LR),Round(LG),Round(LB));
      end;
    end;
  end;
end;  { TCGraphic.DrawPolXBuffer_BMP }

class function TCGraphic.InitializeBmpXBuffer(Bmp : TBitmap; MinXBuffer : TFloatType) : TMatrizNxN;
var                                 { ATENÇÃO! Usar Pointer para Result[i,j] }
  i, j : integer;
begin
  SetLength(Result,Bmp.Width+1);
  for i := 0 to Bmp.Width do
  begin
    SetLength(Result[i],Bmp.Height+1);
    for j := 0 to Bmp.Height do
    begin
      Result[i,j] := MinXBuffer;
    end;
  end;
end;  { TCGraphic.InitializeBmpXBuffer }

class procedure TCGraphic.InitializeBmpXBuffer(BmpHeight, BmpWidth : integer; MinXBuffer : TFloatType; var Buffer : TMatrizNxN);
var                                 { ATENÇÃO! Usar Pointer para Result[i,j] }
  i, j : integer;
begin
  for i := 0 to BmpWidth do
    for j := 0 to BmpHeight do
      Buffer[i,j] := MinXBuffer;
end;  { TCGraphic.InitializeBmpXBuffer }

class procedure TCGraphic.MBase2DOrto(xo : TFloatType; yo : TFloatType; x1 : TFloatType; y1 : TFloatType; x2 : TFloatType; y2 : TFloatType;
                                      var x3 : TFloatType; var y3 : TFloatType);
begin
  If (Unequal(x1,x2,RelPrecision)) and (Unequal(y1,y2,RelPrecision)) then
  begin
    x3 := (((xo-x1)*(x2-x1))+((yo-y1)*(y2-y1)))/hypot(x2-x1,y2-y1);
    y3 := (((xo-x1)*(y2-y1))-((yo-y1)*(x2-x1)))/hypot(x2-x1,y2-y1);
  end
  Else If (Equal(x1,x2,RelPrecision)) and (Equal(y1,y2,RelPrecision)) then
  begin
    x3 := 0;
    y3 := 0;
  end;
end;  { TCGraphic.MBase2DOrto }

class procedure TCGraphic.IMBase2DOrto(xo : TFloatType; yo : TFloatType; x1 : TFloatType; y1 : TFloatType; x2 : TFloatType; y2 : TFloatType;
                             var x3 : TFloatType; var y3 : TFloatType);
begin
  If (Unequal(x1,x2,RelPrecision)) and (Unequal(y1,y2,RelPrecision)) then
  begin
    x3 := (((xo*(x2-x1))+(yo*(y2-y1)))/hypot(x2-x1,y2-y1))+x1;
    y3 := (((xo*(y2-y1))-(yo*(x2-x1)))/hypot(x2-x1,y2-y1))+y1;
  end
  Else If (Equal(x1,x2,RelPrecision)) and (Equal(y1,y2,RelPrecision)) then
  begin
    x3 := 0;
    y3 := 0;
  end;
end;  { TCGraphic.IMBase2DOrto }

class procedure TCGraphic.ReflectedVector(X, Y, Z, XN, YN, ZN : TFloatType; var XR, YR, ZR : TFloatType);
begin
  { Calcula Vetor de Reflexão - usa Vetor Normal (XN,YN,ZN) e Vetor Incidente (X,Y,Z) }
  VetorUnitario(XN,YN,ZN,XN,YN,ZN);
  XR := X - (2*XN*ProdutoEscalar(X,Y,Z,XN,YN,ZN));
  YR := Y - (2*YN*ProdutoEscalar(X,Y,Z,XN,YN,ZN));
  ZR := Z - (2*ZN*ProdutoEscalar(X,Y,Z,XN,YN,ZN));
end;  { TCGraphic.ReflectedVector }

class function TCGraphic.PhongDiffuseSpecularLight(P : TLight; M : TMaterial;
                                                   X, Y, Z, XN, YN, ZN : TFloatType) : TRGBFloat;
var      { Computes Diffuse plus Specular Quote of lighting: Result = Id*kd*(N.L) + Is*ks*(V.R)^N }
  XR, YR, ZR : TFloatType;                              { L - Incident Light vector  :  (X,Y,Z)-P }
  absN,absL,absV,absR : TFloatType;                     { V - Observer-Object vector : (0,0,0)-(X,Y,Z) }
  L, V : T3DPoint;
  VR : TFloatType;
  VN,LN : TFloatType;
begin
  { L - Incident Light Vector }
  L.X := X-P.Pos.X;  L.Y := Y-P.Pos.Y;  L.Z := Z-P.Pos.Z;

  { V - Object to Observer Vector }
  V.X := 0-X;        V.Y := 0-Y;        V.Z := 0-Z;

  { Verification of Light at same side of Normal }
  LN := ProdutoEscalar(L.X,L.Y,L.Z,XN,YN,ZN);    { Dot Product : L.N }
  If Greater(LN,0,RelPrecision) then
  begin   { not in the same side }
    XN := -XN; YN := -YN; ZN := -ZN;
  end;

  { Computes Reflected Vector from reflection point (X,Y,Z) }
  ReflectedVector(L.X, L.Y, L.Z, XN, YN, ZN, XR, YR, ZR);

  { Computes the dot products L.N and V.R }
  absN := Hypot3D(XN,YN,ZN);      absL := Hypot3D(L.X,L.Y,L.Z);
  absV := Hypot3D(V.X,V.Y,V.Z);   absR := Hypot3D(XR,YR,ZR);
  LN := ProdutoEscalar(-L.X,-L.Y,-L.Z,XN,YN,ZN);
  VR := ProdutoEscalar(V.X,V.Y,V.Z,XR,YR,ZR);

  If Unequal(absN*absL,0,RelPrecision) then
    LN := LN/(absN*absL)
  Else LN := 0;
  If (Unequal(absV*absR,0,RelPrecision)) and (Greater(VR,0,RelPrecision)) then
    VR := VR/(absV*absR)
  Else VR := 0;

  If Equal(LN,0,RelPrecision) then VR := 0;

  { Verification of Light and Observer at same side of Normal }
  VN := ProdutoEscalar(XN,YN,ZN,V.X,V.Y,V.Z);                       { Dot Product :  V.N }

  { Computes Light Intensity taken by the Observer }
  If GreaterEq(VN,0,RelPrecision) then    { Light and Observer at same side of Normal }
  begin
    Result.R := P.IL.R*((M.kd.R*LN) + (M.ks.R*Power(VR,M.Ns)));
    Result.G := P.IL.G*((M.kd.G*LN) + (M.ks.G*Power(VR,M.Ns)));
    Result.B := P.IL.B*((M.kd.B*LN) + (M.ks.B*Power(VR,M.Ns)));
  end
  Else begin
    Result.R := 0;  Result.G := 0;  Result.B := 0;
  end;
end;  { PhongDiffuseSpecularLight }

class procedure TCGraphic.PhongShade(AmbientLight : TAmbientLight; N: integer; PLights : TLights;
                                     M : TMaterial; X, Y, Z, XN, YN, ZN : TFloatType;
                                     var R, G, B : TFloatType);
{ 0 < kd < 1 }    { ATENÇÃO! As normais nas Edges deveriam ser média das normais dos triângulos vizinhos }
{ Ispecular = Is*ks*(V.R)^ns }  // expoente ns - maior que 100: superfícies polidas
                                       //        menor que 1:   superfícies opacas }
{ Idifuse = Id*kd*(N.L) }
{ Iambient = Ia*ka  }
{ Result = Ia*ka + Sum of Id[i]*kd[i]*(N.L) + Is[i]*ks[i]*(V.R)^N)  }
var                         { Uses PhongDiffuseSpecularLight }
  i : integer;
  At, MaxIntensity : TFloatType;
  P : TRGBFloat;
begin
  R := M.ka.R*AmbientLight.IA.R;
  G := M.ka.G*AmbientLight.IA.G;
  B := M.ka.B*AmbientLight.IA.B;
  MaxIntensity := 1;
  for i := 1 to N do
  begin
    P := PhongDiffuseSpecularLight(PLights[i],M,X,Y,Z,XN,YN,ZN);
    { Attenuation }
    If PLights[i].Attenuation = 0 then       { none }
    begin
      R := R + P.R;
      G := G + P.G;
      B := B + P.B;
      MaxIntensity := MaxIntensity + 2;
    end
    Else If PLights[i].Attenuation = 1 then  { inverse linear }
    begin
      At := 1+Dist_Points(PLights[i].Pos.X,PLights[i].Pos.Y,PLights[i].Pos.Z,X,Y,Z);
      R := R + (P.R/At);
      G := G + (P.G/At);
      B := B + (P.B/At);
      MaxIntensity := MaxIntensity + 2;
    end
    Else If PLights[i].Attenuation = 2 then  { inverse square }
    begin
      At := 1+DistSQR_Points(PLights[i].Pos.X,PLights[i].Pos.Y,PLights[i].Pos.Z,X,Y,Z);
      R := R + (P.R/At);
      G := G + (P.G/At);
      B := B + (P.B/At);
      MaxIntensity := MaxIntensity + 2;
    end;
  end;
  { Normalizes Color Intensities for RGB Spectrum }
  R := R*255/MaxIntensity;
  G := G*255/MaxIntensity;
  B := B*255/MaxIntensity;
end;  { TCGraphic.PhongShade }

class function TCGraphic.PhongDiffuseSpecularLightR(P : TLight; M : TMaterial;
                                                    X, Y, Z, XN, YN, ZN : TFloatType) : TRGBFloat;
var      { Computes Diffuse plus Specular Quote of lighting: Result = Id*kd*(N.L) + Is*ks*(V.R)^N }
  XR, YR, ZR : TFloatType;                              { L - Incident Light vector  :  (X,Y,Z)-P }
  absN,absL,absV,absR : TFloatType;                     { V - Object-Observer vector : (0,0,0)-(X,Y,Z) }
  L, V : T3DPoint;
  VR : TFloatType;
  VN,LN : TFloatType;
begin
  { L - Incident Light Vector }
  L.X := X-P.Pos.X;  L.Y := Y-P.Pos.Y;  L.Z := Z-P.Pos.Z;

  { V - Object to Observer Vector }
  V.X := 0-X;        V.Y := 0-Y;        V.Z := 0-Z;

  { Verification of Light at same side of Normal }
  LN := ProdutoEscalar(L.X,L.Y,L.Z,XN,YN,ZN);      { Dot Product : L.N }
  If LN>0 then  { not in the same side }
  begin
    XN := -XN; YN := -YN; ZN := -ZN;
  end;

  { Computes Reflected Vector from reflection point (X,Y,Z) }
  ReflectedVector(L.X, L.Y, L.Z, XN, YN, ZN, XR, YR, ZR);

  { Computes the dot product L.N and V.R }
  absN := Hypot3D(XN,YN,ZN);      absL := Hypot3D(L.X,L.Y,L.Z);
  absV := Hypot3D(V.X,V.Y,V.Z);   absR := Hypot3D(XR,YR,ZR);
  LN := ProdutoEscalar(-L.X,-L.Y,-L.Z,XN,YN,ZN);
  VR := ProdutoEscalar(V.X,V.Y,V.Z,XR,YR,ZR);

  If absN*absL <> 0 then
    LN := LN/(absN*absL)
  Else LN := 0;
  If (absV*absR<>0) then
    VR := VR/(absV*absR)
  Else VR := 0;

  //If LN = 0 then VR := 0;

  { Verification of Light and Observer at same side of Normal }
  VN := ProdutoEscalar(XN,YN,ZN,V.X,V.Y,V.Z);                       { Dot Product :  V.N }

  { Computes Light Intensity taken by the Observer }
  If (VN)>=0 then    { Light and Observer at same side of Normal }
  begin
    Result.R := P.IL.R*((M.kd.R*LN) + (M.ks.R*Power(Max(VR,0),M.Ns)));
    Result.G := P.IL.G*((M.kd.G*LN) + (M.ks.G*Power(Max(VR,0),M.Ns)));
    Result.B := P.IL.B*((M.kd.B*LN) + (M.ks.B*Power(Max(VR,0),M.Ns)));
  end
  Else begin
    Result.R := 0;  Result.G := 0;  Result.B := 0;
  end;
end;  { PhongDiffuseSpecularLightR }

class procedure TCGraphic.PhongShadeR(AmbientLight : TAmbientLight; N: integer; PLights : TLights;
                                      M : TMaterial; X, Y, Z, XN, YN, ZN : TFloatType;
                                      var R, G, B : TFloatType);
{ 0 < kd < 1 }
{ Ispecular = Is*ks*(V.R)^ns }  // expoente ns - maior que 100: superfícies polidas
                                       //        menor que 1:   superfícies opacas }
{ Idifuse = Id*kd*(N.L) }
{ Iambient = Ia*ka  }
{ Result = Ia*ka + Sum of Id[i]*kd[i]*(N.L) + Is[i]*ks[i]*(V.R)^N)  }
var                    { Uses PhongDiffuseSpecularLightR }
  i : integer;
  At, MaxIntensity : TFloatType;
  P : TRGBFloat;
begin
  R := M.ka.R*AmbientLight.Ia.R;
  G := M.ka.G*AmbientLight.Ia.G;
  B := M.ka.B*AmbientLight.Ia.B;
  MaxIntensity := 1;
  for i := 1 to N do
  begin
    P := PhongDiffuseSpecularLightR(PLights[i],M,X,Y,Z,XN,YN,ZN);
    { Attenuation }
    If PLights[i].Attenuation = 0 then       { none }
    begin
      R := R + P.R;
      G := G + P.G;
      B := B + P.B;
      MaxIntensity := MaxIntensity + 2;
    end
    Else If PLights[i].Attenuation = 1 then  { inverse linear }
    begin
      At := 1+0.002*Dist_Points(PLights[i].Pos.X,PLights[i].Pos.Y,PLights[i].Pos.Z,X,Y,Z);
      R := R + (P.R/At);
      G := G + (P.G/At);
      B := B + (P.B/At);
      MaxIntensity := MaxIntensity + 2;
    end
    Else If PLights[i].Attenuation = 2 then  { inverse square }
    begin
      At := 1+sqr(0.002)*DistSQR_Points(PLights[i].Pos.X,PLights[i].Pos.Y,PLights[i].Pos.Z,X,Y,Z);
      R := R + (P.R/At);
      G := G + (P.G/At);
      B := B + (P.B/At);
      MaxIntensity := MaxIntensity + 2;
    end;
  end;
  {// Gamma Correction If necessary
  R := Power(R,1/2.2);
  G := Power(G,1/2.2);
  B := Power(B,1/2.2);
  MaxIntensity := Power(MaxIntensity,1/2.2);}
  { Normalizes Color Intensities for RGB Spectrum }
  R := R*255/MaxIntensity;
  G := G*255/MaxIntensity;
  B := B*255/MaxIntensity;
end;  { TCGraphic.PhongShadeR }

class function TCGraphic.Clipping_Polygon(PolC, Poly : T3DPline) : TWire;
var
  i : integer;
begin
  for i := 1 to PolC.Npoly-1 do      { Determinar todas as interseções }
  begin                              { entre PolC e Poly }

  end;
                                     { Inserir Interseções em Poly }

                                     { Apagar pontos internos a PolC }

                                     { Passa por cada ponto e verifica se é interseção }

                                     { Se não for: armazena ponto em polígono cópia e }
                                     {  segue para o próximo }

                                     { Se for: verifica se o segmento para o próximo }
                                     {  ponto está dentro de PolC. Senão, seguir para }
                                     {  o próximo ponto }

                                     { Se sim, verificar se passa por outras interseções }
                                     { antes ou se passa dentro de PolC }

                                     { Se não, ligar ponto a um dos vértices de PolC }

                                     { Se sim, inicia uma nova contagem de polígono cópia }

end;  { TCGraphic.Clipping_Polygon }

{---------------------------------------------------------------------------------------------------}
{                                           TZDebug                                                 }
{                                                                                                   }
{ TZDebug class to gather all algorithms related to debugging and making measures on the code       }
{---------------------------------------------------------------------------------------------------}

end.
